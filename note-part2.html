<!DOCTYPE html>
<!-- saved from url=(0082)file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>note-part2</title>
      
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="./note-part2_files/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%93%BE%E6%8E%A5">链接</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">编译器驱动程序</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5">静态链接</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">目标文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">可重定位目标文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8">符号和符号表</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%9E%E6%8E%A5%E5%B1%9E%E6%80%A7">连接属性</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%AC%A6%E5%8F%B7%E8%A1%A8">符号表</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90">符号解析</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%93%BE%E6%8E%A5%E5%99%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7">链接器如何解析多重定义的全局符号</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5">与静态库链接</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%93%BE%E6%8E%A5%E5%99%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%BC%95%E7%94%A8">链接器如何使用静态库来解析引用</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%87%8D%E5%AE%9A%E4%BD%8D">重定位</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%9D%A1%E7%9B%AE">重定位条目</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8">重定位符号引用</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%87%8D%E5%AE%9A%E4%BD%8D-pc-%E7%9B%B8%E5%AF%B9%E5%BC%95%E7%94%A8">重定位 PC 相对引用</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%BB%9D%E5%AF%B9%E5%BC%95%E7%94%A8">重定位绝对引用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">可执行目标文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">加载可执行目标文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93">动态链接共享库</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93">从应用程序中加载和链接共享库</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81">位置无关代码</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#pic-%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8">PIC 数据引用</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#pic-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">PIC 函数调用</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6">库打桩机制</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%93%E6%A1%A9">编译时打桩</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%93%BE%E6%8E%A5%E6%97%B6%E6%89%93%E6%A1%A9">链接时打桩</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%93%E6%A1%A9">运行时打桩</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%A4%84%E7%90%86%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7">处理目标文件的工具</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81">异常控制流</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%BC%82%E5%B8%B8">异常</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB">异常的类别</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%B8%AD%E6%96%AD">中断</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%99%B7%E9%98%B1">陷阱</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%95%85%E9%9A%9C">故障</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%88%E6%AD%A2">终止</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#linuxx86-64-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8">Linux/x86-64 系统中的异常</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#linuxx86-64-%E6%95%85%E9%9A%9C%E5%92%8C%E7%BB%88%E6%AD%A2">Linux/x86-64 故障和终止</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#linuxx86-64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">Linux/x86-64 系统调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%9B%E7%A8%8B">进程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81">逻辑控制流</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%B9%B6%E5%8F%91%E6%B5%81">并发流</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">私有地址空间</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F">用户模式和内核模式</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">上下文切换</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">系统调用错误处理</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B-id">获取进程 ID</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B">创建和终止进程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B">回收子进程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%A4%E5%AE%9A%E7%AD%89%E5%BE%85%E9%9B%86%E5%90%88%E7%9A%84%E6%88%90%E5%91%98">判定等待集合的成员</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA">修改默认行为</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%A3%80%E6%9F%A5%E5%B7%B2%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">检查已回收子进程的退出状态</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6">错误条件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#wait-%E5%87%BD%E6%95%B0"><code>wait</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%AE%A9%E8%BF%9B%E7%A8%8B%E4%BC%91%E7%9C%A0">让进程休眠</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">加载并运行程序</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%A9%E7%94%A8-fork-%E5%92%8C-execve-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">利用 <code>fork</code> 和 <code>execve</code> 运行程序</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BF%A1%E5%8F%B7">信号</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BF%A1%E5%8F%B7%E6%9C%AF%E8%AF%AD">信号术语</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">发送信号</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%9B%E7%A8%8B%E7%BB%84">进程组</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8-binkill-%E7%A8%8B%E5%BA%8F%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">用 <code>/bin/kill</code> 程序发送信号</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8%E9%94%AE%E7%9B%98%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">用键盘发送信号</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8-kill-%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">用 <code>kill</code> 函数发送信号</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8-alarm-%E5%87%BD%E6%95%B0%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7">用 <code>alarm</code> 函数发送信号</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7">接收信号</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E8%A7%A3%E9%99%A4%E9%98%BB%E5%A1%9E">信号的阻塞和解除阻塞</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BC%96%E5%86%99%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F">编写信号处理程序</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%AE%89%E5%85%A8%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">安全的信号处理</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">正确的信号处理</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">可移植的信号处理</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%90%8C%E6%AD%A5%E6%B5%81%E4%BB%A5%E9%81%BF%E5%85%8D%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E9%94%99%E8%AF%AF">同步流以避免讨厌的并发错误</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%98%BE%E5%BC%8F%E5%9C%B0%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7">显式地等待信号</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC">非本地跳转</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%93%8D%E4%BD%9C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7">操作进程的工具</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80">物理和虚拟寻址</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">地址空间</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E5%85%B7">虚拟内存作为缓存的工具</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#dram-%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84">DRAM 缓存的组织结构</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%A1%B5%E8%A1%A8">页表</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%A1%B5%E5%91%BD%E4%B8%AD">页命中</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BC%BA%E9%A1%B5">缺页</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E9%85%8D%E9%A1%B5%E9%9D%A2">分配页面</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8F%88%E6%98%AF%E5%B1%80%E9%83%A8%E6%80%A7%E6%95%91%E4%BA%86%E6%88%91%E4%BB%AC">又是局部性救了我们</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7">虚拟内存作为内存管理的工具</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7">虚拟内存作为内存保护的工具</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91">地址翻译</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%93%E5%90%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">结合高速缓存和虚拟内存</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%A9%E7%94%A8-tlb-%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91">利用 TLB 加速地址翻译</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">多级页表</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%BC%E5%90%88%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91">综合：端到端的地址翻译</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6intel-core-i7linux-%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F">案例研究：Intel Core i7/Linux 内存系统</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#core-i7-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91">Core i7 地址翻译</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F">Linux 虚拟内存系统</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">Linux 虚拟内存区域</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#linux-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">Linux 缺页异常处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84">内存映射</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%86%8D%E7%9C%8B%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1">再看共享对象</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%86%8D%E7%9C%8B-fork-%E5%87%BD%E6%95%B0">再看 <code>fork</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%86%8D%E7%9C%8B-execve-%E5%87%BD%E6%95%B0">再看 <code>execve</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BD%BF%E7%94%A8-mmap-%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84">使用 <code>mmap</code> 的用户级内存映射</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#malloc-%E5%92%8C-free-%E5%87%BD%E6%95%B0"><code>malloc</code> 和 <code>free</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E7%9B%AE%E6%A0%87">分配器的要求和目标</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%A2%8E%E7%89%87%E5%8C%96">碎片化</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%AE%9E%E7%8E%B0%E9%97%AE%E9%A2%98">实现问题</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">隐式空闲链表</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%94%BE%E7%BD%AE%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%9D%97">放置已分配的块</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E5%89%B2%E7%A9%BA%E9%97%B2%E5%9D%97">分割空闲块</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%8E%B7%E5%8F%96%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98">获取额外的堆内存</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97">合并空闲块</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%B8%A6%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0%E7%9A%84%E5%90%88%E5%B9%B6">带边界标记的合并</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%BC%E5%90%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8">综合：实现一个简单的分配器</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%80%9A%E7%94%A8%E5%88%86%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1">通用分配器设计</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E6%95%B0%E5%92%8C%E5%AE%8F">操作空闲链表的基本常数和宏</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">创建初始空闲链表</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%87%8A%E6%94%BE%E5%92%8C%E5%90%88%E5%B9%B6%E5%9D%97">释放和合并块</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E9%85%8D%E5%9D%97">分配块</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">显式空闲链表</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E7%A6%BB%E7%9A%84%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8">分离的空闲链表</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%AE%80%E5%8D%95%E5%88%86%E7%A6%BB%E5%AD%98%E5%82%A8">简单分离存储</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8D">分离适配</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F">伙伴系统</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86">垃圾收集</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86">垃圾收集器的基本知识</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#marksweep-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">Mark&amp;Sweep 垃圾收集器</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#c-%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E5%AE%88-marksweep">C 程序的保守 Mark&amp;Sweep</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#c-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8E%E5%86%85%E5%AD%98%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF">C 程序中常见的与内存有关的错误</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%9D%8F%E6%8C%87%E9%92%88">解引用坏指针</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%AF%BB%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98">读未初始化的内存</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%85%81%E8%AE%B8%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA">允许栈缓冲区溢出</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9C%A8%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F%E4%B8%8A%E7%8A%AF%E9%94%99">在类型大小上犯错</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%80%A0%E6%88%90%E9%94%99%E4%BD%8D%E9%94%99%E8%AF%AF">造成错位错误</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%94%99%E8%AF%AF%E5%9C%B0%E8%A7%A3%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88">错误地解引用指针</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E9%94%99%E8%AF%AF%E5%9C%B0%E5%A2%9E%E5%87%8F%E6%8C%87%E9%92%88">错误地增减指针</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%82%AC%E5%9E%82%E6%8C%87%E9%92%88">悬垂指针</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%BC%95%E7%94%A8%E5%B7%B2%E7%BB%8F%E8%A2%AB%E9%87%8A%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98">引用已经被释放的内存</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%B3%BB%E7%BB%9F%E7%BA%A7-io">系统级 I/O</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#unix-io">Unix I/O</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%96%87%E4%BB%B6">文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6">打开和关闭文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%AF%BB%E5%92%8C%E5%86%99%E6%96%87%E4%BB%B6">读和写文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8-rio-%E5%8C%85%E5%81%A5%E5%A3%AE%E5%9C%B0%E8%AF%BB%E5%86%99">用 RIO 包健壮地读写</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#rio-%E7%9A%84%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0">RIO 的无缓冲的输入输出函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#rio-%E7%9A%84%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0">RIO 的带缓冲的输入函数</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE">读取文件元数据</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9">读取目录内容</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6">共享文件</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#io-%E9%87%8D%E5%AE%9A%E5%90%91">I/O 重定向</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%A0%87%E5%87%86-io">标准 I/O</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%88%91%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B-io-%E5%87%BD%E6%95%B0">我该使用哪些 I/O 函数？</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">客户端-服务器编程模型</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BD%91%E7%BB%9C">网络</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%85%A8%E7%90%83-ip-%E5%9B%A0%E7%89%B9%E7%BD%91">全球 IP 因特网</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#internet-%E5%9F%9F%E5%90%8D">Internet 域名</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#internet-%E8%BF%9E%E6%8E%A5">Internet 连接</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3">套接字接口</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93">套接字地址结构体</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#socket-%E5%87%BD%E6%95%B0"><code>socket</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#bind-%E5%87%BD%E6%95%B0"><code>bind</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#connect-%E5%87%BD%E6%95%B0"><code>connect</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#listen-%E5%87%BD%E6%95%B0"><code>listen</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#accept-%E5%87%BD%E6%95%B0"><code>accept</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#close-%E5%87%BD%E6%95%B0"><code>close</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%B8%BB%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AC%E6%8D%A2">主机和服务的转换</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#getaddrinfo-%E5%87%BD%E6%95%B0"><code>getaddrinfo</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#getnameinfo-%E5%87%BD%E6%95%B0"><code>getnameinfo</code> 函数</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">套接字接口的辅助函数</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#open_clientfd-%E5%87%BD%E6%95%B0"><code>open_clientfd</code> 函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#open_listenfd-%E5%87%BD%E6%95%B0"><code>open_listenfd</code> 函数</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#echo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%A4%BA%E4%BE%8B">echo 客户端和服务器的示例</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#web-%E6%9C%8D%E5%8A%A1%E5%99%A8">Web 服务器</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#web-%E5%9F%BA%E7%A1%80">Web 基础</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#web-%E5%86%85%E5%AE%B9">Web 内容</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#http-%E4%BA%8B%E5%8A%A1">HTTP 事务</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#http-%E8%AF%B7%E6%B1%82">HTTP 请求</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#http-%E5%93%8D%E5%BA%94">HTTP 响应</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%9C%8D%E5%8A%A1%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9">服务动态内容</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%86%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8">客户端将程序参数传递给服务器</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E8%BF%9B%E7%A8%8B">服务器将参数传递给子进程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%B0%86%E5%85%B6%E4%BB%96%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E8%BF%9B%E7%A8%8B">服务器如何将其他信息传递给子进程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%B0%86%E5%85%B6%E8%BE%93%E5%87%BA%E5%8F%91%E9%80%81%E5%88%B0%E5%93%AA%E9%87%8C">子进程将其输出发送到哪里</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%BC%E5%90%88tiny-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">综合：TINY Web 服务器</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">基于进程的并发编程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%A3">进程的优劣</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9F%BA%E4%BA%8E-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">基于 I/O 多路复用的并发编程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9F%BA%E4%BA%8E-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">基于 I/O 多路复用的并发事件驱动服务器</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E5%8A%A3">I/O 多路复用技术的优劣</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">基于线程的并发编程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B">线程执行模型</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#posix-%E7%BA%BF%E7%A8%8B">Posix 线程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">创建线程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B">终止线程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9B%9E%E6%94%B6%E5%B7%B2%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90">回收已终止线程的资源</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B">分离线程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B">初始化线程</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8">基于线程的并发服务器</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">多线程程序中的共享变量</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">线程内存模型</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B">用信号量同步线程</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%BF%9B%E5%BA%A6%E5%9B%BE">进度图</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5">使用信号量实现互斥</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9D%A5%E8%B0%83%E5%BA%A6%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90">利用信号量来调度共享资源</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者-消费者问题</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">读者-写者问题</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BB%BC%E5%90%88%E5%9F%BA%E4%BA%8E%E9%A2%84%E7%BA%BF%E7%A8%8B%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8">综合：基于预线程化的并发服务器</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%8F%90%E9%AB%98%E5%B9%B6%E8%A1%8C%E6%80%A7">使用线程提高并行性</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%88%BB%E7%94%BB%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD">刻画并行程序的性能</a></li>
</ul>
</li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">其他并发问题</a>
<ul>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7">可重入性</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%8C%96%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0">在线程化的程序中使用已存在的库函数</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E7%AB%9E%E4%BA%89">竞争</a></li>
<li><a href="file:///C:/Users/lenovo/AppData/Local/Temp/crossnote202539-35208-18xzamb.jmz9.html#%E6%AD%BB%E9%94%81">死锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="链接">链接 </h1>
<p>链接可以执行于编译时（compile time）、加载时（load time）或运行时（run time）。</p>
<h2 id="编译器驱动程序">编译器驱动程序 </h2>
<ul>
<li>预处理器 <code>cpp</code> 将 <code>main.c</code> 源代码翻译成一个 ASCII 码的中间文件 <code>main.i</code></li>
<li>C 编译器 <code>cc1</code> 将 <code>main.i</code> 编译为 ASCII 汇编文件 <code>main.s</code></li>
<li>汇编器 <code>as</code> 将 <code>main.s</code> 翻译成<strong>可重定位目标文件</strong>（relocatable object file） <code>main.o</code></li>
<li>链接器 <code>ld</code> 将 <code>main.o</code> 和其他必要的系统目标文件合并成一个<strong>可执行目标文件</strong>（executable object file） <code>main</code>。</li>
</ul>
<p>当运行 <code>main</code> 时，<code>shell</code> 调用操作系统中的<strong>加载器</strong>（loader）函数，将 <code>main</code> 的代码和数据复制到内存，并将控制转移到程序的开头。</p>
<h2 id="静态链接">静态链接 </h2>
<p>Linux LD 就是静态链接器（static linker），它以<strong>一组可重定位目标文件</strong>和命令行参数作为输入，生成一个<strong>完全链接的</strong>、<strong>可以加载和运行的可执行目标文件</strong>作为输出。</p>
<p>链接器的主要任务是</p>
<ul>
<li><strong>符号解析</strong>（symbol resolution）：将每个<strong>符号引用</strong>（symbol reference）与一个<strong>符号定义</strong>（symbol definition）关联起来</li>
<li><strong>重定位</strong>（relocation）：将每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，令它们指向这个内存位置</li>
</ul>
<h2 id="目标文件">目标文件 </h2>
<p>目标文件有三种：</p>
<ul>
<li><strong>可重定位目标文件</strong>（relocatable object file）：包含二进制代码和数据，可以与其他可重定位目标文件合并起来，创建一个可执行目标文件</li>
<li><strong>可执行目标文件</strong>（executable object file）：包含二进制代码和数据，可以直接复制到内存并执行</li>
<li><strong>共享目标文件</strong>（shared object file）：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存和链接</li>
</ul>
<p>编译器和汇编器可以生成<strong>可重定位目标文件</strong>和<strong>共享目标文件</strong>。</p>
<p>一个<strong>目标模块</strong>（object module）就是一个抽象的字节序列，一个<strong>目标文件</strong>（object file）就是存储目标模块的实际文件。</p>
<p>目标文件格式：</p>
<ul>
<li>第一个 Unix 系统使用 <code>a.out</code> 格式</li>
<li>Windows 使用可移植可执行（Portable Executable, <strong>PE</strong>）格式</li>
<li>MacOS-X 使用 <strong>Mach-O</strong> 格式</li>
<li>现代 x86-64 Linux 和 Unix 使用<strong>可执行可链接格式</strong>（Executable and Linkable Format, <strong>ELF</strong>）。</li>
</ul>
<h2 id="可重定位目标文件">可重定位目标文件 </h2>
<p><img src="./note-part2_files/7-3典型ELF格式.png" alt=""></p>
<p><strong>ELF 头</strong>（ELF header）的内容：</p>
<ul>
<li>16 字节序列描述系统的<strong>字大小</strong>（word size）和<strong>字节顺序</strong>（byte ordering）</li>
<li>ELF 头的大小</li>
<li>目标文件类型（可重定位、可执行、共享）</li>
<li>机器类型（x86-64）</li>
<li><strong>节头部表</strong>（section header table）的文件偏移</li>
<li>节头部表中的条目数和条目大小。</li>
</ul>
<p>节头部表中的每个条目（entry）大小固定，描述不同节的位置和大小。</p>
<p>以下是典型的 ELF 文件的节，它们夹在 ELF 头和节头部表之间：</p>
<ul>
<li><code>.text</code>：程序代码</li>
<li><code>.rodata</code>：<strong>只读数据</strong>，如字符串常量、<code>switch</code> 跳转表</li>
<li><code>.data</code>：<strong>已定义的符号</strong>（已被非零初始化的全局和静态变量）</li>
<li><code>.bss</code>：<strong>（试探性定义的静态符号）、被零初始化的符号</strong>（未被显式初始化的静态变量或被零初始化的全局和静态变量）。它不占用实际空间。</li>
<li><code>.symtab</code>：<strong>符号表</strong>，包含程序中定义和引用的符号的信息。</li>
<li><code>.rel.text</code>：<strong><code>.text</code> 节的重定位表</strong>。一般而言，调用外部函数或引用全局变量的指令需要修改，而调用本地函数的指令不需要。可执行目标文件中不需要重定位信息，因此通常省略，除非显式指定。</li>
<li><code>.rel.data</code>：<strong>被模块引用或定义的所有全局变量的重定位表</strong>。任何已初始化的全局变量，若其初始值是一个全局变量地址或外部定义函数的地址，那么就需要被修改</li>
<li><code>.debug</code>：<strong>调试符号表</strong>。条目包括程序中定义的<strong>局部变量</strong>和 <code>typedef</code>、程序中定义和引用的全局变量以及原始 C 源代码。只有在使用 <code>-g</code> 编译选项时才会出现。</li>
<li><code>.line</code>：原始 C 代码中的<strong>行号</strong>和 <code>.text</code> 节机器指令的映射。只有在使用 <code>-g</code> 编译选项时才会出现。</li>
<li><code>.strtab</code>：<strong>字符串表</strong>。内容包括 <code>.symtab</code> 和 <code>.debug</code> 节中的符号名字，以及节头部表中的节名。是以 <code>null</code> 结尾的字符串序列。</li>
</ul>
<p>区分 <code>.data</code> 和 <code>.bss</code> 的意义是节省磁盘空间，运行时在内存中分配这些变量，并初始化为零</p>
<p>不使用 <code>-g</code> 编译选项也能得到符号表，除非用 STRIP 命令去掉它。和编译器中的符号表不同，<code>.symtab</code> 不包含局部变量的条目</p>
<blockquote>
<p><code>.bss</code> 得名于 IBM 704 汇编中“块存储开始（Block Storage Start）”指令。助记：Better Save Space</p>
</blockquote>
<h2 id="符号和符号表">符号和符号表 </h2>
<h3 id="连接属性">连接属性 </h3>
<p>声明是向代码中引入名字的语法。这些名字可以声明在<strong>命名空间作用域</strong>（<strong>全局作用域</strong>）、<strong>类作用域</strong>和<strong>复合语句（块）作用域</strong>中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>          <span class="token comment">// 命名空间作用域</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 类作用域</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 命名空间作用域</span>
    <span class="token keyword keyword-int">int</span> c<span class="token punctuation">;</span>      <span class="token comment">// 复合语句作用域</span>
<span class="token punctuation">}</span>
</code></pre><p>每个名字具有一个称为<strong>连接</strong>的属性，连接有三种：<strong>外部连接</strong>（external linkage）、<strong>内部连接</strong>（internal linkage）和<strong>无连接</strong>（no linkage）。</p>
<p>所有复合语句作用域的声明都是无连接的。</p>
<ul>
<li>无连接的名字由于作用域限制，自然不会影响链接过程</li>
<li>内部连接的名字是每个翻译单元独有的，与其他翻译单元中的同名符号互不干扰</li>
<li>外部连接的名字是所有翻译单元共享的</li>
</ul>
<p>称带有内部连接或外部连接的函数名和变量名为<strong>符号</strong>（symbol）。</p>
<ol>
<li>类型（类、枚举类型、别名）总是外部连接的</li>
<li>默认情形下，符号是外部连接的</li>
<li>用 <code>static</code> 修饰一个符号，可以让它成为内部连接的；用 <code>extern</code> 修饰一个符号，可以让它成为外部连接的</li>
</ol>
<h3 id="符号表">符号表 </h3>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-int">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 同名的静态局部变量会被编译器（向汇编器）输出成两个不同名字的符号</span>
</code></pre><p>符号表 <code>.symtab</code> 由<strong>汇编器</strong>根据 <code>.s</code> 文件中的名字构造。</p>
<p>符号表<strong>不但包括符号，还包括静态局部变量</strong>，除此之外还可以包含<strong>各个节</strong>的条目，以及<strong>对应原始源文件的路径名</strong>的条目。</p>
<p><code>.symtab</code> 节的 ELF 符号表是一个条目数组，条目格式如下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> name<span class="token punctuation">;</span>            <span class="token comment">// String table offset, pointing to symbol name</span>
    <span class="token keyword keyword-char">char</span> type<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>        <span class="token comment">// OBJECT/FUNC/FILE/SECTION/..., 4 bits</span>
         binding<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>     <span class="token comment">// Local/Global, 4 bits</span>
    <span class="token keyword keyword-char">char</span> reserved<span class="token punctuation">;</span>       <span class="token comment">// Unused</span>
    <span class="token keyword keyword-short">short</span> section<span class="token punctuation">;</span>       <span class="token comment">// Section header index</span>
    <span class="token keyword keyword-long">long</span> value<span class="token punctuation">;</span>          <span class="token comment">// Symbol address.</span>
    <span class="token keyword keyword-long">long</span> size<span class="token punctuation">;</span>           <span class="token comment">// Object size in bytes</span>
<span class="token punctuation">}</span> Elf64_Symbol<span class="token punctuation">;</span>
</code></pre><p><code>value</code> 是符号地址，对于可重定位模块，是<strong>距离定义目标的节的起始位置的偏移</strong>；对于可执行目标文件，是<strong>绝对运行时地址</strong>。</p>
<p>每个符号被分配到目标文件的某个节，由 <code>section</code> 字段指示。<code>section</code> 字段是一个到节头部表的索引。</p>
<p>在<strong>可重定位目标文件</strong>有三个<strong>伪节</strong>（pseudosection），它们在节头部表中没有条目：</p>
<ul>
<li>ABS 代表<strong>不该被重定位的符号</strong>（文件名）</li>
<li>UNDEF 代表<strong>本模块中被引用，但未定义的符号</strong></li>
<li>COMMON 代表还未被分配位置的未初始化的数据目标，即<strong>被试探性定义的全局符号</strong>。对于此目标，<code>value</code> 字段给出对齐要求，而 <code>size</code> 给出最小大小</li>
</ul>
<p><strong>可执行目标文件中也可能有以上伪节</strong>。</p>
<p>如果指定了 <code>-fcommon</code> 编译选项，gcc 会将被试探性定义的全局符号分配到 COMMON 节，以让链接器选择定义。<strong>未初始化的静态变量</strong>和<strong>零初始化的全局或静态变量</strong>照常被分配到 <code>.bss</code> 节。在可执行目标文件中，COMMON 中的数据进入 <code>.bss</code> 节。</p>
<p>可以用 GNU <code>readelf</code> 程序查看目标文件内容。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// t.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-int">int</span> glob_var_0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment">// .bss</span>
<span class="token keyword keyword-int">int</span> glob_var_1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// .data</span>

<span class="token keyword keyword-int">int</span> glob_var_tentative<span class="token punctuation">;</span>      <span class="token comment">// .bss if -fno-common, .COMMON if -fcommon</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> static_var_0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// .bss</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> static_var_1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// .data</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> static_var_tentative<span class="token punctuation">;</span>    <span class="token comment">// .bss, no matter -fno-common or -fcommon</span>

<span class="token keyword keyword-int">int</span> <span class="token function">func_called</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// in symbol table</span>

<span class="token keyword keyword-int">int</span> <span class="token function">func_not_called</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// not in symbol table</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> local_var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// not in symbol table</span>

    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> static_local_var_0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// .bss</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> static_local_var_1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">// .data</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> static_local_var_tentative<span class="token punctuation">;</span>   <span class="token comment">// .bss, no matter -fno-common or -fcommon</span>
    <span class="token function">func_called</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc <span class="token parameter variable">-fcommon</span> <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> t t.c<span class="token punctuation">;</span> readelf <span class="token parameter variable">-s</span> t

Symbol table <span class="token string">'.symtab'</span> contains <span class="token number">15</span> entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     <span class="token number">0</span>: 0000000000000000     <span class="token number">0</span> NOTYPE  LOCAL  DEFAULT  UND
     <span class="token number">1</span>: 0000000000000000     <span class="token number">0</span> FILE    LOCAL  DEFAULT  ABS t.c
     <span class="token number">2</span>: 0000000000000000     <span class="token number">0</span> SECTION LOCAL  DEFAULT    <span class="token number">1</span> .text
     <span class="token number">3</span>: 0000000000000004     <span class="token number">4</span> OBJECT  LOCAL  DEFAULT    <span class="token number">4</span> static_var_0
     <span class="token number">4</span>: 0000000000000004     <span class="token number">4</span> OBJECT  LOCAL  DEFAULT    <span class="token number">3</span> static_var_1
     <span class="token number">5</span>: 0000000000000008     <span class="token number">4</span> OBJECT  LOCAL  DEFAULT    <span class="token number">4</span> static_var_tentative
     <span class="token number">6</span>: 0000000000000000     <span class="token number">0</span> SECTION LOCAL  DEFAULT    <span class="token number">5</span> .rodata
     <span class="token number">7</span>: 000000000000000c     <span class="token number">4</span> OBJECT  LOCAL  DEFAULT    <span class="token number">4</span> static_local_var<span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
     <span class="token number">8</span>: 0000000000000008     <span class="token number">4</span> OBJECT  LOCAL  DEFAULT    <span class="token number">3</span> static_local_var_1.1
     <span class="token number">9</span>: 0000000000000010     <span class="token number">4</span> OBJECT  LOCAL  DEFAULT    <span class="token number">4</span> static_local_var_0.0
    <span class="token number">10</span>: 0000000000000000     <span class="token number">4</span> OBJECT  GLOBAL DEFAULT    <span class="token number">4</span> glob_var_0
    <span class="token number">11</span>: 0000000000000000     <span class="token number">4</span> OBJECT  GLOBAL DEFAULT    <span class="token number">3</span> glob_var_1
    <span class="token number">12</span>: 0000000000000004     <span class="token number">4</span> OBJECT  GLOBAL DEFAULT  COM glob_var_tentative
    <span class="token number">13</span>: 0000000000000000    <span class="token number">48</span> FUNC    GLOBAL DEFAULT    <span class="token number">1</span> main
    <span class="token number">14</span>: 0000000000000000     <span class="token number">0</span> NOTYPE  GLOBAL DEFAULT  UND puts

<span class="token comment"># 1: .text</span>
<span class="token comment"># 2: .rela.text</span>
<span class="token comment"># 3: .data</span>
<span class="token comment"># 4: .bss</span>
<span class="token comment"># 5: .rodata</span>
<span class="token comment"># 11: .symtab</span>
<span class="token comment"># 12: .strtab</span>
</code></pre><p>注意：</p>
<ul>
<li><strong>只声明过但未调用的函数</strong>不会出现在符号表中</li>
<li>名字若在符号表中，则它一定也<strong>在 <code>.strtab</code> 字符串表中</strong></li>
<li>符号表中，静态局部变量会被加上后缀 <code>.0</code>、<code>.1</code>、<code>.2</code> 等，以作区分</li>
</ul>
<p>readelf 打印出的 <code>LOCAL</code> 表示此名字是<strong>内部连接</strong>或<strong>无连接</strong>（对应静态局部变量）的，<code>GLOBAL</code> 表示此名字是<strong>外部连接</strong>的。</p>
<h2 id="符号解析">符号解析 </h2>
<p><strong>链接器将每个符号引用与它参数中的可重定位目标文件的符号表中的一个确定的符号定义关联起来</strong>的过程，就是符号解析。</p>
<p>对于引用和定义在同一模块中的局部符号，符号解析是简单的。编译器只允许每个模块中每个局部符号有一个定义。对于局部静态变量，编译器需要保证它们本地链接器符号唯一。</p>
<p>当编译器遇到一个<strong>未在当前模块定义的全局符号</strong>时，会假设它是在其他某个模块中定义的，<strong>生成一个链接器符号表条目</strong>，并将它交给链接器处理。若链接器在它的任何输入模块中都找不到该符号的定义，就输出一条错误信息并终止。</p>
<h3 id="链接器如何解析多重定义的全局符号">链接器如何解析多重定义的全局符号 </h3>
<p>单一定义原则（One Definition Rule, ODR）：</p>
<ul>
<li>一个翻译单元中，允许出现一个变量、函数或类型的多次声明，但至多只允许出现一次定义</li>
<li>一个翻译单元中，如果 <em>ODR-使用</em>了一个符号，那么它至少要出现一次定义</li>
<li>整个程序中，非内联的符号最多只允许出现一次定义</li>
</ul>
<p>忘记写 <code>main</code> 函数不会报编译错误，而是链接错误：<code>main</code> 函数被 ODR-使用，但找不到定义。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token comment">// a.cpp</span>
<span class="token keyword keyword-inline">inline</span> <span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// b.cpp</span>
<span class="token keyword keyword-inline">inline</span> <span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 此例中，f 是内联的，因此可以在两个翻译单元中重复定义</span>
<span class="token comment">// 这两个定义必须完全一致，否则是未定义行为</span>
</code></pre><p>如下的不带 <code>static</code> 或 <code>extern</code> 的全局变量声明在 C++ 中是变量 <code>a</code> 的定义，且 <code>a</code> 是外部连接的。</p>
<p>但在 C 中，这样的声明称为<strong>试探性定义</strong>（tentative definition）。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>
</code></pre><p>当试探性定义与一个同名的“正常定义”<strong>同时出现</strong>时，试探性定义成为声明。否则，这些试探性定义中的某一个成为定义，其余成为声明。</p>
<blockquote>
<p>在标准中，“同时出现”的范围是同一个翻译单元。在某些实现（如 Linux 的 ELF 格式）中，这个范围可以是多个翻译单元。在此情况下，称“正常定义”的符号为<strong>强符号</strong>，试探性定义的符号为<strong>弱符号</strong>。</p>
</blockquote>
<p>汇编器将符号强弱的信息隐含地编码在可重定位目标文件的符号表。</p>
<ul>
<li>在链接时，强符号只能出现一次（对应单一定义原则）</li>
<li>多个弱符号可伴随一个强符号同时链接（弱符号——试探性定义——退化为声明）</li>
<li>没有强符号时，在多个弱符号中任选一个成为定义。</li>
</ul>
<p>以下是一个有关符号解析造成的错误的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// foo.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> y <span class="token operator">=</span> <span class="token number">15212</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">15213</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = 0x%x y = 0x%x\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// bar.c</span>
<span class="token keyword keyword-double">double</span> x<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在 x86-64/Linux 机器上，<code>f()</code> 将会用 <code>0.0</code> 覆盖 <code>foo.c</code> 中的 <code>x</code> 和 <code>y</code> 变量，并触发链接器发出一条 Warning: alignment 4 of symbol 'x' in somefile.o is smaller than 8 in otherfile.o。</p>
<p>可以用 <code>-fno-common</code> 调用 gcc，将试探性定义的全局变量放在 <code>.bss</code> 节，从而禁止链接器对不同翻译单元的试探性定义的合并，使得链接器在遇到此类情况时报重定义错误（这已经成为默认选项）。</p>
<p><code>-Werror</code> 可以把所有警告变为错误。</p>
<h3 id="与静态库链接">与静态库链接 </h3>
<p>编译系统提供一种机制, 将多个翻译单元打包成一个单独的文件, 称为<strong>静态库</strong>（static library）。当静态库作为链接器的输入时，链接器<strong>只从静态库复制被引用了的目标模块</strong>。</p>
<blockquote>
<p>ISO C99 定义了许多标准函数。<br>
如果编译器将这些函数直接集成在编译器里，那么编译器的复杂性就会大大提升，且标准函数的更新会和编译器版本绑定。<br>
如果将所有标准函数放在一个单独的可重定位目标模块（例如 <code>libc.o</code>），那么每个可执行文件都需要包含一份所有标准函数的副本，会浪费许多磁盘和内存空间，并且每个函数的更新都会导致库的重新编译。<br>
如果为每个标准函数创建一个独立的可重定位目标文件（例如 <code>printf.o</code>），那么使用时就太麻烦了。<br>
因此，静态库的概念被提出了。</p>
</blockquote>
<p>使用静态库时，一个使用 C 标准库和数学库的程序可以这样编译链接：</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc main.c /usr/lib/libm.a /usr/lib/libc.a
<span class="token comment"># 实际上 libc.a 会被 C compiler driver 自动传送 因此不必显式指定</span>
</code></pre><p>Linux 中，静态库以<strong>存档</strong>（archive）格式存放在磁盘中，以 <code>.a</code> 标识。它是一组连接起来的可重定位目标文件的集合，有一个 header 来描述每个成员目标文件的大小和位置。</p>
<p>以下是一个创建并使用静态库的例子：</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc <span class="token parameter variable">-c</span> foo.c bar.c              <span class="token comment"># compile, assemble, but don't link</span>
ar rcs libfoobar.a foo.o bar.o  <span class="token comment"># 打包成静态库</span>

gcc <span class="token parameter variable">-c</span> main.c    <span class="token comment"># 设 main.c 只引用了 foo.c 中的符号</span>
gcc <span class="token parameter variable">-static</span> <span class="token parameter variable">-o</span> my-prog main.o ./libfoobar.a
<span class="token comment"># 或等价地：</span>
gcc <span class="token parameter variable">-static</span> <span class="token parameter variable">-o</span> my-prog main.o -L. <span class="token parameter variable">-lfoobar</span>
</code></pre><p>链接器运行时，它判定 <code>main.o</code> 只引用了来自 <code>foo.o</code> 的符号，因此它从 <code>libfoobar.a</code> 中只复制 <code>foo.o</code> 到 <code>my-prog</code> 中（此外还可能包括 <code>libc.a</code> 中的 <code>printf.o</code>，以及其他 C 运行时系统中的其他模块）。</p>
<h3 id="链接器如何使用静态库来解析引用">链接器如何使用静态库来解析引用 </h3>
<p>符号解析阶段，链接器扫描其输入参数（可重定位目标文件和存档文件）是按照<strong>它们作为编译器驱动程序参数的顺序</strong>的。</p>
<p>链接器维护三个集合，它们初始时均为空：</p>
<ul>
<li><strong>可重定位目标文件的集合</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li>
<li><strong>未解析的符号集合</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>（即已被引用但尚未定义的符号集合）</li>
<li><strong>已经定义的符号集合</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></li>
</ul>
<p>对于每个输入文件 <code>f</code>，链接器可以判断它是目标文件还是存档文件：</p>
<ul>
<li>如果 <code>f</code> 是<strong>目标文件</strong>，链接器将它添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，并更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>。</li>
<li>如果 <code>f</code> 是<strong>存档文件</strong>，链接器尝试在 <code>f</code> 定义的符号中匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> 中的每个未解析符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>。如果匹配成功，将 <code>f</code> 中对应的模块 <code>m</code> 添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，并更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>。</li>
</ul>
<p>如果扫描完成后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> 非空，那么链接器输出一个错误并终止，否则它会合并和重定位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 中的文件，构建输出的可执行文件。</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token comment"># 这就导致了链接器的输入顺序很重要</span>
<span class="token comment"># 例如以下命令将使链接器报错</span>
gcc <span class="token parameter variable">-static</span> -L. <span class="token parameter variable">-lfoobar</span> <span class="token parameter variable">-o</span> my-prog main.o
</code></pre><p>我们一般<strong>将静态库放在末尾</strong>。并且如果库之间有依赖关系，我们还要对它们排序。如果 <code>libx.a</code> 和 <code>liby.a</code> 互相引用对方的符号，我们还需要让其中一个库重复出现（或将他们合并成一个存档文件）。</p>
<h2 id="重定位">重定位 </h2>
<p>链接器完成符号解析后，就将每个符号引用和恰好一个符号定义（即输入目标模块中的一个符号表条目）关联起来。现在，链接器知道了它的输入目标模块中代码节和数据节的确切大小，可以开始重定位了。</p>
<p>重定位分为两步：</p>
<ul>
<li><strong>重定位节和符号定义</strong>：
<ul>
<li><strong>将所有相同类型的节合并</strong>（例如每个模块的 <code>.data</code> 被合并为输出可执行目标文件的 <code>.data</code>）</li>
<li>将<strong>运行时内存地址</strong>赋给合并后的节、赋给输入模块定义的每个节以及赋给输入模块定义的每个符号。此后，程序中的从每条指令和全局变量都拥有了唯一的运行时内存地址。</li>
</ul>
</li>
<li><strong>重定位节中的符号引用</strong>：修改代码节和数据节中的符号引用，使得它们指向正确的运行时内存地址。这一步依赖于可重定位目标模块中的<strong>重定位条目</strong>（relocation entry）。</li>
</ul>
<h3 id="重定位条目">重定位条目 </h3>
<p>汇编器不知道数据、代码和外部符号最终会被存放在什么位置。遇到最终位置未知的目标引用时，<strong>汇编器生成一个重定位条目</strong>，告诉链接器如何修改这个引用。</p>
<p>代码的重定位条目在 <code>.rel.text</code> 节中，已初始化数据的重定位条目在 <code>.rel.data</code> 节中。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// ELF relocation entry</span>
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> offset<span class="token punctuation">;</span>          <span class="token comment">// Offset from start of section to fixup</span>
    <span class="token keyword keyword-long">long</span> type<span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>        <span class="token comment">// Relocation type</span>
         symbol<span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">;</span>      <span class="token comment">// Symbol table index</span>
    <span class="token keyword keyword-long">long</span> addend<span class="token punctuation">;</span>          <span class="token comment">// Constant</span>
<span class="token punctuation">}</span> Elf64_Rela<span class="token punctuation">;</span>
<span class="token comment">// 一些类型的重定位要使用 addend 对被修改引用的值做偏移调整</span>
</code></pre><p>ELF 定义了 32 种重定位类型，我们关心两种：</p>
<ul>
<li><code>R_X86_64_PC32</code>：重定位一个使用 32 位 PC 相对地址的引用。</li>
<li><code>R_X86_64_32</code>：重定位一个使用 32 位绝对地址的引用。</li>
</ul>
<p>这两种引用类型支持 x86-64 小型代码模型（small code model），该模型假设可执行目标文件中的代码和数据的地址都可以用 <strong>32 位有符号偏移量</strong>表示（总体大小小于 2 GB）。</p>
<p>更大的程序可以使用 <code>-mcmodel=medium</code> 或 <code>-mcmodel=large</code> 编译选项。</p>
<h3 id="重定位符号引用">重定位符号引用 </h3>
<p>以下代码描述了链接器的重定位算法。</p>
<p>我们把每个节看作一个字节数组，每个重定位条目是一个类型为 <code>Elf64_Rela</code> 的结构体，链接器已经为每个节和每个符号选择了运行时地址（用 <code>ADDR</code> 函数表示）</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>sec <span class="token operator">:</span> sections<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>r <span class="token operator">:</span> relocation_entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        refptr <span class="token operator">=</span> sec <span class="token operator">+</span> r<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>    <span class="token comment">// ptr to reference to be relocated</span>

        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>type <span class="token operator">==</span> R_X86_64_PC32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            refaddr <span class="token operator">=</span> <span class="token function">ADDR</span><span class="token punctuation">(</span>sec<span class="token punctuation">)</span> <span class="token operator">+</span> r<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>  <span class="token comment">// ref's runtime address</span>
            <span class="token operator">*</span>refptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ADDR</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>symbol<span class="token punctuation">)</span> <span class="token operator">+</span> r<span class="token punctuation">.</span>addend <span class="token operator">-</span> refaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>type <span class="token operator">==</span> R_X86_64_32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>refptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ADDR</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>symbol<span class="token punctuation">)</span> <span class="token operator">+</span> r<span class="token punctuation">.</span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>对于 PC 相对引用，<code>addend</code> 通常等于地址长度的相反数</strong>。<strong>对于绝对引用，<code>addend</code> 为零</strong>。对于 PC 相对引用，被填入的地址是引用指令下一条指令的地址到符号真实地址的偏移量，<code>addend</code> 用于补齐 <code>r.offset</code> 和下一条指令的地址之间的差值。</p>
<p>以如下代码为例，<code>main</code> 函数分别用 PC 相对引用和绝对引用的方式引用了全局符号 <code>sum</code> 和 <code>array</code>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// sum.c</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.c</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// defined in sum.o</span>
<span class="token keyword keyword-int">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> val <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// objdump -dx main.o</span>
<span class="token comment">// 0000000000000000 &lt;main&gt;:</span>
<span class="token number">0x0</span><span class="token operator">:</span>    <span class="token number">48</span> <span class="token number">83</span> ec <span class="token number">08</span>        sub    $<span class="token number">0x8</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
<span class="token number">0x4</span><span class="token operator">:</span>    be <span class="token number">02</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>     mov    $<span class="token number">0x2</span><span class="token punctuation">,</span> <span class="token operator">%</span>esi
<span class="token number">0x9</span><span class="token operator">:</span>    bf <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>     mov    $<span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token operator">%</span>edi        <span class="token comment">// arr</span>
                        a<span class="token operator">:</span> R_X86_64_32  array
<span class="token number">0xe</span><span class="token operator">:</span>    e8 <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>     callq  <span class="token number">13</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">0x13</span><span class="token operator">&gt;</span>    <span class="token comment">// sum</span>
                        f<span class="token operator">:</span> R_X86_64_PC32  sum<span class="token operator">-</span><span class="token number">0x4</span>
<span class="token number">0x13</span><span class="token operator">:</span>   <span class="token number">48</span> <span class="token number">83</span> c4 <span class="token number">08</span>        add    $<span class="token number">0x8</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
<span class="token number">0x17</span><span class="token operator">:</span>   c3                 retq
</code></pre><h4 id="重定位-pc-相对引用">重定位 PC 相对引用 </h4>
<p><code>main</code> 函数调用外部函数 <code>sum</code>，相应的重定位条目如下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// relocation entry of sum</span>
re <span class="token operator">=</span> <span class="token punctuation">{</span>
    re<span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token number">0xf</span><span class="token punctuation">,</span>
    re<span class="token punctuation">.</span>symbol <span class="token operator">=</span> sum<span class="token punctuation">,</span>
    re<span class="token punctuation">.</span>type <span class="token operator">=</span> R_X86_64_PC32<span class="token punctuation">,</span>
    re<span class="token punctuation">.</span>addend <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>链接器将会在 <code>&lt;main+0xf&gt;</code> 中填入 32 位 PC 相对地址：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 假设 ADDR(.text) == 0x4004d0, ADDR(sum) == 0x4004e8</span>
refaddr <span class="token operator">=</span> <span class="token function">ADDR</span><span class="token punctuation">(</span>sec<span class="token punctuation">)</span> <span class="token operator">+</span> re<span class="token punctuation">.</span>offset
        <span class="token operator">=</span> <span class="token function">ADDR</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xf</span>
        <span class="token operator">=</span> <span class="token number">0x4004df</span><span class="token punctuation">;</span>

<span class="token operator">*</span>refptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ADDR</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>symbol<span class="token punctuation">)</span> <span class="token operator">+</span> re<span class="token punctuation">.</span>addend <span class="token operator">-</span> refaddr<span class="token punctuation">)</span>
        <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ADDR</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0x4004df</span><span class="token punctuation">)</span>
        <span class="token operator">=</span> <span class="token number">0x4004e8</span> <span class="token operator">-</span> <span class="token number">0x4004df</span> <span class="token operator">-</span> <span class="token number">4</span>
        <span class="token operator">=</span> <span class="token number">0x5</span><span class="token punctuation">;</span>

<span class="token comment">// So 0x5 is filled in &lt;main+0xf&gt;, and the corresponding instruction becomes:</span>
<span class="token number">0x4004de</span><span class="token operator">:</span>    e8 <span class="token number">05</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>     callq  <span class="token number">4004e8</span> <span class="token operator">&lt;</span>sum<span class="token operator">&gt;</span>
</code></pre><h4 id="重定位绝对引用">重定位绝对引用 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>re <span class="token operator">=</span> <span class="token punctuation">{</span>
    re<span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token number">0xa</span><span class="token punctuation">,</span>
    re<span class="token punctuation">.</span>symbol <span class="token operator">=</span> arr<span class="token punctuation">,</span>
    re<span class="token punctuation">.</span>type <span class="token operator">=</span> R_X86_64_32<span class="token punctuation">,</span>
    re<span class="token punctuation">.</span>addend <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>链接器在 <code>&lt;main+0xa&gt;</code> 填入 32 位绝对地址：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 假设 ADDR(arr) == 0x601018</span>
<span class="token operator">*</span>refptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ADDR</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>symbol<span class="token punctuation">)</span> <span class="token operator">+</span> re<span class="token punctuation">.</span>addend<span class="token punctuation">)</span>
        <span class="token operator">=</span> <span class="token number">0x601018</span><span class="token punctuation">;</span>

<span class="token comment">// The corresponding instruction becomes:</span>
<span class="token number">0x4004d9</span><span class="token operator">:</span>    bf <span class="token number">18</span> <span class="token number">10</span> <span class="token number">60</span> <span class="token number">00</span>     mov    $<span class="token number">0x601018</span><span class="token punctuation">,</span> <span class="token operator">%</span>edi
</code></pre><p>最后，以下是最终可执行目标文件的 <code>.data</code> 节：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token number">0000000000601018</span> <span class="token operator">&lt;</span>arr<span class="token operator">&gt;</span><span class="token operator">:</span>
    <span class="token number">0x601018</span><span class="token operator">:</span>    <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">02</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>
</code></pre><h2 id="可执行目标文件">可执行目标文件 </h2>
<p><img src="./note-part2_files/7-13-典型ELF可执行目标文件.png" alt=""></p>
<p>ELF 头中的 <code>e_entry</code> 字段指示了程序的<strong>入口点</strong>（entry point），即程序首条指令的地址。</p>
<p><code>.init</code> 节定义了一个小函数 <code>_init</code>，程序的初始化代码会调用它。</p>
<p>可执行文件已经<strong>完全链接</strong>（已被重定位），它不需要 <code>rel</code> 节。</p>
<p>ELF 被设计地很容易加载到内存。可执行文件的连续的<strong>片</strong>（chunk）被映射到连续的内存段。<strong>程序头部表</strong>（program header table）描述了这种映射关系。</p>
<p><img src="./note-part2_files/7-14-程序头部表.png" alt=""></p>
<p>根据可执行文件的内容，两个内存段的内容会被初始化。</p>
<p><strong>代码段</strong>（code segment）有读 / 执行访问权限，开始于内存地址 <code>0x400000</code> 处，总共在内存中占 <code>0x69c</code> 字节，并且它被初始化为可执行目标文件的头 <code>0x69c</code> 个字节（这包括 ELF 头、程序头部表，以及 <code>.init</code>、<code>.text</code> 和 <code>.rodata</code> 节）</p>
<p><strong>数据段</strong>（data segment）有读 / 写访问权限，开始于内存地址 <code>0x600df8</code> 处，总共在内存中占 <code>0x230</code> 字节，并且它被初始化为可执行目标文件中偏移 <code>0xdf8</code> 处起的 <code>0x228</code> 个字节（位于 <code>.data</code> 节），其余 <code>8</code> 个字节对应于在运行时被初始化为 <code>0</code> 的 <code>.bss</code> 数据。</p>
<p>对于任何段 <code>s</code>，链接器所选择的起始地址 <code>vaddr</code> 必须满足</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>vaddr</mtext><mo>≡</mo><mtext>off</mtext><mspace></mspace><mspace width="1em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"></mspace><mtext>align</mtext><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\text{vaddr}\equiv\text{off}\pmod{\text{align}},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">vaddr</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">off</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord text"><span class="mord">align</span></span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span></span></p>
<p>其中 <code>off</code> 是<strong>段的首字节在目标文件中的偏移量</strong>，<code>align</code> 是程序头部表中指定的对齐（此处为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup><mo>=</mo><mn>0</mn><mi>x</mi><mn>200000</mn></mrow><annotation encoding="application/x-tex">2^{21}=0x200000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">200000</span></span></span></span>）。这种对齐加快了段传送到内存的效率。</p>
<h2 id="加载可执行目标文件">加载可执行目标文件 </h2>
<p>在 Linux shell 中运行可执行目标文件时，shell 调用某个驻留在存储器中称为<strong>加载器</strong>（loader）的操作系统代码来运行它。</p>
<p>加载器将可执行目标文件中的代码和数据从磁盘复制到内存（称为<strong>加载</strong>），然后跳转到程序的首条指令或入口点。</p>
<p>任何 Linux 程序都可以通过调用 <code>execve</code> 函数来调用加载器。</p>
<p><img src="./note-part2_files/7-15-linux运行时内存映像.png" alt=""></p>
<p>在 Linux x86-64 系统中，代码段总是从内存地址 <code>0x400000</code> 开始，后面跟着数据段、运行时堆。堆后的区域为共享模块保留，用户栈总是从最大的合法用户地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{48}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 开始，向内存地址减小的方向增长。栈以后的区域（从地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span></span></span></span> 起）为<strong>内核</strong>中的代码和数据保留。</p>
<p>我们将堆、数据和代码段化成了相邻的，并且栈顶在最大合法用户地址处。实际上由于 <code>.data</code> 段的对齐要求，代码段和数据段有间隙。同时，在分配栈、共享库和堆的运行时地址时，链接器还会使用<strong>地址空间布局随机化</strong>（ASLR）。</p>
<p>加载器运行时会创建像这样的内存映像，然后经历以下步骤：</p>
<ul>
<li>在程序头部表的引导下，加载器<strong>将可执行文件的片复制到代码段和数据段</strong></li>
<li>跳转到程序入口点，即 <code>_start</code> 函数的地址（它在系统目标文件 <code>ctrl.o</code> 中定义）</li>
<li><code>_start</code> 调用系统启动函数 <code>_libc_start_main</code>（在 <code>libc.so</code> 中定义）</li>
<li><code>_libc_start_main</code> 初始化执行环境，调用用户层的 <code>main</code> 函数，处理 <code>main</code> 的返回值，并在需要的时候将控制返回给内核。</li>
</ul>
<blockquote>
<p>更准确地，Linux 的每个程序运行在一个进程上下文中，有自己的虚拟地址空间。<br>
shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。<br>
子进程通过 <code>execve</code> 系统调用启动加载器，加载器删除子进程现有的虚拟内存段，创建一组新的代码、数据、堆和栈段。新的栈和堆被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的内容。<br>
最后，加载器跳转到 <code>_start</code> 地址。<br>
除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制，直到 CPU 引用一个被映射的虚拟页时才会进行复制。此时，操作系统利用其页面调度机制自动将页面从磁盘传送到内存。</p>
</blockquote>
<h2 id="动态链接共享库">动态链接共享库 </h2>
<p>静态库仍然有一些问题：</p>
<ul>
<li>静态库需要用户时时更新, 重新链接</li>
<li>标准 I/O 函数如 <code>printf</code> 和 <code>scanf</code> 的代码被几乎所有程序使用，它们在运行时会被复制到每个运行进程的文本段里，造成极大的浪费</li>
</ul>
<p><strong>共享库</strong>（shared library）: 又称<strong>共享目标</strong>（shared object），是一种特殊的目标模块。它<strong>在运行或加载时可以被加载到任意的内存地址</strong>，并可以和在内存中的程序链接起来，这个过程称为<strong>动态链接</strong>（dynamic linking），由动态链接器（dynamic linker）完成。</p>
<p>共享库在 Linux 中通常以后缀名 <code>.so</code> 标识，Windows 中以 <code>.dll</code> 标识。</p>
<ul>
<li>在<strong>文件系统中</strong>，一个共享库只有一个 <code>.so</code> 文件，所有引用共享库的可执行目标文件<strong>共享这个 <code>.so</code> 文件的代码和数据</strong>，而不像静态库一样将其内容复制并嵌入其可执行文件中</li>
<li>在<strong>内存中</strong>，共享库的<code>.text</code> 节的副本可以被不同的引用它的进程共享</li>
</ul>
<p>创建共享库：</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token comment"># -fpic: 生成位置无关代码; -shared: 生成共享目标</span>
gcc <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fpic</span> <span class="token parameter variable">-o</span> libfoobar.so foo.c bar.c
gcc <span class="token parameter variable">-o</span> my-prog main.c ./libfoobar.so
<span class="token comment"># my-prog 会在运行时动态链接 libfoobar.so</span>
</code></pre><p><code>my-prog</code> 运行时可以和 <code>libfoobar.so</code> 链接。</p>
<p>创建可执行文件 <code>my-prog</code> 时静态执行了一些链接，程序加载时，动态完成链接的过程。此时，<strong>没有任何 <code>libfoobar.so</code> 的代码和数据节被真的复制到 <code>my-prog</code> 中</strong>，链接器只复制了一些重定位和符号表信息，它们使得运行时可以解析对 <code>libfoobar.so</code> 的引用。</p>
<p>加载器照常加载 <code>my-prog</code>，它会注意到 <code>my-prog</code> <strong>包含一个 <code>.interp</code> 节</strong>，其中包含动态链接器的路径名。<strong>动态链接器本身就是一个共享目标</strong>（在 Linux 上，<code>ld-linux.so</code>）。加载器不会像通常一样将控制传递给应用，而是<strong>加载和运行动态链接器</strong>，然后动态链接器执行以下重定位完成链接任务：</p>
<ul>
<li>重定位 <code>libc.so</code> 的文本和数据到某个内存段</li>
<li>重定位 <code>libfoobar.so</code> 的文本和数据到另一个内存段</li>
<li>重定位 <code>my-prog</code> 中所有对由 <code>libc.so</code> 和 <code>libfoobar.so</code> 定义的符号的引用</li>
</ul>
<p>最后，动态链接器将控制传递给应用程序，此时起共享库的位置就固定了，并且在应用程序执行过程中都不会改变。</p>
<p>这是在应用程序<strong>被加载后、被执行前</strong>，动态链接器加载并链接共享库的情景。</p>
<h2 id="从应用程序中加载和链接共享库">从应用程序中加载和链接共享库 </h2>
<p>应用程序还可能在<strong>运行时</strong>要求动态链接器加载和链接共享库，而而无需在调用编译驱动程序时将那些库链接到应用内。</p>
<p>这种动态链接的一些应用：</p>
<ul>
<li><strong>分发软件</strong>：Windows 应用的开发者常常利用共享库分发软件更新。他们生成共享库的新版本，用户下载并用它替换当前版本，下次他们运行应用程序时，应用就能自动链接并加载新的共享库</li>
<li><strong>构建高性能 Web 服务器</strong>：早期 Web 服务器通过使用 <code>fork</code> 和 <code>execve</code> 创建子进程，并在该子进程的上下文中运行 CGI 程序来生成动态内容。现代高性能 Web 服务器使用动态链接更高效地生成动态内容。其思路是将每个生成动态内容的函数打包在共享库，当一个来自 Web 服务器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用 <code>fork</code> 和 <code>execve</code> 创建子进程并在其上下文中运行函数。函数会一直缓存在服务器的地址空间中，后续请求的开销就降低到一个简单的函数调用开销，并且运行时无需停止服务器即可更新已存在的函数或添加新函数</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span></span>

<span class="token comment">// Linux 为动态链接器提供了 `dlopen` 接口</span>
<span class="token comment">// 允许应用程序在运行时加载和链接共享库</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 若成功，返回指向句柄的指针，否则返回 NULL</span>
</code></pre><p><code>flag</code> 选项要么包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RTLD_NOW</mtext></mrow><annotation encoding="application/x-tex">\text{RTLD\_NOW}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">RTLD_NOW</span></span></span></span></span>，指示链接器立即解析对外部符号的引用，要么包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RTLD_LAZY</mtext></mrow><annotation encoding="application/x-tex">\text{RTLD\_LAZY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">RTLD_LAZY</span></span></span></span></span>，指示链接器推迟符号解析直到执行来自库中的代码。这两个值都可以与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RTLD_GLOBAL</mtext></mrow><annotation encoding="application/x-tex">\text{RTLD\_GLOBAL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">RTLD_GLOBAL</span></span></span></span></span> 取或，它指示此库中定义的符号可以在后续的动态链接中被解析。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span> <span class="token function">dlsym</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> handle<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// handle 是指向已打开的共享库的句柄，symbol 是符号名</span>
<span class="token comment">// 若 symbol 存在，则返回其地址，否则返回 NULL</span>

<span class="token keyword keyword-int">int</span> <span class="token function">dlclose</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 若没有其他共享库仍在使用该共享库，dlclose 就卸载此共享库</span>

<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回字符串，描述调用 dlopen, dlsym 或 dlclose 时发生的最近的错误，若没有错误则返回 NULL</span>
</code></pre><p>以下示例展示了如何利用这些接口动态链接 <code>libfoobar.so</code> 共享库，并调用它的 <code>foo_func</code> 例程</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword keyword-int">int</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> handle<span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>foo_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>error<span class="token punctuation">;</span>

    handle <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"./libvector.so"</span><span class="token punctuation">,</span> RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    foo_func <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> <span class="token string">"foo_func"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">foo_func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">dlclose</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>以上程序用如下命令编译：</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc <span class="token parameter variable">-rdynamic</span> <span class="token parameter variable">-o</span> my-prog dll.c <span class="token parameter variable">-ldl</span>
</code></pre><p><code>-rdynamic</code> 选项使得<strong>可执行文件里的全局符号对于动态链接器可见</strong>。以下是一个例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// bar.c, compiled into libbar.so</span>
<span class="token keyword keyword-extern">extern</span> <span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// shared library libbar.so references a symbol defined in main.o</span>

<span class="token comment">// main.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> dlh <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"./libbar.so"</span><span class="token punctuation">,</span> RTLD_NOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dlh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>bar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>dlh<span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc <span class="token parameter variable">-c</span> <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-o</span> <span class="token parameter variable">-main.o</span> main.c
gcc <span class="token parameter variable">-c</span> <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-fpic</span> <span class="token parameter variable">-o</span> <span class="token parameter variable">-bar.o</span> bar.c
gcc <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> libbar.so bar.o
gcc <span class="token parameter variable">-o</span> prog main.o -L. <span class="token parameter variable">-lbar</span> <span class="token parameter variable">-ldl</span>    <span class="token comment"># 不带 -rdynamic</span>

./prog
./libbar.so: undefined symbol: foo
<span class="token comment"># 可见 main.o 中的符号对于动态链接器来说不可见</span>

<span class="token comment"># 为了成功运行 第四行需要添加 -rdynamic 选项</span>
gcc <span class="token parameter variable">-rdynamic</span> <span class="token parameter variable">-o</span> prog main.o -L. <span class="token parameter variable">-lbar</span> <span class="token parameter variable">-ldl</span>
./prog
Hello, world<span class="token operator">!</span>

<span class="token comment"># Symbol are only exported by default from shared libraries. -rdynamic tells linker to do the same for executables (like main.o).</span>
</code></pre><blockquote>
<p>Java 定义了一个标准调用规则，称为 Java 本地接口（Java Native Interface, JNI），它允许 Java 程序调用“本地的”C/C++ 函数。其基本思想是将本地 C/C++ 函数编译到一个共享库，并利用 <code>dlopen</code>（或类似的接口）动态链接和加载这个共享库，实现函数调用。</p>
</blockquote>
<h2 id="位置无关代码">位置无关代码 </h2>
<p>如何实现让多个运行中进程共享内存中相同的库代码？</p>
<p>一种<strong>不可行</strong>的方法：<strong>为每个共享库分配一个事先预备的专用地址空间片</strong>，要求加载器总是在这个地址上加载共享库。这种方法对地址空间的使用较低效（即使进程不使用这个库，空间还是会被分配），并且它难以管理：必须保证没有片会重叠，并且当库被修改后，还必须重新确认它的片是否还适合其大小，如果不适合，就必须重新分配一个新的片。随着库数量的增多，系统的地址空间四分五裂，造成许多未使用而又使用不了的小洞。更糟的是，对每个系统，库在内存中的分配都是不同的，使得管理难上加难。</p>
<p><strong>位置无关代码</strong>（Position-Independent Code, <strong>PIC</strong>）：<strong>可以加载而无需重定位</strong>的代码。</p>
<p>通过对 gcc 使用 <code>-fpic</code> 选项，可以生成 PIC 代码，使得<strong>代码可以被加载到内存的任何位置而无需链接器修改</strong>，于是无限多个进程可以轻松共享一个共享模块的代码段的单一副本。</p>
<p>共享库的编译必须总是使用 <code>-fpic</code> 选项。</p>
<p>在 x86-64 系统中，对同一个目标模块中符号的引用可以用 PC 相对寻址来编译，构造目标文件时由静态链接器重定位，就像我们之前讨论的一样。但是，对于定义在外部的符号，就需要特殊的技巧引用：</p>
<h3 id="pic-数据引用">PIC 数据引用 </h3>
<p>我们指出：无论一个目标模块（包括共享目标模块）在内存的何处被加载，其<strong>数据段与代码段的距离总是保持不变</strong>。</p>
<p>生成对全局变量的 PIC 引用时，编译器<strong>在数据段开始的地方</strong>创建一个<strong>全局偏移量表</strong>（Global Offset Table, <strong>GOT</strong>）。</p>
<p>在 GOT 中，每个被当前目标模块引用的（外部）符号都有一个 <strong>8 字节条目</strong>。编译器还为 GOT 中每个条目生成一个重定位记录。</p>
<p>加载时，<strong>动态链接器重定位 GOT 中的每个条目</strong>，使得它包含目标正确的绝对地址。</p>
<p>每个引用全局目标的模块都有自己的 GOT。</p>
<p><img src="./note-part2_files/7-18-GOT引用全局变量.png" alt=""></p>
<p>不过，因为 <code>addcnt</code> 是在 <code>libvector.so</code> 模块内部定义的，编译器实际可以产生对 <code>addcnt</code> 的直接 PC 相对引用，并增加一个重定位，让静态链接器在构造此共享模块时解析它，不需要为它生成 GOT 条目。</p>
<p>此处编译器采用了最通用的方案，为所有引用使用 GOT。</p>
<h3 id="pic-函数调用">PIC 函数调用 </h3>
<p>假设程序调用一个定义在共享库中的函数，那么编译器在此共享模块加载前无法预测这个函数的运行时地址。</p>
<p>如果为该函数引用生成一条重定位记录，让动态链接器在程序加载的时候解析它，即需要链接器修改调用模块的代码段，这样就不是 PIC 的了。</p>
<p>GNU 编译系统使用<strong>延迟绑定</strong>（lazy binding）技术，将过程地址的绑定推迟到第一次调用该过程时。<strong>第一次调用过程的运行时开销很大</strong>，但此后的每次调用都只需要花费一条指令和一个间接的内存引用。</p>
<p><strong>过程链接表</strong>（Procedure Linkage Table, PLT）：PLT 是一个数组，其中每个条目是 16 字节代码。</p>
<p>每个被可执行程序调用的库函数都有它自己的 PLT 条目，每个条目负责调用一个具体的函数。</p>
<ul>
<li><code>PLT[0]</code> 是一个特殊条目，它跳转到<strong>动态链接器</strong>。</li>
<li><code>PLT[1]</code> 调用<strong>系统启动函数 <code>__libc_start_main</code></strong>，它初始化执行环境，调用 <code>main</code> 并处理其返回值。</li>
<li>从 <code>PLT[2]</code> 开始的条目调用用户代码调用的函数。</li>
</ul>
<p>GOT 和 PLT 联合使用时：</p>
<ul>
<li><strong><code>GOT[0]</code> 和 <code>GOT[1]</code> 包含动态链接器在解析函数地址时会使用的信息</strong>。</li>
<li><code>GOT[2]</code> 是<strong>动态链接器在 <code>ld-linux.so</code> 模块中的入口点</strong></li>
<li>其余的 <code>GOT</code> 条目对应于一个被调用的函数，其地址需要在运行时被解析。</li>
</ul>
<p>每个 GOT 条目都有一个对应的 PLT 条目，例如 <code>GOT[4]</code> 对应于 <code>PLT[2]</code>。</p>
<p>初始时，每个 GOT 条目都<strong>指向对应 PLT 条目的第二条指令</strong>。</p>
<p>一个目标模块如果调用了定义在共享库的任何函数，它就会有自己的 GOT 和 PLT。GOT 在数据段，而 PLT 在代码段。</p>
<p><img src="./note-part2_files/7-19-PLT和GOT调用外部函数.png" alt=""></p>
<p>首次执行 <code>callq addvec</code> 时：</p>
<ol>
<li><code>callq</code> 实际的参数是 <code>PLT[2]</code> 的地址，即 <code>addvec</code> 的 PLT 条目</li>
<li><code>PLT[2]</code> 中，程序跳转到 <code>*GOT[4]</code>，初始时这相当于跳转到 <code>PLT[2]</code> 的第二条指令</li>
<li>将 <code>addvec</code> 的 ID <code>0x1</code> 压栈，然后跳转到动态链接器对应的条目 <code>PLT[0]</code></li>
<li><code>PLT[0]</code> 将动态链接器的参数 <code>GOT[1]</code> 压栈，然后间接跳转到动态链接器的入口点 <code>GOT[2]</code>。动态链接器使用刚刚压栈的两个参数确定 <code>addvec</code> 的运行时地址，用它重写 <code>GOT[4]</code>，再把控制传递给 <code>addvec</code>。</li>
</ol>
<p>后续调用 <code>addvec</code> 时就可以直接经由 <code>PLT[2]</code> 跳转到 <code>addvec</code>，而不需要经过动态链接器。</p>
<h2 id="库打桩机制">库打桩机制 </h2>
<p><strong>库打桩</strong>（library interpositioning）：允许截获对共享库函数的调用，取而代之执行自己的代码。</p>
<h3 id="编译时打桩">编译时打桩 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// int.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span>  <span class="token comment">// 这里的 malloc.h 是本地的 malloc.h 文件, 而不是 system include 目录下的 malloc.h</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 本地 malloc.h 文件</span>
<span class="token comment">// 指示预处理器用对包装函数的调用替换掉对目标函数的调用</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">malloc</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token function">mymalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">free</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token function">myfree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span></span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">mymalloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">myfree</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// mymalloc.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">COMPILETIME</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span>  <span class="token comment">// 这里的 malloc.h 是 system include 目录下的 malloc.h</span></span>

<span class="token comment">// 包装函数</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">mymalloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc(%d) = %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span>size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">myfree</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"free(%p)\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc <span class="token parameter variable">-DCOMPILETIME</span> <span class="token parameter variable">-c</span> mymalloc.c
gcc -I. <span class="token parameter variable">-o</span> intc int.c mymalloc.o
<span class="token comment"># -I. 告诉预处理器在搜索通常的 system include 目录之前先在 . 目录查找头文件</span>
<span class="token comment"># 注意 mymalloc.c 中的包装函数是使用 malloc.h 头文件编译的</span>

./intc
<span class="token comment"># 可以得到追踪信息</span>
</code></pre><h3 id="链接时打桩">链接时打桩 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// mymalloc.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LINKTIME</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">__real_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">__real_free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">__wrap_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">__real_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc(%d) = %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span>size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">__wrap_free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">__real_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"free(%p)\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><p>Linux 静态链接器支持用 <code>--wrap f</code> 标志进行链接时打桩。</p>
<p>此标志将对符号 <code>f</code> 的引用解析成 <code>__wrap_f</code>，并将对符号 <code>__real_f</code> 的引用解析为 <code>f</code></p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>gcc <span class="token parameter variable">-DLINKTIME</span> <span class="token parameter variable">-c</span> mymalloc.c
gcc <span class="token parameter variable">-c</span> int.c

gcc -Wl,--wrap,malloc -Wl,--wrap,free <span class="token parameter variable">-o</span> intl int.o mymalloc.o
<span class="token comment"># -Wl,option 将 option 参数传递给链接器 (每个逗号被替换成空格)</span>
<span class="token comment"># 这里就把 --wrap malloc 以及 --wrap free 作为参数传递给链接器</span>
</code></pre><h3 id="运行时打桩">运行时打桩 </h3>
<p>编译时打桩需要能够访问程序源代码，链接时打桩需要能够访问程序的可重定位对象文件，但运行时打桩只需要能够访问可执行目标文件。这基于动态链接器的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LD_PRELOAD</mtext></mrow><annotation encoding="application/x-tex">\text{LD\_PRELOAD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">LD_PRELOAD</span></span></span></span></span> 环境变量。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LD_PRELOAD</mtext></mrow><annotation encoding="application/x-tex">\text{LD\_PRELOAD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">LD_PRELOAD</span></span></span></span></span> 被设置为一个<strong>共享库路径名的列表</strong>（以空格或分号分隔），那么在当加载或执行程序的时候需要解析未定义引用时，动态链接器（<code>ld-linux.so</code>）会先搜索 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LD_PRELOAD</mtext></mrow><annotation encoding="application/x-tex">\text{LD\_PRELOAD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">LD_PRELOAD</span></span></span></span></span> 中的库，然后再搜索其他任何库。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// mymalloc.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">RUNTIME</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>mallocp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> error<span class="token punctuation">;</span>

    mallocp <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>RTLD_NEXT<span class="token punctuation">,</span> <span class="token string">"malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">mallocp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc(%d) = %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span>size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>freep<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> error<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>

    freep <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>RTLD_NEXT<span class="token punctuation">,</span> <span class="token string">"free"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">dlerror</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">freep</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"free(%p)\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><p>注意这里我们的 wrapper function 的名字也是 <code>malloc</code>，所以我们需要使用 <code>dlfcn.h</code> 的函数显式地动态链接 <code>malloc</code>。</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token comment"># create shared library</span>
gcc <span class="token parameter variable">-DRUNTIME</span> <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fpic</span> <span class="token parameter variable">-o</span> mymalloc.so mymalloc.c <span class="token parameter variable">-ldl</span>
<span class="token comment"># compile main program</span>
gcc <span class="token parameter variable">-o</span> intr int.c
<span class="token comment"># run</span>
<span class="token assign-left variable">LD_PRELOAD</span><span class="token operator">=</span><span class="token string">"./mymalloc.so"</span><span class="token punctuation">;</span> ./intr
</code></pre><h2 id="处理目标文件的工具">处理目标文件的工具 </h2>
<p>GNU binutils 包：</p>
<ul>
<li><code>ar</code>：创建静态库，插入、删除、列出和提取成员</li>
<li><code>strings</code>：列出目标文件中所有可打印字符串</li>
<li><code>strip</code>：从目标文件中删除符号表信息</li>
<li><code>nm</code>：列出目标文件中的符号表</li>
<li><code>size</code>：列出目标文件中的节及其大小</li>
<li><code>readelf</code>：显示目标文件的完整结构，包括 ELF 头编码的所有信息，包含 <code>size</code> 和 <code>nm</code> 的功能</li>
<li><code>objdump</code>：所有二进制工具之母，显示一个目标文件中所有的信息。最大作用是反汇编 <code>.text</code></li>
</ul>
<p>以及 <code>ldd</code>：列出可执行文件的动态依赖</p>
<h1 id="异常控制流">异常控制流 </h1>
<p>程序计数器假设一个指令地址序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_0,a_1,\cdots,a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>。每次从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的过渡称为<strong>控制转移</strong>（control transfer），这样的控制转移序列是处理器的<strong>控制流</strong>（control flow）。如果每个指令在内存中都是相邻的，那么控制流就是平滑的，否则称控制流发生了“突变”，这通常由跳转、调用、返回等指令引起。</p>
<p>系统需要对系统状态的变化做出反应，在现代系统中体现为控制流的突变，这种突变称为<strong>异常控制流</strong>（Exceptional Control Flow, <strong>ECF</strong>）。</p>
<h2 id="异常">异常 </h2>
<p><strong>异常</strong>（exception）：是<strong>控制流的突变</strong>，它响应处理器状态的某些变化。</p>
<p>异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。</p>
<p><img src="./note-part2_files/8-1-异常.png" alt=""></p>
<p>称处理器<strong>状态</strong>的变化为<strong>事件</strong>（event）。</p>
<p>事件可能和当前指令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mtext>curr</mtext></msub></mrow><annotation encoding="application/x-tex">I_{\text{curr}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">curr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的执行有关，如虚拟内存缺页、整数除零、算术溢出，也可能无关，如系统定时器产生信号或一个 I/O 请求完成。</p>
<p>处理器检测到事件发生后，通过称为<strong>异常表</strong>（Exception table）的跳转表进行一个间接过程调用，到一个称为<strong>异常处理程序</strong>（exception handler）的操作系统子程序。此后，异常处理程序可能：</p>
<ul>
<li>将控制返回给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mtext>curr</mtext></msub></mrow><annotation encoding="application/x-tex">I_{\text{curr}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">curr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>将控制返回给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mtext>nexr</mtext></msub></mrow><annotation encoding="application/x-tex">I_{\text{nexr}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">nexr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mtext>curr</mtext></msub></mrow><annotation encoding="application/x-tex">I_{\text{curr}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">curr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的下一条指令)</li>
<li>终止被中断的程序</li>
</ul>
<h3 id="异常处理">异常处理 </h3>
<p>每种可能的异常类型都有一个唯一的<strong>非负整数</strong>的<strong>异常号</strong>（exception number）。一些由处理器设计者分配，例如除以零、缺页、内存访问违例、断点以及算术溢出；另一些由内核设计者分配，如系统调用和来自外部 I/O 设备的信号。</p>
<p>系统启动时（重启或加电），操作系统分配并初始化<strong>异常表</strong>。</p>
<p>异常表表项的索引是<strong>异常号</strong>，表项是<strong>指向异常处理程序的指针</strong>。</p>
<p>异常表起始地址在一个称为<strong>异常表基址寄存器</strong>（exception table base register）的特殊 CPU 寄存器中。触发异常时，按 <code>(异常表基址寄存器, 异常号, 8)</code> 的方式寻址异常处理程序。</p>
<p>异常和过程调用的不同：</p>
<ul>
<li><strong>返回地址</strong>或者是当前指令，或者是当前指令的下一条指令，或者终止</li>
<li><strong>额外的处理器状态也被压栈</strong>，如包含当前条件码的 EFLAGS 寄存器等。返回时，这些状态会被恢复</li>
<li>若控制从用户程序转移到内核，那么所有状态会被压到<strong>内核栈</strong>，而非用户栈</li>
<li>异常处理程序运行在<strong>内核模式</strong>，它们对所有系统资源都有完全的访问权限</li>
</ul>
<p>异常处理程序结束时，它可以执行一条“从中断返回”指令，返回被中断的程序（也可以不）。该指令<strong>将状态弹回</strong>到处理器的控制和数据寄存器，<strong>将模式恢复</strong>到<strong>用户模式</strong>（如果是用户程序产生了异常），然后将控制返回。</p>
<h3 id="异常的类别">异常的类别 </h3>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因</th>
<th style="text-align:center">异步 / 同步</th>
<th style="text-align:center">返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">中断（interrupt）</td>
<td style="text-align:center">来自 I/O 设备的信号</td>
<td style="text-align:center">异步</td>
<td style="text-align:center">返回到下一条指令</td>
</tr>
<tr>
<td style="text-align:center">陷阱（trap）</td>
<td style="text-align:center">有意的异常</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">返回到下一条指令</td>
</tr>
<tr>
<td style="text-align:center">故障（fault）</td>
<td style="text-align:center">潜在可恢复的错误</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">可能返回到当前指令</td>
</tr>
<tr>
<td style="text-align:center">终止（abort）</td>
<td style="text-align:center">不可恢复的错误</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">不返回</td>
</tr>
</tbody>
</table>
<h4 id="中断">中断 </h4>
<p><strong>异步</strong>：指<strong>事件的发生不依赖于当前指令的执行</strong>。</p>
<p>I/O 设备，如磁盘驱动器、网络适配器、磁盘控制器或定时器芯片，可以向处理器芯片上的一个引脚发信号，并将异常号放在系统总线上来触发中断。异常号标识了引起中断的设备。</p>
<p>在当前指令完成后，处理器注意到中断引脚电压升高，因此从系统总线读取异常号，调用对应的<strong>中断处理程序</strong>（interrupt handler），处理程序返回到当前指令的下一条指令。</p>
<h4 id="陷阱">陷阱 </h4>
<p><strong>同步</strong>：异常是执行当前指令的结果，这类指令称为<strong>故障指令</strong>（faulting instruction）。</p>
<p>陷阱是有意的异常，其最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，称为<strong>系统调用</strong>（system call）。</p>
<p>系统调用是用户进程向内核进程请求服务的主要方法。</p>
<p>处理器提供了 <code>syscall n</code> 指令，它导致一个到异常处理程序的陷阱，这个异常处理程序解析参数，并调用适当的内核程序。</p>
<p>借助异常实现系统调用，是为了从用户模式切换到内核模式。</p>
<p><img src="./note-part2_files/8-5-interrupt-trap.png" alt=""></p>
<h4 id="故障">故障 </h4>
<p>故障由错误情况引起。</p>
<p>如果故障处理程序可以修正这个错误情况，它就将控制返回到引起故障的指令，重新执行它。</p>
<p>否则它返回到内核的 <code>abort</code> 例程，终止引起故障的应用程序。</p>
<h4 id="终止">终止 </h4>
<p>终止是不可恢复的致命错误，例如 DRAM 或 SRAM 位被损坏时发生的奇偶错误。</p>
<p>终止处理程序从不将控制返回给应用程序，它直接返回到 <code>abort</code> 例程，终止应用程序。</p>
<p><img src="./note-part2_files/8-7-fault-abort.png" alt=""></p>
<h3 id="linuxx86-64-系统中的异常">Linux/x86-64 系统中的异常 </h3>
<table>
<thead>
<tr>
<th style="text-align:center">异常号</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">异常类别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">除法错误</td>
<td style="text-align:center">故障</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">一般保护故障</td>
<td style="text-align:center">故障</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">缺页</td>
<td style="text-align:center">故障</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">机器检查</td>
<td style="text-align:center">终止</td>
</tr>
<tr>
<td style="text-align:center">32~255</td>
<td style="text-align:center">操作系统定义的异常</td>
<td style="text-align:center">中断或陷阱</td>
</tr>
</tbody>
</table>
<p>0~31 号异常由 Intel 架构师定义，在任何 x86-64 系统上都是相同的。</p>
<h4 id="linuxx86-64-故障和终止">Linux/x86-64 故障和终止 </h4>
<p><strong>除法错误</strong>（divide error）：除以零，或除法指令的结果对目标操作数来说太大了。Unix 不会试图从中恢复，它会直接终止程序。Linux shell 通常报告为“浮点异常（<strong>Floating exception</strong>）”</p>
<p><strong>一般保护故障</strong>（general protection fault）：程序引用未定义的虚拟内存区域、试图写只读的代码段等等。Linux 不会尝试恢复它。Linux shell 通常报告为“段错误（<strong>Segmentation fault</strong>）”</p>
<p><strong>缺页</strong>（page fault）：指令引用了对应的物理页面尚不在内存中的虚拟地址。缺页处理程序会将页面从磁盘复制到内存，然后<strong>重新执行</strong>引起缺页异常的指令。</p>
<p><strong>机器检查</strong>（machine check）：在导致故障的指令执行时检测到致命硬件错误。机器检查处理程序从不返回控制给应用程序。</p>
<h4 id="linuxx86-64-系统调用">Linux/x86-64 系统调用 </h4>
<p>每个系统调用有唯一的整数号，对应一个<strong>到内核中跳转表的偏移量</strong>（和异常表不同）</p>
<p>C 程序可以用 <code>syscall</code> 函数直接调用任何系统调用，但这不必要，因为标准库提供了各种系统调用的包装函数。系统调用及其包装函数称为<strong>系统级函数</strong>。</p>
<p>所有到 Linux 系统调用的参数都是通过<strong>通用寄存器</strong>，而非栈，传递的。</p>
<p>按惯例，<strong>系统调用号放在 <code>%rax</code> 中</strong>，参数依次放在 <code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r8</code> 和 <code>%r9</code> 中。系统调用的返回值放在 <code>%rax</code> 中。从系统调用返回时，<strong>寄存器 <code>%rcx</code>、<code>%r11</code> 会被破坏</strong>。</p>
<p>-4095 到 -1 之间的返回值表明发生了错误，对应于负的 <code>errno</code>。</p>
<p>Linux x86-64 中常用的系统调用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">名字</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>read</code></td>
<td style="text-align:center">读文件</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>write</code></td>
<td style="text-align:center">写文件</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>open</code></td>
<td style="text-align:center">打开文件</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>close</code></td>
<td style="text-align:center">关闭文件</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>stat</code></td>
<td style="text-align:center">获取文件信息</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><code>mmap</code></td>
<td style="text-align:center">将内存页映射到文件</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><code>brk</code></td>
<td style="text-align:center">重置堆顶</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center"><code>dup2</code></td>
<td style="text-align:center">复制文件描述符</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center"><code>pause</code></td>
<td style="text-align:center">挂起进程直到信号到达</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td style="text-align:center"><code>alarm</code></td>
<td style="text-align:center">调度告警信号的传送</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td style="text-align:center"><code>getpid</code></td>
<td style="text-align:center">获取进程 ID</td>
</tr>
<tr>
<td style="text-align:center">57</td>
<td style="text-align:center"><code>fork</code></td>
<td style="text-align:center">创建新进程</td>
</tr>
<tr>
<td style="text-align:center">59</td>
<td style="text-align:center"><code>execve</code></td>
<td style="text-align:center">执行程序</td>
</tr>
<tr>
<td style="text-align:center">60</td>
<td style="text-align:center"><code>_exit</code></td>
<td style="text-align:center">终止进程</td>
</tr>
<tr>
<td style="text-align:center">61</td>
<td style="text-align:center"><code>wait4</code></td>
<td style="text-align:center">等待进程终止</td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center"><code>kill</code></td>
<td style="text-align:center">发送信号到进程</td>
</tr>
</tbody>
</table>
<p>以下例子调用 <code>write</code>：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1 表示 stdout，"hello, world\n" 是要写的内容，13 是要写的字节数</span>
    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"hello, world\n"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// asm</span>
<span class="token punctuation">.</span>section <span class="token punctuation">.</span>data
string<span class="token operator">:</span>
    <span class="token punctuation">.</span>ascii <span class="token string">"hello, world\n"</span>
string_end<span class="token operator">:</span>
    <span class="token punctuation">.</span>equ len<span class="token punctuation">,</span> string_end <span class="token operator">-</span> string

<span class="token punctuation">.</span>section <span class="token punctuation">.</span>text
<span class="token punctuation">.</span>globl main
main<span class="token operator">:</span>
    movq    $<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax
    movq    $<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdi
    movq    $string<span class="token punctuation">,</span> <span class="token operator">%</span>rsi
    movq    $len<span class="token punctuation">,</span> <span class="token operator">%</span>rdx
    syscall

    movq    $<span class="token number">60</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax
    movq    $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdi
    syscall
</code></pre><blockquote>
<p>有时，异常只指同步异常，不包括异步的中断。</p>
</blockquote>
<h2 id="进程">进程 </h2>
<p><strong>进程</strong>（process）：一个正在执行的程序的实例。</p>
<p>每个程序都运行在某个进程的<strong>上下文</strong>（context）中，上下文由一个程序正确运行所需的状态组成，包括</p>
<ul>
<li><strong>内存中的程序代码和数据</strong></li>
<li><strong>用户栈</strong></li>
<li><strong>内核栈</strong></li>
<li><strong>寄存器</strong>（通用目的寄存器、浮点寄存器、程序计数器、状态寄存器）</li>
<li>各种<strong>内核数据结构</strong>（如描述地址空间的<strong>页表</strong>、包含有关当前进程信息的<strong>进程表</strong>、包含进程已打开文件的信息的<strong>文件表</strong>）</li>
</ul>
<p>每次在 shell 中运行可执行目标文件，shell 都会创建一个新进程，在新进程中运行文件。应用程序也可以创建进程。</p>
<p>进程提供两个主要的抽象：</p>
<ul>
<li>一个<strong>独立的逻辑控制流</strong>，它提供了一个假象，好像程序独占地使用处理器</li>
<li>一个<strong>私有的地址空间</strong>，它提供了一个假象，好像程序独占地使用内存系统</li>
</ul>
<h3 id="逻辑控制流">逻辑控制流 </h3>
<p><img src="./note-part2_files/8-12-逻辑控制流.png" alt=""></p>
<p>与程序指令相对应的 PC 值的序列就是这个程序的<strong>逻辑控制流</strong>，简称逻辑流。</p>
<p>如上，处理器的物理控制流被分成了三个独立的逻辑控制流，它们交错执行，轮流使用处理器。每个进程执行流的一部分，然后被<strong>抢占</strong>（preempted）（暂时挂起）。</p>
<h3 id="并发流">并发流 </h3>
<p><strong>并发流</strong>（concurrent flow）：一个逻辑流的整个执行<strong>在时间上</strong>和另一个流重叠。上图中，进程 A 和 B，A 和 C 的执行是并发的，但 B 和 C 不是。</p>
<p>一个进程执行其控制流的每一时间段称为一个<strong>时间片</strong>（time slice），进程 A 的流由两个时间片组成。</p>
<p>并发（concurrency）就是指多个流并发地执行的现象。多任务（multitasking）又称时间分片（time slicing），指多个进程轮流运行的概念。</p>
<p><strong>并行流</strong>（paralell flow）是并发流的真子集。如果两个流<strong>并发地运行在不同的处理器核</strong>或<strong>不同的计算机</strong>上，那么它们就是并行流。并发流的思想与处理器的核数或计算机数无关，但并行流有关。</p>
<h3 id="私有地址空间">私有地址空间 </h3>
<p>进程为每个程序提供一个私有地址空间，一般来说，这个空间中的内存字节不能被其他进程读写，因此是<strong>私有</strong>的。</p>
<p>每个这样的空间都有相同的通用结构。代码段总是从 <code>0x400000</code> 起，地址空间顶部保留给内核。</p>
<p><img src="./note-part2_files/8-13-进程地址空间.png" alt=""></p>
<h3 id="用户模式和内核模式">用户模式和内核模式 </h3>
<p>处理器通常用某个控制寄存器的一个<strong>模式位</strong>（mode bit）来区分用户模式和内核模式。</p>
<p><strong>设置了模式位，进程就运行在内核模式下</strong>，处理器可以执行任何指令，访问系统中任何内存位置。</p>
<p><strong>不设置模式位，进程就运行在用户模式下</strong>，处理器不能执行<strong>特权指令</strong>（privileged instruction），例如停止处理器、改变模式位、发起 I/O 操作。用户模式下的进程也不能直接引用地址空间内核区内的代码和数据（只能通过系统调用接口），否则导致致命的保护故障。</p>
<p>从用户模式变为内核模式只能通过中断、故障或陷入系统调用这样的异常。</p>
<p>Linux 提供了 <code>/proc</code> 文件系统，将许多内核数据结构的内容输出为一个用户程序可读的文本文件的层次结构，从而允许用户模式进程访问。例如 <code>/proc/cpuinfo</code> 包含 CPU 类型。2.6 版本的 Linux 内核引用 <code>/sys</code> 文件系统，输出关于系统总线和设备的额外底层信息。</p>
<h3 id="上下文切换">上下文切换 </h3>
<p>内核可以决定<strong>调度某个（先前被抢占过的）进程</strong>，使这个进程抢占当前的进程，这种决策由内核中的<strong>调度器</strong>（scheduler）完成。</p>
<p>内核使用<strong>上下文切换</strong>（context switch）机制实现此过程中控制的交接，这包括：</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复目标进程的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ul>
<p>内核代表用户执行<strong>系统调用</strong>时，可能发生上下文切换。若系统调用因为等待某个事件而阻塞（例如等待磁盘读写），内核可以让当前进程休眠，切换到另一个进程。<code>sleep</code> 系统调用可以显式请求让调用进程休眠。不过即使系统调用没有阻塞，内核也可以选择执行上下文切换。</p>
<p><strong>中断</strong>也可能引起上下文切换。所有系统都有某种产生周期性定时器中断的机制，通常为每 1 ms 或每 10 ms。每次发生定时器中断时，内核判定当前进程已运行了足够长的时间，就会执行上下文切换。</p>
<p><img src="./note-part2_files/8-14-进程上下文切换.png" alt=""></p>
<p>上图中，进程 A 执行 <code>read</code> 系统调用陷入内核，内核陷阱处理程序请求来自磁盘控制器的 DMA 传输，然后内核执行从进程 A 到进程 B 的上下文切换。</p>
<p>注意：</p>
<ul>
<li>在切换之前，内核<strong>代表进程 A 在用户模式下</strong>执行指令</li>
<li>在切换的第一部分，内核<strong>代表进程 A 在内核模式下</strong>执行指令，然后某一时刻，它开始<strong>代表进程 B 在内核模式下</strong>执行指令</li>
<li>切换结束后，内核<strong>代表进程 B 在用户模式下</strong>执行指令。</li>
</ul>
<p>进程 B 在用户模式运行，直到磁盘发出中断信号表示数据已经传送到内存，内核判定进程 B 已经运行了足够长的时间，执行到进程 A 的上下文切换。</p>
<h2 id="系统调用错误处理">系统调用错误处理 </h2>
<p>Unix 系统级函数遇到错误时，通常会返回 -1，并设置全局整数变量 <code>errno</code>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 程序员总是需要检查错误 这很麻烦 可读性也很低：</span>
<span class="token comment">// 如果发生错误</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// strerror 函数返回一个描述 errno 错误的字符串</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"fork error: %s\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 我们将判断错误的语句提取出来：</span>
<span class="token keyword keyword-void">void</span> <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s: %s\n"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 然后定义一个 wrapper function：</span>
<span class="token class-name">pid_t</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"Fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 现在就可以更简洁地调用 fork 了：</span>
pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h2 id="进程控制">进程控制 </h2>
<h3 id="获取进程-id">获取进程 ID </h3>
<p>每个进程有唯一的正数进程 ID（PID），注意 <strong>PID 非零</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：调用进程的 PID</span>
<span class="token class-name">pid_t</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：调用进程父进程的 PID</span>
<span class="token class-name">pid_t</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// pid_t 在 Linux 上被定义为 int</span>
</code></pre><h3 id="创建和终止进程">创建和终止进程 </h3>
<p>从程序员角度，进程有三种状态：</p>
<ul>
<li><strong>运行</strong>：在 CPU 上执行，或等待被执行且最终会被内核调度</li>
<li><strong>停止</strong>：进程的执行被<strong>挂起</strong>（suspended），且不会被调度。发生在进程收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGSTOP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGSTOP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGSTOP</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTSTP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTSTP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTSTP</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTTIN</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTTIN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTTIN</span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTTOU</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTTOU}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTTOU</span></span></span></span></span> 信号时，并且进程会保持停止直到收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span> 信号。</li>
<li><strong>终止</strong>：进程永远地停止了。这通常是因为：
<ul>
<li>进程收到默认行为是终止进程的信号</li>
<li>从主程序返回</li>
<li>调用 <code>exit</code> 函数</li>
</ul>
</li>
</ul>
<p>用 <code>exit</code> 函数来<strong>终止</strong>进程（另一种方法是从主程序返回）：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token comment">// 终止进程，退出状态为 status</span>
<span class="token comment">// 返回：不返回</span>
<span class="token keyword keyword-void">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>父进程通过 <code>fork</code> <strong>创建</strong>新的运行的子进程。</p>
<p>子进程得到父进程<strong>用户级虚拟地址空间的副本</strong>，包括相同的代码、数据段、本地变量值、堆、共享库和用户栈。</p>
<p>子进程也拥有父进程<strong>文件描述符表的副本</strong>，可以读写父进程任何打开的文件。</p>
<p>子进程得到的副本<strong>与父进程独立</strong>。</p>
<p><code>fork</code> <strong>只被调用一次，但会返回两次</strong>：一次在调用进程（父进程）<strong>返回子进程的 PID</strong>，一次在新创建的子进程中<strong>返回 0</strong>。可以从返回值分辨父进程和子进程。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：子进程返回 0，父进程返回子进程的 PID，出错则返回 -1</span>
<span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">pid_t</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// wrapper function</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// child process</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child: x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent: x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output may **differ** on different systems</span>
<span class="token comment">// parent: x=0</span>
<span class="token comment">// child: x=2</span>
</code></pre><p>父进程和子进程是<strong>并发运行</strong>的独立进程，内核可以<strong>以任意方式</strong>交替执行它们逻辑控制流中的指令。在我们的例子中，父进程的 <code>printf</code> 先被执行，然后是子进程的，但在其它系统可能相反。</p>
<p>两个进程拥有<strong>相同且独立的地址空间</strong>。创建子进程后，父进程对状态的改变不会反映在子进程，子进程的改变也不会影响父进程。</p>
<p>父进程和子进程<strong>共享文件描述符表</strong>，父进程的 <code>stdout</code> 文件是打开的，且指向屏幕，所以子进程也继承了它，同样指向屏幕。</p>
<p><img src="./note-part2_files/8-16-进程图.png" alt=""></p>
<p>上图的嵌套 <code>fork</code> 中，四条 <code>printf</code> 可以以任意顺序执行。</p>
<h3 id="回收子进程">回收子进程 </h3>
<p>进程终止后，内核不会立即将其清除。进程会保持在一种已终止的状态，<strong>内核继续保存它的退出状态</strong>，直到被其父进程<strong>回收</strong>（reaped）。</p>
<p>父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后清除已终止的子进程，释放相关的内存空间。</p>
<p>终止但未被回收的进程称为<strong>僵死进程</strong>（zombie）。</p>
<p>如果父进程终止了，内核会安排 <code>init</code> 进程成为它的孤儿进程的养父，并代替它回收它的僵死子进程。<code>init</code> 进程 PID 为 1，在系统启动时由内核创建，不会终止，是所有进程的祖先。</p>
<p>长时间运行的程序总是应该回收其僵死子进程，以节约系统的内存资源。</p>
<p>进程可以调用 <code>waitpid</code> 函数等待其子进程终止或停止。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token comment">// 返回：若成功，返回子进程的 PID；若 WNOHANG，返回 0；若出错，返回 -1</span>
<span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token operator">*</span> statusp<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>当 <code>options = 0</code> 时，<code>waitpid</code> <strong>挂起调用进程</strong>，直到其<strong>等待集合</strong>（wait set）中的一个子进程终止，<strong>返回终止的子进程的 PID</strong>（如果调用时已经有子进程终止了，则立即返回）。</p>
<p>此时已终止的子进程已经被回收。</p>
<h4 id="判定等待集合的成员">判定等待集合的成员 </h4>
<p>等待集合的成员由参数 <code>pid</code> 确定：</p>
<ul>
<li>若 <code>pid &gt; 0</code>，等待集合为 <code>pid</code> 所指定的子进程</li>
<li>若 <code>pid = -1</code>，等待集合就是父进程的<strong>所有子进程</strong></li>
<li>其他等待集合不做讨论</li>
</ul>
<h4 id="修改默认行为">修改默认行为 </h4>
<p><code>options</code> 选项：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WNOHANG</mtext></mrow><annotation encoding="application/x-tex">\text{WNOHANG}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">WNOHANG</span></span></span></span></span>：若等待集合中的<strong>任何子进程都还未终止</strong>，则立即返回 <code>0</code>。可以用于在等待子进程终止的过程中做一些其他工作。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WUNTRACED</mtext></mrow><annotation encoding="application/x-tex">\text{WUNTRACED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">WUNTRACED</span></span></span></span></span>：挂起调用进程，直到等待集合的某个进程<strong>终止或被停止</strong>（而不只是终止），返回这个终止或停止的子进程的 PID</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WCONTINUED</mtext></mrow><annotation encoding="application/x-tex">\text{WCONTINUED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">WCONTINUED</span></span></span></span></span>：挂起调用进程，直到等待集合中一个正在运行的进程终止，<strong>或一个被停止的进程收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span> 信号重新开始执行</strong></li>
</ul>
<p>可以用 <code>|</code> 把这些以上选项组合起来：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WNOHANG</mtext><mo>∣</mo><mtext>WUNTRACED</mtext></mrow><annotation encoding="application/x-tex">\text{WNOHANG} \mid \text{WUNTRACED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WNOHANG</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">WUNTRACED</span></span></span></span></span>：<strong>立即返回</strong>，如果等待集合中的子进程均未停止或终止，则返回零；否则返回终止或停止的子进程的 PID</p>
<h4 id="检查已回收子进程的退出状态">检查已回收子进程的退出状态 </h4>
<p>如果 <code>statusp</code> 非空，<code>waitpid</code> 会在其中放上<strong>导致返回的子进程的状态信息</strong>。</p>
<p><code>status</code> 是 <code>statusp</code> 指向的值，其值在 <code>wait.h</code> 被解释为：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WIFEXITED(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WIFEXITED(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WIFEXITED(status)</span></span></span></span></span>：若子进程通过调用 <code>exit</code> 或一个 <code>return</code> <strong>正常终止</strong>，则返回真
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WEXITSTATUS(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WEXITSTATUS(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WEXITSTATUS(status)</span></span></span></span></span>：返回一个<strong>正常终止</strong>的子进程的<strong>退出状态</strong>，只有在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WIFEXITED()</mtext></mrow><annotation encoding="application/x-tex">\text{WIFEXITED()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WIFEXITED()</span></span></span></span></span> 返回真时才会被定义</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WIFSIGNALED(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WIFSIGNALED(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WIFSIGNALED(status)</span></span></span></span></span>：若子进程<strong>由于一个未被捕获的信号终止</strong>，则返回真
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WTERMISIG(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WTERMISIG(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WTERMISIG(status)</span></span></span></span></span>：返回<strong>导致子进程终止的信号编号</strong>，只有在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WIFSIGNALED()</mtext></mrow><annotation encoding="application/x-tex">\text{WIFSIGNALED()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WIFSIGNALED()</span></span></span></span></span> 返回真时才会被定义</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WIFSTOPPED(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WIFSTOPPED(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WIFSTOPPED(status)</span></span></span></span></span>：若引起返回的子进程当前是<strong>停止</strong>的，则返回真
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WSTOPSIG(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WSTOPSIG(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WSTOPSIG(status)</span></span></span></span></span>：返回<strong>导致子进程停止的信号编号</strong>，只有在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WIFSTOPPED()</mtext></mrow><annotation encoding="application/x-tex">\text{WIFSTOPPED()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WIFSTOPPED()</span></span></span></span></span> 返回真时才会被定义</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WCONTINUED(status)</mtext></mrow><annotation encoding="application/x-tex">\text{WCONTINUED(status)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">WCONTINUED(status)</span></span></span></span></span>：若引起返回的子进程<strong>收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span> 信号重新启动</strong>，则返回真</li>
</ul>
<h4 id="错误条件">错误条件 </h4>
<p>若调用进程<strong>无子进程</strong>，<code>waitpid</code> 返回 -1，并设置 <code>errno</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ECHILD</mtext></mrow><annotation encoding="application/x-tex">\text{ECHILD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">ECHILD</span></span></span></span></span>。</p>
<p>若 <code>waitpid</code> 函数<strong>被一个信号中断</strong>，那么它返回 -1，并设置 <code>errno</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>EINTR</mtext></mrow><annotation encoding="application/x-tex">\text{EINTR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">EINTR</span></span></span></span></span>。</p>
<blockquote>
<p>以上的常量由系统头文件定义，例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>WNOHANG</mtext></mrow><annotation encoding="application/x-tex">\text{WNOHANG}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">WNOHANG</span></span></span></span></span> 在 <code>wait.h</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ECHILD</mtext></mrow><annotation encoding="application/x-tex">\text{ECHILD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">ECHILD</span></span></span></span></span> 在 <code>errno.h</code></p>
</blockquote>
<h4 id="wait-函数"><code>wait</code> 函数 </h4>
<p><code>wait</code> 函数是 <code>waitpid</code> 的简化版本：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>


<span class="token comment">// 返回：若成功，返回终止子进程的 PID；若出错，返回 -1</span>
<span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span> statusp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等价于 waitpid(-1, &amp;status, 0);</span>
</code></pre><h4 id="示例">示例 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">2</span></span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> status<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>

    <span class="token comment">// create N children</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// reap N children in no particular order</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child %d terminated normally with exit status=%d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-else">else</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child %d terminated abnormally\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// "no more children" is the only normal termination</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> ECHILD<span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"waitpid error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="让进程休眠">让进程休眠 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：还要休眠的秒数</span>
<span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> secs<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：永远返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">pause</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>sleep</code> 使调用进程<strong>休眠至少 <code>secs</code> 秒</strong>，然后返回 0。</p>
<p>如果 <code>sleep</code> 函数被一个信号<strong>中断</strong>而过早返回，则返回剩余的秒数。</p>
<p><code>pause</code> 让调用进程休眠，直到该进程收到一个信号。</p>
<h3 id="加载并运行程序">加载并运行程序 </h3>
<p><code>execve</code> 以参数列表 <code>argv</code> 和环境变量列表 <code>envp</code> 加载并运行可执行目标文件 <code>filename</code></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：若成功，不返回；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><strong>只有当出现错误时</strong>（如 <code>filename</code> 不存在），<code>execve</code> 才会返回到调用程序。即，<code>execve</code> <strong>调用一次，从不返回</strong>。</p>
<p><img src="./note-part2_files/8-20-参数和环境变量.png" alt=""></p>
<p>按照惯例，<code>argv[0]</code> 是可执行目标文件的名字（路径），其余的元素是它的命令行参数。<strong><code>argv[argc]</code> 是 <code>NULL</code></strong>。</p>
<p><code>envp</code> 的每个元素的形式为 <code>name=value</code>，它同样以 <code>NULL</code> 结尾。</p>
<p><code>execve</code> 启动加载器，</p>
<ul>
<li>加载器删除子进程现有的虚拟内存段，创建一组新的代码段、数据段、堆段和栈段</li>
<li>新的栈段和堆段被初始化为零</li>
<li>新的代码和数据段被初始化为可执行文件的内容，这通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk）完成</li>
<li>最后，加载器跳转到 <code>_start</code>，<code>_start</code> 调用 <code>_libc_start_main</code>，最终调用 <code>main(int argc, char* argv[], char* envp[])</code></li>
</ul>
<p>当 <code>main</code> 开始执行时，用户栈的结构如下：</p>
<p><img src="./note-part2_files/8-22-用户栈典型结构.png" alt=""></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token comment">// 返回：若找到，返回指向 value 的指针；未找到则返回空指针</span>
<span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：若成功，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">setenv</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> newvalue<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> overwrite<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：无</span>
<span class="token keyword keyword-void">void</span> <span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>getenv</code> 在环境变量数组 <code>envp</code> 里搜索字符串 <code>"name=value"</code>。</p>
<p><code>setenv</code> 修改环境变量数组：</p>
<ul>
<li>若 <code>name</code> 不存在，将其添加到 <code>envp</code> 数组</li>
<li>若 <code>name</code> 存在，且 <code>overwrite</code> 为真，则将其值覆写为 <code>newvalue</code></li>
<li>否则不作操作</li>
</ul>
<p><code>unsetenv</code> 从 <code>envp</code> 数组中删除 <code>name</code>。</p>
<blockquote>
<p>程序是一堆代码和数据，可以作为目标文件存在于磁盘上，或作为段存在于地址空间中。<br>
进程是<strong>执行中程序的具体实例</strong>。程序总是运行在某个进程的上下文中。<br>
<code>fork</code> <strong>在新的进程中运行原来程序的拷贝</strong>。<br>
<code>execve</code> <strong>在当前进程的上下文中加载运行一个新的程序</strong>，它会覆盖当前进程的地址空间，但并未创建一个新的进程，因此新的程序仍有相同的 PID，且继承了调用 <code>execve</code> 时已打开的文件描述符</p>
</blockquote>
<h3 id="利用-fork-和-execve-运行程序">利用 <code>fork</code> 和 <code>execve</code> 运行程序 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXARGS</span> <span class="token expression"><span class="token number">128</span></span></span>

<span class="token comment">// If argv[0] is a builtin cmd, run it and return true</span>
<span class="token comment">// otherwise return false</span>
<span class="token keyword keyword-int">int</span> <span class="token function">builtin_command</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"quit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"&amp;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Called by eval()</span>
<span class="token comment">// Parse the cmd line and build argv (by modifying buf)</span>
<span class="token comment">// Return 1 if buf ends with &amp; or buf is blank, 0 otherwise</span>
<span class="token keyword keyword-int">int</span> <span class="token function">parseline</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> delim<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> argc<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> bg<span class="token punctuation">;</span>

    buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>    <span class="token comment">// replace the trailing '\n'</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// ignore leading spaces</span>
        buf<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment">// build argv</span>
    argc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>delim <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// delim is a ptr to the first occurrence of ' ' in buf (or NULL if not found)</span>
        argv<span class="token punctuation">[</span>argc<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>
        <span class="token operator">*</span>delim <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        buf <span class="token operator">=</span> delim <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// ignore spaces</span>
            buf<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">// ignore blank line</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'&amp;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        argv<span class="token punctuation">[</span><span class="token operator">--</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// remove &amp; in argv</span>

    <span class="token keyword keyword-return">return</span> bg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Evaluate cmd line</span>
<span class="token keyword keyword-void">void</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> cmdline<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span>MAXARGS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// argument list for execve()</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// holds modified cmd line</span>
    <span class="token keyword keyword-int">int</span> bg<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>

    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bg <span class="token operator">=</span> <span class="token function">parseline</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">builtin_command</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>

    <span class="token comment">// call execve in child process</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Command not found.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// parent waits for foreground job to terminate</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> status<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"waitfg: waitpid error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> cmdline<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// command line</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// read</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&gt; "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Fgets</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// evaluate</span>
        <span class="token function">eval</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这个 shell 不回收它的后台子进程，是有缺陷的。</p>
<h2 id="信号">信号 </h2>
<p><strong>Linux 信号</strong>是一种更高层的软件形式的异常，允许进程和内核中断其他进程。</p>
<p>信号通知进程<strong>系统中发生了一个事件</strong>，每种信号类型都对应某种系统事件。</p>
<p><strong>底层的硬件异常由内核的异常处理程序处理</strong>，一般对用户进程不可见。信号可以<strong>通知用户进程</strong>系统中发生了这些异常，例如，如果一个进程试图除以零，那么内核就会发送给它一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGFPE</mtext></mrow><annotation encoding="application/x-tex">\text{SIGFPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGFPE</span></span></span></span></span> 信号。</p>
<p>信号也可以通知用户进程系统中的软件事件，例如键入 <code>Ctrl+C</code>，内核就会发送一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGINT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGINT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGINT</span></span></span></span></span> 信号给这个前台进程组中的每个进程。一个进程可以向另一个进程发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGKILL</mtext></mrow><annotation encoding="application/x-tex">\text{SIGKILL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGKILL</span></span></span></span></span> 来强制终止它。当一个子进程终止时，内核会发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 给父进程。</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">默认行为</th>
<th style="text-align:center">相应事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGHUP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGHUP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGHUP</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">终端线挂断</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGINT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGINT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGINT</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">来自键盘的中断（<code>Ctrl+C</code>）</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGQUIT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGQUIT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">SIGQUIT</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">来自键盘的退出（<code>Ctrl+\</code>）</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGILL</mtext></mrow><annotation encoding="application/x-tex">\text{SIGILL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGILL</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">非法指令</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTRAP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTRAP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTRAP</span></span></span></span></span></td>
<td style="text-align:center">终止并转储内存</td>
<td style="text-align:center">跟踪陷阱</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGABRT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGABRT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGABRT</span></span></span></span></span></td>
<td style="text-align:center">终止并转储内存</td>
<td style="text-align:center">来自 <code>abort</code> 函数的终止信号</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGBUS</mtext></mrow><annotation encoding="application/x-tex">\text{SIGBUS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGBUS</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">总线错误</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGFPE</mtext></mrow><annotation encoding="application/x-tex">\text{SIGFPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGFPE</span></span></span></span></span></td>
<td style="text-align:center">终止并转储内存</td>
<td style="text-align:center">浮点异常</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGKILL</mtext></mrow><annotation encoding="application/x-tex">\text{SIGKILL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGKILL</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">杀死程序</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGUSR1</mtext></mrow><annotation encoding="application/x-tex">\text{SIGUSR1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGUSR1</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">用户定义信号 1</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGSEGV</mtext></mrow><annotation encoding="application/x-tex">\text{SIGSEGV}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGSEGV</span></span></span></span></span></td>
<td style="text-align:center">终止并转储内存</td>
<td style="text-align:center">无效内存引用</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGUSR2</mtext></mrow><annotation encoding="application/x-tex">\text{SIGUSR2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGUSR2</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">用户定义信号 2</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGPIPE</mtext></mrow><annotation encoding="application/x-tex">\text{SIGPIPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGPIPE</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">向一个没有读用户的管道写</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGALRM</mtext></mrow><annotation encoding="application/x-tex">\text{SIGALRM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGALRM</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">来自 <code>alarm</code> 函数的定时器信号</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTERM</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTERM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTERM</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">软件终止信号</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGSTKFLT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGSTKFLT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGSTKFLT</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">协处理器栈错误</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span></td>
<td style="text-align:center">忽略</td>
<td style="text-align:center">子进程终止或停止</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span></td>
<td style="text-align:center">忽略</td>
<td style="text-align:center">继续执行一个停止的进程</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGSTOP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGSTOP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGSTOP</span></span></span></span></span></td>
<td style="text-align:center">停止（直到下一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span>）</td>
<td style="text-align:center">不是来自终端的停止信号</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTSTP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTSTP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTSTP</span></span></span></span></span></td>
<td style="text-align:center">停止（直到下一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span>）</td>
<td style="text-align:center">来自终端的停止信号（<code>Ctrl+Z</code>）</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTTIN</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTTIN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTTIN</span></span></span></span></span></td>
<td style="text-align:center">停止（直到下一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span>）</td>
<td style="text-align:center">后台进程试图从终端读</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTTOU</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTTOU}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTTOU</span></span></span></span></span></td>
<td style="text-align:center">停止（直到下一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span>）</td>
<td style="text-align:center">后台进程试图向终端写</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGURG</mtext></mrow><annotation encoding="application/x-tex">\text{SIGURG}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGURG</span></span></span></span></span></td>
<td style="text-align:center">忽略</td>
<td style="text-align:center">套接字上的紧急情况</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGXCPU</mtext></mrow><annotation encoding="application/x-tex">\text{SIGXCPU}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGXCPU</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">超过 CPU 时间限制</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGXFSZ</mtext></mrow><annotation encoding="application/x-tex">\text{SIGXFSZ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGXFSZ</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">超过文件大小限制</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGVTALRM</mtext></mrow><annotation encoding="application/x-tex">\text{SIGVTALRM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGVTALRM</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">虚拟定时器期满</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGPROF</mtext></mrow><annotation encoding="application/x-tex">\text{SIGPROF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGPROF</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">剖析定时器期满</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGWINCH</mtext></mrow><annotation encoding="application/x-tex">\text{SIGWINCH}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGWINCH</span></span></span></span></span></td>
<td style="text-align:center">忽略</td>
<td style="text-align:center">窗口大小改变</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGIO</mtext></mrow><annotation encoding="application/x-tex">\text{SIGIO}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGIO</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">文件描述符已准备好进行 I/O 操作</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGPWR</mtext></mrow><annotation encoding="application/x-tex">\text{SIGPWR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGPWR</span></span></span></span></span></td>
<td style="text-align:center">终止</td>
<td style="text-align:center">电源故障</td>
</tr>
</tbody>
</table>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGKILL</mtext></mrow><annotation encoding="application/x-tex">\text{SIGKILL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGKILL</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGSTOP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGSTOP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGSTOP</span></span></span></span></span> 信号<strong>既不能被捕获也不能被忽略</strong>。</p>
<blockquote>
<p>多年前，主存是用<strong>磁芯存储器</strong>（core memory）实现的。转储内存（dumping core）是一个历史术语，指将代码和数据内存段的映像写到磁盘上</p>
</blockquote>
<h3 id="信号术语">信号术语 </h3>
<p>向目的进程发信号需要两个步骤：</p>
<ul>
<li>
<p><strong>发送信号</strong>：内核<strong>更新目的进程上下文中的某个状态</strong>。进程<strong>可以给自己发送信号</strong>。发送信号通常有两种原因：</p>
<ul>
<li>内核检测到一个<strong>系统事件</strong>，例如除以零或子进程终止</li>
<li>一个<strong>进程调用 <code>kill</code> 函数</strong>，显式地向另一个进程发送信号</li>
</ul>
</li>
<li>
<p><strong>接收信号</strong>：目的进程被内核强迫<strong>执行某个动作</strong>作为对信号的反应。进程可以：</p>
<ul>
<li><strong>忽略</strong>信号</li>
<li><strong>终止</strong></li>
<li><strong>捕获</strong>信号，执行<strong>信号处理程序</strong>（signal handler）</li>
</ul>
</li>
</ul>
<p>信号处理程序是一个用户层函数，其控制转移过程如图：</p>
<p><img src="./note-part2_files/8-27-信号处理.png" alt=""></p>
<p>发出但未被接收的信号是<strong>待处理信号</strong>（pending signal）。</p>
<p>任何时刻，<strong>一种信号类型至多只会有一个待处理信号</strong>。当进程已有一个类型为 <code>k</code> 的待处理信号后，任何接下来发送到此进程的 <code>k</code> 类型信号都会被丢弃。</p>
<p>进程可以<strong>阻塞</strong>接收某类型的信号。当某类型的信号被阻塞后，它可以被发送，但不会被接收，即发送后会成为一个待处理信号，直到它被进程解除阻塞。</p>
<p>一个待处理信号至多只能被接收一次。</p>
<p>内核为每个进程在 <strong><code>pending</code> 位向量</strong>中维护一个待处理信号的集合，在 <strong><code>blocked</code> 位向量</strong>（又称<strong>信号掩码</strong>，signal mask）中维护被阻塞的信号集合。当 <code>k</code> 类型信号被传送，<code>pending</code> 的第 <code>k</code> 位就会被设置；当 <code>k</code> 类型信号被接收，<code>pending</code> 的第 <code>k</code> 位就会被清除。</p>
<h3 id="发送信号">发送信号 </h3>
<h4 id="进程组">进程组 </h4>
<p>每个进程属于一个<strong>唯一</strong>的进程组（process group）。进程组由一个<strong>进程组 ID</strong> 标识，它是一个<strong>正整数</strong>。</p>
<p>默认地，子进程和其父进程属于同一个进程组。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：当前进程的进程组 ID</span>
<span class="token class-name">pid_t</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：如果成功，返回 0，否则返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token class-name">pid_t</span> pgid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>setpgid</code> 函数设置进程组 ID：</p>
<ul>
<li>如果 <code>pid &gt; 0</code>，就将进程 <code>pid</code> 的进程组 ID 设置为 <code>pgid</code></li>
<li>如果 <code>pid = 0</code>，就将<strong>当前进程</strong>的进程组 ID 设置为 <code>pgid</code></li>
<li>如果 <code>pgid = 0</code>，就使用 <code>pid</code> 所指定的进程的 PID 作为进程组 ID</li>
<li>如果 <code>pgid</code> 所指示的进程组尚不存在，就创建一个新的进程组</li>
</ul>
<p>例如：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果当前进程 pid 是 15213，那么这会创建一个新的进程组，其进程组 ID 也是 15213，并将当前进程加入到这个新进程组中</span>
</code></pre><h4 id="用-binkill-程序发送信号">用 <code>/bin/kill</code> 程序发送信号 </h4>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>/bin/kill <span class="token parameter variable">-9</span> <span class="token number">15213</span>    <span class="token comment"># 发送信号 9（SIGKILL）给进程 15213</span>

/bin/kill <span class="token parameter variable">-9</span> <span class="token parameter variable">-15213</span>   <span class="token comment"># 负的 PID 导致信号被发送给进程组 15213 的所有进程</span>
</code></pre><h4 id="用键盘发送信号">用键盘发送信号 </h4>
<p><strong>作业</strong>（job）表示<strong>为了对一条命令求值而创建的进程</strong>。</p>
<p>任何时刻至多只有一个前台作业（foreground job）。</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">sort</span>  <span class="token comment"># 这会创建一个由两个进程组成的前台作业</span>
</code></pre><p>shell 为每个作业创建一个独立的进程组，进程组 ID 通常取自作业中父进程中的一个（如图）</p>
<p><img src="./note-part2_files/8-28-前台和后台进程组.png" alt=""></p>
<p>键入 <code>Ctrl+C</code> 会使内核向前台进程组中的每个进程发送一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGINT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGINT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGINT</span></span></span></span></span> 信号，默认地，这导致前台作业终止。</p>
<p>键入 <code>Ctrl+Z</code> 会使内核向前台进程组中的每个进程发送一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGTSTP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGTSTP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGTSTP</span></span></span></span></span> 信号，默认地，这导致前台作业停止（挂起）。</p>
<h4 id="用-kill-函数发送信号">用 <code>kill</code> 函数发送信号 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token comment">// 返回：若成功，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>kill</code> 向进程 <code>pid</code> 发送信号 <code>sig</code>：</p>
<ul>
<li>如果 <code>pid &gt; 0</code>，将信号 <code>sig</code> 发送给进程 <code>pid</code></li>
<li>如果 <code>pid = 0</code>，信号就会发送给<strong>调用进程所属的进程组中的每个进程</strong></li>
<li>如果 <code>pid &lt; 0</code>，信号就会发送给进程组 <code>-pid</code> 中的每个进程</li>
</ul>
<h4 id="用-alarm-函数发送信号">用 <code>alarm</code> 函数发送信号 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：前一次的待处理的闹钟剩余的秒数（如果此次 alarm 调用没有发生的话），若没有待处理闹钟，返回 0</span>
<span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> secs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>alarm</code> 设置闹钟（alarm），安排内核在 <code>secs</code> 秒后向调用进程发送一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGALRM</mtext></mrow><annotation encoding="application/x-tex">\text{SIGALRM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGALRM</span></span></span></span></span> 信号。</p>
<p>如果 <code>secs = 0</code>，则不会安排新的闹钟。</p>
<p>对 <code>alarm</code> 的调用会<strong>取消任何待处理的闹钟</strong>。</p>
<h3 id="接收信号">接收信号 </h3>
<p><strong>当内核将进程 <code>p</code> 由内核模式切换到用户模式时，它会检查 <code>p</code> 的未被阻塞的待处理信号集合</strong>：</p>
<ul>
<li>如果该集合为空，内核将控制传递到 <code>p</code> 的逻辑控制流中的下一条指令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mtext>next</mtext></msub></mrow><annotation encoding="application/x-tex">I_{\text{next}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">next</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>否则内核选择集合中的某个信号 <code>k</code>（通常是最小的 <code>k</code>），并强制 <code>p</code> 接收 <code>k</code>。此后，控制传递回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mtext>next</mtext></msub></mrow><annotation encoding="application/x-tex">I_{\text{next}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">next</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<blockquote>
<p><code>printf</code> 会加锁访问输出端。如果进程在执行 <code>printf</code> 到对输出端加锁但尚未解锁时被抢占，那么它下一次被调度时，内核会先检查进程的待处理信号集合。如果存在未处理信号，则会先调用信号处理程序。如果信号处理程序内调用了 <code>printf</code>，由于先前对输出端的锁尚未解除，进程会死锁。</p>
</blockquote>
<p>每种信号都有一个默认行为，它是以下的一种：</p>
<ul>
<li>进程终止</li>
<li>进程终止并转储内存</li>
<li>进程停止（挂起），直到被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCONT</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCONT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCONT</span></span></span></span></span> 重启</li>
<li>进程忽略此信号</li>
</ul>
<p>进程可以使用 <code>signal</code> 函数修改某种信号的默认行为（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGSTOP</mtext></mrow><annotation encoding="application/x-tex">\text{SIGSTOP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGSTOP</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGKILL</mtext></mrow><annotation encoding="application/x-tex">\text{SIGKILL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGKILL</span></span></span></span></span> 除外）</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：若成功，返回指向前次处理程序的指针；若出错，返回 SIG_ERR，不设置 errno</span>
<span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>signal</code> 函数为 <code>signum</code> 类型信号安装（install）信号处理程序 <code>handler</code>：</p>
<ul>
<li>如果 <code>handler = SIG_IGN</code>，则忽略 <code>signum</code> 类型的信号</li>
<li>如果 <code>handler = SIG_DFL</code>，则将 <code>signum</code> 类型的信号行为恢复为默认</li>
<li>否则将 <code>signum</code> 类型的信号行为设置为调用 <code>handler</code> 指向的函数（安装信号处理程序 <code>handler</code>）</li>
</ul>
<p>调用信号处理程序称为<strong>捕获信号</strong>，执行信号处理程序称为<strong>处理信号</strong>。</p>
<p>当进程捕获了一个 <code>k</code> 类型的信号时，会将 <code>k</code> 作为一个整型参数调用该信号的处理程序。为信号处理程序添加这个参数，是为了使同一个处理函数可以处理不同类型的信号。</p>
<p>当处理程序返回时，控制通常被传递回进程<strong>被中断处的指令</strong>（某些系统中，被中断的系统调用会立即返回一个错误）。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">sigint_handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Sio_puts</span><span class="token punctuation">(</span><span class="token string">"Caught SIGINT!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// safe I/O</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// safe exit</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// install the SIGINT handler</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> sigint_handler<span class="token punctuation">)</span> <span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"signal error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// wait for Ctrl+C</span>
<span class="token punctuation">}</span>
</code></pre><p>信号处理程序也可以被其他信号处理程序中断。</p>
<p><img src="./note-part2_files/8-31-信号处理程序被其他信号处理程序中断.png" alt=""></p>
<h3 id="信号的阻塞和解除阻塞">信号的阻塞和解除阻塞 </h3>
<ul>
<li><strong>隐式阻塞机制</strong>：内核默认阻塞任何<strong>当前处理程序正在处理的信号的类型</strong>的待处理信号。图 8-31 中，如果在处理程序 S 运行时发送给该进程另一个 <code>s</code> 信号，那么当 S 返回后，<code>s</code> 会变成待处理信号</li>
<li><strong>显式阻塞机制</strong>：程序可以使用 <code>sigprocmask</code> 函数及其辅助函数来阻塞和解除阻塞信号</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token comment">// 返回：若成功，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> how<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> oldset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>sigprocmask</code> 根据 <code>how</code> 改变 <code>blocked</code> 位向量。</p>
<p>如果 <code>how</code> 是：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIG_BLOCK</mtext></mrow><annotation encoding="application/x-tex">\text{SIG\_BLOCK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SIG_BLOCK</span></span></span></span></span>：将 <code>set</code> 中的信号添加到 <code>blocked</code> 中，即 <code>blocked = blocked | set</code></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIG_UNBLOCK</mtext></mrow><annotation encoding="application/x-tex">\text{SIG\_UNBLOCK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SIG_UNBLOCK</span></span></span></span></span>：将 <code>set</code> 中的信号从 <code>blocked</code> 中删除，即 <code>blocked = blocked &amp; ~set</code></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIG_SETMASK</mtext></mrow><annotation encoding="application/x-tex">\text{SIG\_SETMASK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SIG_SETMASK</span></span></span></span></span>：将 <code>blocked</code> 设置为 <code>set</code>，即 <code>blocked = set</code></li>
</ul>
<p>如果 <code>oldset</code> 非空，那么 <code>oldset</code> 就会保存 <code>blocked</code> 的旧值</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token comment">// 以下四个函数的返回：若成功，返回 0；若出错，返回 -1</span>

<span class="token comment">// 初始化 set 为空</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化 set 为包含所有信号的集合</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将信号 signum 添加到 set 中</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将信号 signum 从 set 中删除</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 测试信号 signum 是否在 set 中</span>
<span class="token comment">// 返回：若在，返回 1；若不在，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>以下是用 <code>sigprocmask</code> 临时阻塞接收 <code>SIGINT</code> 信号的示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token class-name">sigset_t</span> mask<span class="token punctuation">,</span> prev_mask<span class="token punctuation">;</span>

<span class="token function">Sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Block SIGINT and save current signal mask</span>
<span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ... Code region that will not be interrupted by SIGINT ...</span>

<span class="token comment">// Restore previous signal mask which unblocks SIGINT</span>
<span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_mask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="编写信号处理程序">编写信号处理程序 </h3>
<p>信号处理程序和主程序<strong>并发</strong>运行，共享全局变量。</p>
<h4 id="安全的信号处理">安全的信号处理 </h4>
<p><strong>处理程序要尽量简单</strong>：例如处理程序可以只简单地设置一个全局标志，然后立即返回，让主程序完成所有与接收信号有关的处理</p>
<p><strong>只在处理程序中调用异步信号安全的函数</strong>：异步信号安全的函数要么是<strong>可重入</strong>的（只访问局部变量），要么不能被信号处理程序中断。注意，<code>printf</code>、<code>sprintf</code>、<code>malloc</code>、<code>exit</code> 都不在此列。</p>
<p><img src="./note-part2_files/8-33-异步信号安全的函数.png" alt=""></p>
<p><code>write</code> 函数是唯一安全的在信号处理程序中产生输出的函数。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// CSAPP 开发了 SIO 包以供在信号处理程序中使用</span>

<span class="token comment">// 返回：若成功，返回传送的字节数；若出错，返回 -1</span>
<span class="token class-name">ssize_t</span> <span class="token function">sio_puts</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">sio_strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 返回：若成功，返回传送的字节数；若出错，返回 -1</span>
<span class="token class-name">ssize_t</span> <span class="token function">sio_putl</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">sio_ltoa</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Based on K&amp;R itoa()</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">sio_puts</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 返回：无</span>
<span class="token keyword keyword-void">void</span> <span class="token function">sio_error</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sio_puts</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>保存和恢复 <code>errno</code></strong>：许多 Linux 异步信号安全的函数会在出错返回时设置 <code>errno</code>。在处理程序中调用此类函数可能干扰主程序依赖 <code>errno</code> 的部分。在进入处理程序时，我们<strong>将 <code>errno</code> 保存在一个局部变量，并在处理程序返回时恢复它</strong>。如果处理程序不返回（调用 <code>_exit</code> 终止进程），则无需这么做</p>
<p><strong>阻塞所有的信号，保护对共享全局数据结构的访问</strong>：如果处理程序和主程序或其他处理程序共享某个全局数据结构，那么在读写该数据结构时，处理程序和主程序应<strong>暂时阻塞所有信号</strong>。从主程序访问数据结构 <code>d</code> 通常需要一系列指令，如果此指令序列被访问 <code>d</code> 的其他处理程序中断，那么就会得到不可预知的结果。</p>
<p><strong>用 <code>volatile</code> 声明全局变量</strong>：如果处理程序和 <code>main</code> 函数共享全局变量 <code>g</code>，处理程序会更新 <code>g</code>，<code>main</code> 周期性地读取 <code>g</code>。对于编译器而言，<code>main</code> 中的 <code>g</code> 看起来是一个不变量，它可能会将 <code>g</code> 缓存在寄存器中，导致 <code>main</code> 无法看到 <code>g</code> 的更新。<strong>用 <code>volatile</code> 声明 <code>g</code></strong>，可以强迫编译器每次都从内存中读取 <code>g</code> 的值。当然，对于 <code>g</code> 的访问也应该阻塞所有信号。</p>
<p><strong>用 <code>sig_atomic_t</code> 声明标志</strong>：常见设计中，处理程序写全局标志来记录收到了信号，主程序周期性地读这个标志，响应信号，然后清除此标志。对这种标志，C 提供整型类型 <code>sig_atomic_t</code>，保证对它的读写是<strong>原子的</strong>。</p>
<p>即将标志声明成</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-volatile">volatile</span> <span class="token class-name">sig_atomic_t</span> flag<span class="token punctuation">;</span>
<span class="token comment">// 可以安全地单个地读写 flag，而不用暂时阻塞信号</span>
<span class="token comment">// 但对于 flag++ 或 flag += 10 这种可能需要多条指令的操作，仍然需要阻塞信号</span>
</code></pre><h4 id="正确的信号处理">正确的信号处理 </h4>
<p>未处理的信号<strong>不排队</strong>。<code>pending</code> 中每种类型的信号只对应一位。</p>
<p>如果目的进程正在执行 <code>k</code> 类型信号的处理程序，且此时两个 <code>k</code> 类型信号被传送，那么第二个信号就会被简单地丢弃。</p>
<p>如果存在一个待处理的信号，就表明之前已有至少一个同类型信号到达。</p>
<p>以下示例展现了一个错误的信号处理程序。父进程创建三个子进程，当有子进程停止或终止时，内核向父进程发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 信号，父进程捕获这个信号，执行 <code>handler1</code> 处理它并回收子进程。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// Buggy code</span>

<span class="token comment">// SIGCHILD handler</span>
<span class="token keyword keyword-void">void</span> <span class="token function">handler1</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> olderrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">sio_error</span><span class="token punctuation">(</span><span class="token string">"waitpid error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sio_puts</span><span class="token punctuation">(</span><span class="token string">"Handler reaped child\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// do some cleanup work, modeled by Sleep</span>
    errno <span class="token operator">=</span> olderrno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">,</span> n<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXBUF<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> handler1<span class="token punctuation">)</span> <span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"signal error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Parent creates children</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from child %d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Parent waits for terminal input and then processes it</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent processing input\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>运行后，我们发现尽管发送了三个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 信号，但只有两个信号被接收。如果用 <code>Ctrl+Z</code> 挂起父进程，并执行 <code>ps t</code>，我们会看到有一个子进程未被回收，成为了僵死进程。</p>
<p>这是因为 <code>handler1</code> 忽略了信号不会排队的问题。</p>
<ul>
<li>父进程接收并捕获了第一个信号，在 <code>handler1</code> 执行时，第二个信号被传送，并被添加到了待处理信号集合中，然而，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 被 <code>handler1</code> 阻塞，它不会被接收。</li>
<li>此后（<code>handler1</code> 仍未返回），第三个信号到达，因为已有一个待处理的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span>，这个信号会被直接丢弃。</li>
<li><code>handler1</code> 返回时，内核注意到有一个待处理的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span>，迫使父进程接收这个信号。父进程捕获它，并再次调用 <code>handler1</code>。此后就再也没有待处理的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 了，第三个信号永久地丢失了。</li>
</ul>
<p>存在待处理的信号，只是说明<strong>自进程最后一次收到某个信号以来，至少已经有一个同类型信号被发送了</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">handler2</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> olderrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>

    <span class="token comment">// replaced if with while, so handler reaps as many zombies as possible</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Sio_puts</span><span class="token punctuation">(</span><span class="token string">"Handler reaped child\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> ECHILD<span class="token punctuation">)</span>
        <span class="token function">Sio_error</span><span class="token punctuation">(</span><span class="token string">"waitpid error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    errno <span class="token operator">=</span> olderrno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="可移植的信号处理">可移植的信号处理 </h4>
<p>不同的 Unix 系统中信号处理的语义可能不同。</p>
<ul>
<li><strong><code>signal</code> 函数的语义各有不同</strong>：有些老旧的 Unix 在信号 <code>k</code> 被处理程序捕获之后将对信号 <code>k</code> 的反应恢复到默认（卸载处理程序），于是每次运行之后，处理程序必须调用 <code>signal</code> 函数，显式地重新安装它自己。</li>
<li><strong>系统调用可以被中断</strong>：<code>read</code>、<code>write</code>、<code>accept</code> 这样的系统调用潜在地会阻塞进程一段较长的时间，称为<strong>慢速系统调用</strong>。在某些老旧 Unix 中，当处理程序捕获到信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并设置 <code>errno</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>EINTR</mtext></mrow><annotation encoding="application/x-tex">\text{EINTR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">EINTR</span></span></span></span></span>。程序员必须手动重启被中断的系统调用的代码</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token comment">// 由 POSIX 定义，用于明确指令信号处理语义</span>
<span class="token comment">// 返回：若成功，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> signum<span class="token punctuation">,</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sigaction</span><span class="token operator">*</span> act<span class="token punctuation">,</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sigaction</span><span class="token operator">*</span> oldact<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>我们定义一个 wrapper function <code>Signal</code>，它的信号处理语义是：</p>
<ul>
<li>只有信号处理程序当前正在处理的信号类型会被阻塞</li>
<li>信号不会排队等待</li>
<li>只要可能，被中断的系统调用会自动重启</li>
<li>一旦设置了信号处理程序，它就不会被自动卸载</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token class-name">handler_t</span><span class="token operator">*</span> <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">handler_t</span><span class="token operator">*</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sigaction</span> action<span class="token punctuation">,</span> old_action<span class="token punctuation">;</span>

    action<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token comment">// set handler</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>action<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// empty signal mask</span>
    action<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> SA_RESTART<span class="token punctuation">;</span>   <span class="token comment">// restart interrupted system calls if possible</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">sigaction</span><span class="token punctuation">(</span>signum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>action<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_action<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"Signal error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>old_action<span class="token punctuation">.</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>练习 8.8：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-volatile">volatile</span> <span class="token keyword keyword-long">long</span> counter <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">handler1</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">sigset_t</span> mask<span class="token punctuation">,</span> prev_mask<span class="token punctuation">;</span>

    <span class="token function">Sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// block all signals</span>
    <span class="token function">Sio_putl</span><span class="token punctuation">(</span><span class="token operator">--</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_mask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// restore signal mask</span>

    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
    <span class="token class-name">sigset_t</span> mask<span class="token punctuation">,</span> prev_mask<span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld "</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">signal</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span> handler1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// install handler1</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// send signal to child</span>
    <span class="token function">Waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">Sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// block all signals</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_mask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// restore signal mask</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output: 213</span>
</code></pre><p>虽然 <code>counter</code> 被声明成了 <code>volatile</code> 的，但是<strong>父进程和子进程并不共享同一个 <code>counter</code></strong>，子进程的地址空间是父进程的拷贝，因此它们的两个 <code>counter</code> 也彼此独立。</p>
<h3 id="同步流以避免讨厌的并发错误">同步流以避免讨厌的并发错误 </h3>
<p>并发流可能交错的数量和指令数量呈指数关系，极其复杂。我们需要以某种方式同步并发流，得到最大的可行的交错的集合，每个可行交错都能得到正确结果。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// A shell program with a subtle sync error</span>
<span class="token keyword keyword-void">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> olderrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>
    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_all<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>

    <span class="token function">Sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// reap a zombie child</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_all<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">deletejob</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// delete the child from the job list</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> ECHILD<span class="token punctuation">)</span>
        <span class="token function">Sio_error</span><span class="token punctuation">(</span><span class="token string">"waitpid error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    errno <span class="token operator">=</span> olderrno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> pid<span class="token punctuation">;</span>
    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_all<span class="token punctuation">;</span>

    <span class="token function">Sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">initjobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// initialize the job list</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// child process</span>
            <span class="token function">Execve</span><span class="token punctuation">(</span><span class="token string">"/bin/date"</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// parent process</span>
        <span class="token function">addjob</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// add the child to the job list</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>当父进程创建一个新子进程后，它将这个子进程添加到作业列表（通过调用 <code>addjob(pid)</code>）。当父进程在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 处理程序中回收一个僵死子进程时，它就从作业列表中删除这个子进程（通过调用 <code>deletejob(pid)</code>）。</p>
<p>这个程序有一个<strong>同步错误</strong>，当事件按以下顺序发生时，就会出错：</p>
<ul>
<li>父进程执行 <code>fork</code>，内核调度新创建的子进程运行</li>
<li>在父进程能够再次有运行之前，子进程终止，成为僵死进程，内核传递一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 给父进程</li>
<li>父进程变成可运行状态，在它执行之前，内核注意到未处理的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span>，迫使父进程接收这个信号</li>
<li>信号处理程序捕获 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span>，并回收子进程，调用 <code>deletejob(pid)</code>，<strong>此时父进程尚未调用 <code>addjob(pid)</code></strong>，因此 <code>deletejob</code> 什么也不会做</li>
<li>信号处理程序返回，父进程继续执行，调用 <code>addjob(pid)</code>，将已被回收的不存在的子进程添加到作业列表中</li>
</ul>
<p>这是一个称为<strong>竞争</strong>（race）的经典同步错误的示例。<code>main</code> 函数中的 <strong><code>addjob</code> 和信号处理程序中的 <code>deletejob</code>之间存在竞争</strong>，如果 <code>addjob</code> 赢得竞争，结果就是正确的，否则就是错误的。此类错误极其难以调试。</p>
<p><strong>在创建子进程之前阻塞 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span>，并在准备好回收子进程时解除它的阻塞</strong>，即在调用 <code>fork</code> 之前阻塞 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 信号，然后在调用 <code>addjob</code> 之后解除它的阻塞，可以保证<strong>子进程回收会在 <code>addjob</code> 之后发生</strong>。</p>
<p><strong>子进程会继承其父进程的被阻塞信号集合</strong>，所以我们需要在调用 <code>execve</code> 之前解除对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 的阻塞。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> pid<span class="token punctuation">;</span>
    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>

    <span class="token function">Sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">initjobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// initialize the job list</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// block SIGCHLD</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// child process</span>
            <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// unblock SIGCHLD in child process</span>
            <span class="token function">Execve</span><span class="token punctuation">(</span><span class="token string">"/bin/date"</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// parent process</span>
        <span class="token function">addjob</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// add the child to the job list</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// unblock SIGCHLD</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="显式地等待信号">显式地等待信号 </h3>
<p>当 Linux shell 创建一个前台作业时，在接收下一条用户命令之前，它必须等待作业终止，并被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 处理程序回收。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-volatile">volatile</span> <span class="token class-name">sig_atomic_t</span> pid<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> olderrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    errno <span class="token operator">=</span> olderrno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">sigint_handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">sigset_t</span> mask<span class="token punctuation">,</span> prev<span class="token punctuation">;</span>

    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> sigchld_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> sigint_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// block SIGCHLD</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">Execve</span><span class="token punctuation">(</span><span class="token string">"/bin/date"</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// unblock SIGCHLD</span>

        <span class="token comment">// wait for SIGCHLD to be received (wasteful)</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pid<span class="token punctuation">)</span>
            <span class="token punctuation">;</span>

        <span class="token comment">// do some wark after SIGCHLD is received</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>创建子进程后，父进程将 <code>pid</code> 置零，直到收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span> 信号，<code>sigchld_handler</code> 将 <code>pid</code> 设置为子进程的 PID。这是正确的，但浪费了 CPU 资源。</p>
<p>一种解决办法是将循环体改为 <code>pause</code>，以避免对 CPU 资源的浪费：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pid<span class="token punctuation">)</span>
    <span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 注意循环仍然是必要的，即不能直接改为：</span>
<span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 因为如果父进程收到 SIGINT，pause 就会被中断</span>
</code></pre><p>然而这段代码有严重的竞争条件，如果<strong>在 <code>while</code> 之后、<code>pause</code> 之前收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGCHLD</mtext></mrow><annotation encoding="application/x-tex">\text{SIGCHLD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGCHLD</span></span></span></span></span>，那么 <code>pause</code> 会使进程永远休眠</strong>。</p>
<p>另一种方案用 <code>sleep</code> 替换 <code>pause</code>。它的问题是<strong>太慢了</strong>。如果在 <code>while</code> 之后、<code>sleep</code> 之前收到信号，程序需要等较长时间才能再次检查 <code>pid</code>。换用 <code>nanosleep</code> 也不能解决问题：太短的休眠间隔太浪费，太大的休眠间隔又太慢。</p>
<p>合适的解决方法是使用 <code>sigsuspend</code>：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token comment">// 返回：-1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigsuspend</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>sigsuspend</code> <strong>暂时用 <code>mask</code> 替换当前的阻塞集合，然后挂起调用进程，直到收到一个信号</strong>：</p>
<ul>
<li>如果信号行为是<strong>终止</strong>，那么该进程不从 <code>sigsuspend</code> 返回，<strong>直接终止</strong></li>
<li>如果信号行为是<strong>调用处理程序</strong>，那么 <code>sigsuspend</code> <strong>从处理程序返回</strong>，恢复调用 <code>sigsuspend</code> 时原有的 <code>blocked</code> 位向量</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 调用 sigsuspend 就如同**原子地**执行：</span>
<span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>原子属性保证在等价代码中，对 <code>sigprocmask</code> 和 <code>pause</code> 的调用是连续的，不会被中断，从而消除了潜在的竞争。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">sigset_t</span> mask<span class="token punctuation">,</span> prev<span class="token punctuation">;</span>

    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> sigchld_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> sigint_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// block SIGCHLD</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// wait for SIGCHLD to be received (wasteful)</span>
        pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pid<span class="token punctuation">)</span>
            <span class="token comment">// temporarily unblocks SIGCHLD, and then sleeps until the parent catches a signal</span>
            <span class="token comment">// before returning, it restores the original blocked set, which blocks SIGCHLD again.</span>
            <span class="token function">sigsuspend</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// optionally unblock SIGCHLD</span>
        <span class="token comment">// this might be useful in a real shell with bg jobs that need to be reaped</span>
        <span class="token function">Sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// do some wark after SIGCHLD is received</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="非本地跳转">非本地跳转 </h2>
<p>C 提供了一种用户级异常控制流形式，称为<strong>非本地跳转</strong>（nonlocal jump），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;setjmp.h&gt;</span></span>

<span class="token comment">// 返回：若直接调用，返回 0；若从 longjmp 返回，返回非 0</span>
<span class="token keyword keyword-int">int</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：返回到 setjmp</span>
<span class="token keyword keyword-void">void</span> <span class="token function">longjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// setjmp 和 longjmp 的可以被信号处理程序使用的版本</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sigsetjmp</span><span class="token punctuation">(</span>sigjmp_buf env<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> savesigs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">siglongjmp</span><span class="token punctuation">(</span>sigjmp_buf env<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>setjmp</code> 在 <code>env</code> 中保存当前的调用环境，以供 <code>longjmp</code> 使用，然后返回零。</p>
<p><code>longjmp</code> 从 <code>env</code> 中恢复调用环境，并返回到最近一次初始化 <code>env</code> 的 <code>setjmp</code>，这个 <code>setjmp</code> 将会返回非零值。</p>
<p><strong>调用环境</strong>包括程序计数器、栈指针和通用目的寄存器。</p>
<p><code>setjmp</code> 的返回值<strong>不能赋值给变量</strong>，但它可以用在 <code>switch</code> 或条件语句的测试中：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>rc <span class="token operator">=</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// error!</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">setjmp</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token comment">// ok</span>
</code></pre><p><code>setjmp</code> 函数<strong>只被调用一次，但返回多次</strong>，而 <code>longjmp</code> 函数<strong>被调用一次，但从不返回</strong>。</p>
<p>非本地跳转允许从深层嵌套的函数调用中立即返回：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 使用非本地跳转跳出深层嵌套的函数调用</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

jmp_buf buf<span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> error1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> error2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span><span class="token function">setjmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-case">case</span> <span class="token number">0</span><span class="token operator">:</span>
            <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-case">case</span> <span class="token number">1</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Detected an error1 condition in foo\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-case">case</span> <span class="token number">2</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Detected an error2 condition in foo\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-default">default</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unknown error condition in foo\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Deeply nested function foo</span>
<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>error1<span class="token punctuation">)</span>
        <span class="token function">longjmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>error2<span class="token punctuation">)</span>
        <span class="token function">longjmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>非本地跳转可以<strong>使信号处理程序分支到一个特殊的代码位置</strong>，而不是返回到被信号中断了的指令处。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

sigjmp_buf buf<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">siglongjmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sigsetjmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Sio_puts</span><span class="token punctuation">(</span><span class="token string">"starting\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token function">Sio_puts</span><span class="token punctuation">(</span><span class="token string">"restarting\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Sio_puts</span><span class="token punctuation">(</span><span class="token string">"processing...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// control never reaches here</span>
<span class="token punctuation">}</span>
</code></pre><p>当键入 <code>Ctrl+C</code> 时，<code>handler</code> 利用非本地跳转实现软重启。</p>
<p>程序第一次启动时，对 <code>sigsetjmp</code> 的调用将会保存<strong>调用环境</strong>和<strong>信号的上下文</strong>（包括 <code>pending</code> 和 <code>blocked</code>）。</p>
<p>为了避免竞争，必须<strong>在调用 <code>sigsetjmp</code> 之后再安装信号处理程序</strong>，否则就可能在调用 <code>sigsetjmp</code> 前调用 <code>siglongjmp</code>。</p>
<p><code>sigsetjmp</code> 和 <code>siglongjmp</code> <strong>不是异步信号安全函数</strong>，因为 <code>siglongjmp</code> 可以跳到任意代码。我们必须小心，<strong>在 <code>siglongjmp</code> 可达的代码中不要调用异步信号不安全的函数</strong>。</p>
<blockquote>
<p>C++ 和 Java 的异常机制是更高层次的。可以把 <code>try</code> 中的 <code>catch</code> 子句看作 <code>setjmp</code>，把 <code>throw</code> 看作 <code>longjmp</code>。</p>
</blockquote>
<h2 id="操作进程的工具">操作进程的工具 </h2>
<ul>
<li><code>strace</code>：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用 <code>-static</code> 编译程序，可以得到一个更干净、不带有大量与共享库相关的输出的轨迹</li>
<li><code>ps</code>：列出当前系统中的进程（包括僵死进程）</li>
<li><code>top</code>：打印当前进程资源使用的信息</li>
<li><code>pmap</code>：显示进程的内存映射</li>
<li><code>/proc</code>：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容</li>
</ul>
<h1 id="虚拟内存">虚拟内存 </h1>
<h2 id="物理和虚拟寻址">物理和虚拟寻址 </h2>
<p>主存被组织成一个由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个连续的字节大小的单元的数组，每个字节都拥有一个唯一的<strong>物理地址</strong>（Physical Address, <strong>PA</strong>）。</p>
<p>CPU 直接使用物理地址寻址的方式就是<strong>物理寻址</strong>（physical addressing）。在物理寻址模型中，CPU 加载数据时生成一个有效的物理地址，将它通过<strong>内存总线</strong>传递给主存，主存取出对应数据，并将其返回给 CPU 寄存器。</p>
<p>早期 PC、数字信号处理器、嵌入式微处理器和 Cray 超级计算机使用物理寻址。</p>
<p>现代处理器使用<strong>虚拟寻址</strong>（virtual addressing）。在虚拟寻址模型中，CPU 生成一个<strong>虚拟地址</strong>（Virtual Address, VA），将它经过<strong>地址翻译</strong>（address translation）转换成一个有效的物理地址，然后将其通过内存总线传递给主存。</p>
<p>地址翻译需要硬件和操作系统紧密配合，CPU 芯片上的<strong>内存管理单元</strong>（Memory Management Unit, <strong>MMU</strong>）负责执行地址翻译，它利用存放在主存中的页表动态翻译虚拟地址，页表的内容由操作系统管理。</p>
<h2 id="地址空间">地址空间 </h2>
<p><strong>地址空间</strong>（address space）是一个<strong>非负整数</strong>地址的有序集合。</p>
<p>如果地址空间中的整数是连续的，那么它是一个<strong>线性地址空间</strong>（linear address space）。我们总假设地址空间是线性的。</p>
<p>在带虚拟内存的系统中，CPU 从一个有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">N=2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个地址的地址空间中生成虚拟地址，其中的地址从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 编号。这个地址空间被称为<strong>虚拟地址空间</strong>（Virtual Address Space, <strong>VAS</strong>）。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 称为<strong>虚拟地址空间的位数</strong>（virtual address space size），它决定了虚拟地址空间的大小。</p>
<p>物理地址从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 编号，构成了一个<strong>物理地址空间</strong>（Physical Address Space, <strong>PAS</strong>）。我们假设物理地址空间的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的位数次幂，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 字节。</p>
<h2 id="虚拟内存作为缓存的工具">虚拟内存作为缓存的工具 </h2>
<p>概念上，虚拟内存被组织为一个存放在磁盘上大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的字节数组，它被缓存在主存中。</p>
<p>VM 系统将虚拟内存分割成<strong>虚拟页</strong>（Virtual Page, VP），每个虚拟页都包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">P=2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span> 个字节。</p>
<p>类似地，物理内存被分割成<strong>物理页</strong>（Physical Page, PP），每个物理页也包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 个字节，物理页也称为<strong>页帧</strong>（page frame）。</p>
<p>页是数据在磁盘和主存之间传送的基本单元。</p>
<p>一个虚拟页有三种状态：</p>
<ul>
<li><strong>未分配</strong>（unallocated）：VM 系统还未<strong>分配</strong>（创建）的页。它不与任何数据关联，不占用磁盘空间。</li>
<li><strong>缓存</strong>（cached）：<strong>已缓存在物理内存中</strong>的已分配页。</li>
<li><strong>未缓存</strong>（uncached）：<strong>未缓存在物理内存中</strong>的已分配页。</li>
</ul>
<p><img src="./note-part2_files/9-3-VM使用主存作为缓存.png" alt=""></p>
<h3 id="dram-缓存的组织结构">DRAM 缓存的组织结构 </h3>
<p>我们用 SRAM 缓存指 CPU 的 L1、L2 和 L3 缓存，用 DRAM 缓存指主存。</p>
<p>DRAM 比 SRAM 慢约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 倍，磁盘比 DRAM 慢约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100000</mn></mrow><annotation encoding="application/x-tex">100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span> 多倍，而且从磁盘的一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节又要慢约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100000</mn></mrow><annotation encoding="application/x-tex">100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span> 倍，因此，DRAM 缓存的组织结构完全是由巨大的不命中处罚驱动的。</p>
<p><strong>虚拟页往往很大</strong>，通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext><mo>∼</mo><mn>2</mn><mtext>MB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}\sim 2 \text{MB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord text"><span class="mord">MB</span></span></span></span></span>。</p>
<p>DRAM 是<strong>全相联</strong>的，即任何虚拟页都可以放置在任何物理页中。</p>
<p>操作系统对 DRAM 缓存使用<strong>更复杂精密的替换算法</strong>。</p>
<p>DRAM 缓存总是<strong>写回</strong>，而不是直写。</p>
<h3 id="页表">页表 </h3>
<p>VM 系统需要判定一个虚拟页是否已缓存、已缓存的虚拟页对应的物理页、未缓存的虚拟页对应的磁盘位置等，这些功能由操作系统、MMU 中的地址翻译硬件和<strong>常驻在物理内存</strong>中的<strong>页表</strong>（page table）提供。</p>
<p>页表是<strong>页表条目</strong>（Page Table Entry, <strong>PTE</strong>）的数组。</p>
<p>虚拟地址空间的每个页在页表的<strong>固定</strong>偏移处都有一个 PTE。PTE 由一个<strong>有效位</strong>（valid bit）和一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 位的<strong>地址字段</strong>组成。</p>
<p><strong>有效位</strong>指示对应的虚拟页<strong>是否已缓存</strong>。</p>
<ul>
<li>若有效位被设置，地址字段就指示<strong>对应的物理页的地址</strong></li>
<li>否则，
<ul>
<li>如果地址字段是<strong>空</strong>的，则说明虚拟页<strong>未分配</strong></li>
<li>如果地址字段是<strong>非空</strong>的，则虚拟页<strong>已分配</strong>，地址字段是<strong>虚拟页在磁盘上的位置</strong>。</li>
</ul>
</li>
</ul>
<p><img src="./note-part2_files/9-4-页表.png" alt=""></p>
<h3 id="页命中">页命中 </h3>
<p>CPU 试图读取 VP 2 中的字时，地址翻译硬件将虚拟页号 VPN 作为索引定位 PTE 2。</p>
<p>PTE 2 的有效位被设置，故 VP 2 已被缓存在 DRAM 中，这是一次<strong>页命中</strong>。地址翻译硬件使用 PTE 2 的地址字段（即物理页号 PPN）构造出这个字的物理地址。</p>
<h3 id="缺页">缺页 </h3>
<p>DRAM 缓存不命中称为<strong>缺页</strong>（page fault）。</p>
<p>CPU 试图读取 VP 3 中的字时，由于 VP 3 未缓存，会触发一个<strong>缺页异常</strong>。这调用内核的<strong>缺页异常处理程序</strong>，它选择<strong>牺牲</strong>一个页，此例中就是 VP 4。如果 VP 4 已经被修改了，那么内核会将它复制回磁盘（<strong>写回</strong>）。内核会修改 VP 4 的页表条目，将其有效位清零。</p>
<p>然后，内核从磁盘复制 VP 3 到内存中的 PP 3（即 VP 4 的原缓存位置），更新 PTE 3 并返回。缺页处理程序返回时，会<strong>重新执行引起缺页的指令</strong>，这一次会页命中。</p>
<p><img src="./note-part2_files/9-6-缺页.png" alt=""></p>
<p>虚拟内存在 20 世纪 60 年代早期发明，早于 SRAM 缓存（后者由于 CPU-内存之间差距的加大诞生），因此其术语和 SRAM 缓存的术语不同。</p>
<p>虚拟内存的说法中，<strong>块</strong>称作<strong>页</strong>，页在磁盘和内存之间传送的活动叫做<strong>交换</strong>（swapping）或<strong>页面调度</strong>（paging）。页从磁盘<strong>换入</strong>（swapped in / paged in）DRAM，从 DRAM <strong>换出</strong>（swapped out / paged out）磁盘。</p>
<p>一直到不命中发生时才换入页面的策略称为<strong>按需页面调度</strong>（demand paging），所有现代系统都采用这种策略。</p>
<h3 id="分配页面">分配页面 </h3>
<p><img src="./note-part2_files/9-8-分配页面.png" alt=""></p>
<p>此例中，操作系统分配 VP 5：在磁盘上创建空间，并更新 PTE 5，将其地址字段填充为 VP 5 在磁盘上的位置。</p>
<h3 id="又是局部性救了我们">又是局部性救了我们 </h3>
<p>局部性保证了程序在任意时刻都趋向于在一个较小的<strong>活动页面</strong>（active page）集合上工作，即程序的<strong>工作集</strong>（working set）或<strong>常驻集合</strong>（resident set），这使得虚拟内存系统的性能很好。</p>
<p>如果工作集大小超出了物理内存的大小，那么程序将会<strong>抖动</strong>（thrashing），严重降低性能。</p>
<p>可以用 Linux 的 <code>getrusage</code> 函数检测缺页的数量。</p>
<h2 id="虚拟内存作为内存管理的工具">虚拟内存作为内存管理的工具 </h2>
<p>虚拟地址空间通常比物理地址空间大，但在一些早期系统（DEC PDP-11/70），也可能比物理地址空间小。虚拟内存对这种系统也有用处。</p>
<p>操作系统为每个进程提供了独立的页表，每个进程都有自己<strong>独立</strong>的虚拟地址空间。</p>
<p><strong>多个虚拟页可以映射到同一个物理页</strong>，这称为<strong>共享</strong>（sharing）。</p>
<p>通过使用 VM 系统：</p>
<p><strong>链接</strong>被简化：每个进程拥有独立的地址空间，因此它们不用在意代码和数据实际存放在物理内存的何处，可以使用<strong>相同格式的内存映像</strong>。这使得链接过程被简化，允许链接器生成完全链接的可执行文件。</p>
<p><strong>加载</strong>被简化：加载时，Linux 加载器为代码和数据段<strong>分配虚拟页</strong>，并将它们标记成<strong>未缓存</strong>的，将页表条目的地址字段设置成<strong>磁盘上目标文件的位置</strong>。加载器不会把数据从磁盘复制到内存，VM 系统会自动完成这一过程。</p>
<p><strong>内存映射</strong>（memory mapping）：将一组连续的虚拟页映射到某个文件中的某个位置</p>
<p><strong>共享</strong>被简化：每个进程拥有私有的代码、数据、堆、栈，它们不和其他进程共享，会被操作系统映射到<strong>不交</strong>的物理页中。而对于内核代码、C 标准库代码等需要被各个进程共享的代码，操作系统通过<strong>将不同进程中的某些虚拟页映射到相同的物理页</strong>，从而使得多个进程可以共享这部分代码的一个副本。</p>
<p><strong>内存分配</strong>被简化：当一个运行在用户进程的程序要求额外的堆空间时（如调用 <code>malloc</code>），操作系统分配一些连续的虚拟页，并将它们映射到相同数目的物理页，这些<strong>物理页可以散落在物理内存的任意位置</strong>（不必连续）。</p>
<h2 id="虚拟内存作为内存保护的工具">虚拟内存作为内存保护的工具 </h2>
<p>对内存系统的访问必须被控制：用户进程不能修改它的只读代码段，不能读或写内核代码和数据结构，不能读或写其他进程的私有空间，不能写与其他进程共享的虚拟页（除非得到所有共享者显式的允许）</p>
<p>我们在 PTE 上添加一些额外的<strong>许可位</strong>，用于控制对虚拟页的访问：</p>
<ul>
<li>SUP 位：进程是否必须运行在<strong>内核模式</strong>下才能访问这个虚拟页</li>
<li>READ 位：进程是否可以读取这个虚拟页</li>
<li>WRITE 位：进程是否可以写这个虚拟页</li>
</ul>
<p><img src="./note-part2_files/9-10-内存保护.png" alt=""></p>
<p>如果指令违反了这些许可位规定的许可条件，CPU 就会触发一个<strong>一般保护故障</strong>，将控制转移到内核的<strong>一般保护异常处理程序</strong>，它会终止进程。Linux 将这种异常报告为<strong>段错误</strong>（segmentation fault）</p>
<h2 id="地址翻译">地址翻译 </h2>
<p>地址翻译是一个从虚拟地址空间（VAS）到物理地址空间（PAS）的映射：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="center" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>MAP</mtext><mo>:</mo><mtext>VAS</mtext><mo>→</mo><mtext>PAS</mtext><mo>∪</mo><mi mathvariant="normal">∅</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>MAP</mtext><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if&nbsp;data&nbsp;at&nbsp;virtual&nbsp;addr.&nbsp;</mtext><mstyle scriptlevel="0" displaystyle="false"><mi>A</mi></mstyle><mtext>&nbsp;are&nbsp;present&nbsp;at&nbsp;physical&nbsp;addr.&nbsp;</mtext><mstyle scriptlevel="0" displaystyle="false"><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∅</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if&nbsp;data&nbsp;at&nbsp;virtual&nbsp;addr.&nbsp;</mtext><mstyle scriptlevel="0" displaystyle="false"><mi>A</mi></mstyle><mtext>&nbsp;are&nbsp;not&nbsp;present&nbsp;in&nbsp;physical&nbsp;memory</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gather*}
    \text{MAP}: \text{VAS}\rightarrow\text{PAS}\cup\varnothing, \\
    \text{MAP}(A) = \begin{cases}
        A', &amp; \text{if data at virtual addr. $A$ are present at physical addr. $A'$} \\
        \varnothing, &amp; \text{if data at virtual addr. $A$ are not present in physical memory}
    \end{cases}
\end{gather*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-5.56em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord text"><span class="mord">MAP</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">VAS</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">PAS</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord amsrm">∅</span><span class="mpunct">,</span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord text"><span class="mord">MAP</span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord amsrm">∅</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if&nbsp;data&nbsp;at&nbsp;virtual&nbsp;addr.&nbsp;</span><span class="mord mathnormal">A</span><span class="mord">&nbsp;are&nbsp;present&nbsp;at&nbsp;physical&nbsp;addr.&nbsp;</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if&nbsp;data&nbsp;at&nbsp;virtual&nbsp;addr.&nbsp;</span><span class="mord mathnormal">A</span><span class="mord">&nbsp;are&nbsp;not&nbsp;present&nbsp;in&nbsp;physical&nbsp;memory</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>CPU 中的一个控制寄存器，<strong>页表基址寄存器</strong>（Page Table Base Register, <strong>PTBR</strong>），指向当前页表的起始位置。</p>
<p><img src="./note-part2_files/9-12-地址翻译.png" alt=""></p>
<p>地址翻译时，<strong>处理器先生成一个虚拟地址</strong>，并将其传送给 MMU。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 位的虚拟地址被划分为两个部分：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 位的<strong>虚拟页偏移量</strong>（Virtual Page Offset, <strong>VPO</strong>）：用于在虚拟页内定位字</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n-p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 位的<strong>虚拟页号</strong>（Virtual Page Number, <strong>VPN</strong>）：作为索引，在页表中定位 PTE</li>
</ul>
<p><strong>MMU 通过 VPN 定位目标 PTE 的地址</strong>，然后向高速缓存或主存请求此 PTE。得到 PTE 后，MMU 检查有效位：</p>
<p>如果有效位为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，这是一次<strong>页命中</strong>。MMU 就会从 PTE 中取出<strong>物理页号</strong>（Physical Page Number, <strong>PPN</strong>）。由于<strong>物理页偏移量</strong>（Physical Page Offset, <strong>PPO</strong>）等于 VPO，因此将 PPN 和 VPO 组合起来就得到了物理地址。</p>
<p>MMU 将物理地址传送给高速缓存或主存，高速缓存或主存向处理器返回对应的字，就完成了整个过程。</p>
<p><img src="./note-part2_files/9-13-页命中和缺页.png" alt=""></p>
<p>如果有效位为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，MMU 触发一个<strong>缺页异常</strong>，CPU 将控制传递给内核的缺页异常处理程序。</p>
<p>缺页处理程序确定出牺牲页（如果牺牲页已被修改，就将它<strong>写回</strong>磁盘），然后调入新的页，并更新内存中相应的 PTE。最后，缺页处理程序返回到引起缺页的指令，并重新执行它，这一次会页命中。</p>
<p><strong>页命中完全由硬件处理</strong>，<strong>而缺页则由硬件和内核协作处理</strong>。</p>
<h3 id="结合高速缓存和虚拟内存">结合高速缓存和虚拟内存 </h3>
<p><img src="./note-part2_files/9-14-VM和cache.png" alt=""></p>
<p>大部分（同时使用 VM 和 SRAM 高速缓存的）系统使用<strong>物理寻址</strong>来索引 SRAM 高速缓存，这使得多个进程同时在高速缓存中缓存块更容易，也使得共享来自相同虚拟页的块更容易。而且，这使得高速缓存不用烦恼内存保护的问题，这会在地址翻译的过程中处理。</p>
<p>注意，页表条目也可以被缓存在高速缓存中。</p>
<h3 id="利用-tlb-加速地址翻译">利用 TLB 加速地址翻译 </h3>
<p>每次 CPU 产生一个虚拟地址，MMU 就需要查阅一个 PTE，这是一个<strong>内存操作</strong>，如果缓存不命中的话会很慢。</p>
<p>MMU 中可能包括一个存储 PTE 的小缓存，称为<strong>翻译后备缓冲区</strong>（Translation Lookaside Buffer, <strong>TLB</strong>）。TLB 的<strong>相联度一般较高</strong>，因此出现抖动的可能性较小。</p>
<p>TLB 是<strong>虚拟寻址</strong>的，VPN 被分成 <strong>TLB 标记位</strong>和 <strong>TLB 索引位</strong>两部分。</p>
<p><img src="./note-part2_files/9-15-16-TLB.png" alt=""></p>
<h3 id="多级页表">多级页表 </h3>
<p>如果我们有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位的地址空间，页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span>，那么页表就需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}/2^{12}=2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 个 PTE，每个 PTE 需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 个字节，总共就需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>MB</mtext></mrow><annotation encoding="application/x-tex">4 \text{MB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">MB</span></span></span></span></span> 的内存空间，这太大了。</p>
<p>我们使用多级页表来压缩空间。以一个二级页表为例：</p>
<p>一级页表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个 PTE，每个 PTE 指向一个二级页表。二级页表包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 个 PTE，每个 PTE 对应一个虚拟页。使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 字节的 PTE 时，一级页表和每个二级页表的大小都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span>，恰好与一个页的大小相同。</p>
<p>一级页表的每个 PTE 对应虚拟地址空间中一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>MB</mtext></mrow><annotation encoding="application/x-tex">4 \text{MB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">MB</span></span></span></span></span> 的<strong>片</strong>（chunk）。如果片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 中<strong>所有</strong>的页都是<strong>未分配</strong>的，那么一级 PTE <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 为空。</p>
<p>多级页表从两个方面节约了内存：</p>
<ul>
<li>如果一级页表的某个 PTE 为空，那么<strong>相应的二级页表就不会存在</strong>。由于对典型的程序来说，虚拟地址空间的大部分都是未分配的，因此这是一种巨大的节约</li>
<li>只有一级页表和最经常使用的二级页表需要被缓存在主存中</li>
</ul>
<p><img src="./note-part2_files/9-17-多级页表.png" alt=""></p>
<p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 级页表，虚拟地址被划分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 VPN 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个 VPO。VPN <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 级页表的索引，而第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 级页表的每个 PTE 都指向第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 级页表的基址（第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 级页表除外）。和单级页表一样，PPO 和 VPO 是相同的。</p>
<h3 id="综合端到端的地址翻译">综合：端到端的地址翻译 </h3>
<p>假设：</p>
<ul>
<li>内存按字节寻址</li>
<li>内存访问针对单字节的字</li>
<li>虚拟地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">n=14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">14</span></span></span></span> 位长</li>
<li>物理地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">m=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span> 位长</li>
<li>页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">P=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 字节</li>
<li>TLB 四路组相联，总共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> 个条目</li>
<li>L1 d-cache 物理寻址、直接映射，行大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 字节，总共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> 组</li>
</ul>
<p>因为页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 字节，所以 VPO 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 位，VPN 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 位。</p>
<ul>
<li><strong>TLB</strong> 将 VPN 的高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 位作为标记位（TLBT），将 VPN 的低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 位作为索引位（TLBI）</li>
<li><strong>页表</strong>是单级的，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8=256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> 个 PTE。</li>
<li><strong>高速缓存</strong>将物理地址的低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 位作为块偏移（CO），中间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 位作为组索引（CI），高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 位作为标记位（CT）</li>
</ul>
<p><img src="./note-part2_files/9-20-端到端.png" alt=""></p>
<h2 id="案例研究intel-core-i7linux-内存系统">案例研究：Intel Core i7/Linux 内存系统 </h2>
<p>Intel Core i7 Haswell <strong>处理器封装</strong>（processor package）包括四个核心、一个所有核心共享的 L3 高速缓存、一个 DDR3 内存控制器。每个核心包含两级高速缓存和两级 TLB，以及一组基于 QuickPath 技术的点到点链路（允许核心与其他核心以及外部 I/O 桥直接通信）。</p>
<p>TLB 虚拟寻址、四路组相联。L1、L2、L3 高速缓存物理寻址，L1 和 L2 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 路组相联，L3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> 路组相联，块大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 字节。页大小可以在启动时配置成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>MB</mtext></mrow><annotation encoding="application/x-tex">4 \text{MB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">MB</span></span></span></span></span>，Linux 一般使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span>。</p>
<p>Haswell 架构允许完全的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 位虚拟和物理地址空间，但 Core i7 实现只支持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>48</mn></mrow><annotation encoding="application/x-tex">48</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">48</span></span></span></span> 位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn><mtext>TB</mtext></mrow><annotation encoding="application/x-tex">256 \text{TB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">256</span><span class="mord text"><span class="mord">TB</span></span></span></span></span>）虚拟地址空间和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>52</mn></mrow><annotation encoding="application/x-tex">52</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">52</span></span></span></span> 位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>PB</mtext></mrow><annotation encoding="application/x-tex">4 \text{PB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">PB</span></span></span></span></span>）物理地址空间。Core i7 还有一个兼容模式，支持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>GB</mtext></mrow><annotation encoding="application/x-tex">4 \text{GB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">GB</span></span></span></span></span>）虚拟和物理地址空间。</p>
<p><img src="./note-part2_files/9-21-i7内存系统.png" alt=""></p>
<h3 id="core-i7-地址翻译">Core i7 地址翻译 </h3>
<p>Core i7 Haswell 采用<strong>四级页表</strong>。每个进程有自己私有的页表层次结构。</p>
<p>当一个 Linux 进程运行时，与<strong>已分配页相关的页表</strong>驻留在内存中。</p>
<p>CR3 控制寄存器指向第一级页表 L1 的基址。CR3 的值是每个进程的上下文的一部分。</p>
<p><img src="./note-part2_files/9-22-i7地址翻译.png" alt=""></p>
<p>前三级页表中的 PTE 格式：</p>
<p><img src="./note-part2_files/9-23-PTE格式.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">(Present) 子页表是否已缓存到物理内存中</td>
</tr>
<tr>
<td style="text-align:center">R/W</td>
<td style="text-align:center">(Read-only or read/write) 对所有可访问页，只读或读写权限</td>
</tr>
<tr>
<td style="text-align:center">U/S</td>
<td style="text-align:center">(User or supervisor) 对所有可访问页，用户或超级用户（内核）模式权限</td>
</tr>
<tr>
<td style="text-align:center">WT</td>
<td style="text-align:center">(Write-through or write-back) 子页表采用直写还是写回策略</td>
</tr>
<tr>
<td style="text-align:center">CD</td>
<td style="text-align:center">(Cache disabled) 子页表是否可以被缓存</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">(Accessed) 引用位，由 MMU 在读或写时设置，由软件清除</td>
</tr>
<tr>
<td style="text-align:center">PS</td>
<td style="text-align:center">(Page size) 页大小，可以为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>MB</mtext></mrow><annotation encoding="application/x-tex">4 \text{MB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">MB</span></span></span></span></span>（只对第一级 PTE 定义）</td>
</tr>
<tr>
<td style="text-align:center">Base addr</td>
<td style="text-align:center">子页表的物理基址的高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> 位</td>
</tr>
<tr>
<td style="text-align:center">XD</td>
<td style="text-align:center">(eXecute disasbled) 对所有可访问页，是否允许取指令</td>
</tr>
</tbody>
</table>
<p>Linux 中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 总是为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，此时地址字段包含一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> 位 PPN，它指向下一级页表的基址。这要求物理页表必须 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span> 对齐</strong>。</p>
<p>第四级页表 PTE 的格式：</p>
<p><img src="./note-part2_files/9-24-PTE格式.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">(Present) 子页表是否已缓存到物理内存中</td>
</tr>
<tr>
<td style="text-align:center">R/W</td>
<td style="text-align:center">(Read-only or read/write) 对于子页，只读或读写权限</td>
</tr>
<tr>
<td style="text-align:center">U/S</td>
<td style="text-align:center">(User or supervisor) 对于子页，用户或超级用户（内核）模式权限</td>
</tr>
<tr>
<td style="text-align:center">WT</td>
<td style="text-align:center">(Write-through or write-back) 子页采用直写还是写回策略</td>
</tr>
<tr>
<td style="text-align:center">CD</td>
<td style="text-align:center">(Cache disabled) 子页是否可以被缓存</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">(Accessed) 引用位（reference bit）。由 MMU 在读和写时设置，由软件清除</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">(Dirty bit) 修改位（dirty bit）。由 MMU 在读和写时设置，由软件清除</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">(Global) 全局位。如果设置，那么任务切换时，它不会从 TLB 中被驱逐</td>
</tr>
<tr>
<td style="text-align:center">Base addr</td>
<td style="text-align:center">子页的物理基址的高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> 位</td>
</tr>
<tr>
<td style="text-align:center">XD</td>
<td style="text-align:center">(eXecute disasbled) 对于子页，是否允许取指令</td>
</tr>
</tbody>
</table>
<p>XD 位是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 位系统引入的，这使得内核降低了缓冲区溢出攻击的风险。</p>
<p>每次访问一个页时，MMU 都会设置 A 位，它是内核页替换算法的一部分</p>
<p>每次写一个页时，MMU 都会设置 D 位，内核根据它决定是否需要将牺牲页写回磁盘</p>
<p>内核可以调用一条内核模式指令来清除引用位和修改位。</p>
<p>Core i7 MMU 将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>36</mn></mrow><annotation encoding="application/x-tex">36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">36</span></span></span></span> 位的 VPN 划分成四个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 位的片，作为到页表中 PTE 的索引：</p>
<p><img src="./note-part2_files/9-25-页表翻译.png" alt=""></p>
<blockquote>
<p>地址翻译包括两个步骤：</p>
<ul>
<li>MMU 将虚拟地址翻译成物理地址</li>
<li>将物理地址传送给 L1 高速缓存</li>
</ul>
<p>这两个步骤可以部分重叠：</p>
<p>页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext>KB</mtext></mrow><annotation encoding="application/x-tex">4 \text{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">KB</span></span></span></span></span> 时，虚拟地址有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span> 位的 VPO，并且它和其对应的 PPO 相同。八路组相联、物理寻址的 L1 高速缓存有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 个组，块大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 字节，因此物理地址的低 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 位是块偏移，中间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 位是组索引，高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40</span></span></span></span> 位是标记位。<br>
因此，当 CPU 发送 VPN 给 MMU 时，它会同时发送 VPO 给 L1 高速缓存，从而可以让 <strong>L1 高速缓存的组选择</strong>和 <strong>MMU 的页表查找</strong>同时进行。</p>
</blockquote>
<h3 id="linux-虚拟内存系统">Linux 虚拟内存系统 </h3>
<p>Linux 为每个进程维护一个独立的虚拟地址空间：</p>
<p><img src="./note-part2_files/9-26-linux进程的虚拟内存.png" alt=""></p>
<p>内核虚拟内存包括<strong>内核中的代码和数据结构</strong>。</p>
<p>内核虚拟内存的某些区域被映射到了<strong>所有进程共享的物理页</strong>，例如内核的代码和全局数据结构等</p>
<p>Linux 也将一组连续的虚拟页（大小等于系统中 DRAM 的总量）映射到一组连续的物理页，为内核提供了一个便利的访问物理内存任何位置的方法（例如访问页表或某些被映射到物理内存的 I/O 设备）。</p>
<p>内核虚拟内存的其他区域包含了<strong>每个进程都不相同的数据</strong>，例如页表、内核在进程上下文中使用的栈，以及记录虚拟地址空间当前组织的数据结构。</p>
<h4 id="linux-虚拟内存区域">Linux 虚拟内存区域 </h4>
<p>Linux 将虚拟内存划分成一些<strong>区域</strong>（area，又叫<strong>段</strong>，segment）。一个区域就是一个已分配的、连续的虚拟内存<strong>片</strong>，代码段、数据段、堆、共享库段、用户栈等都是区域。<strong>所有页都有一个所属的区域</strong>。</p>
<p>区域的概念允许虚拟内存有间隙，使得内核不用记录尚不存在的虚拟页，它们也不会占用任何内存或磁盘资源。</p>
<p>内核为每个进程维护一个 <code>task_struct</code>，其中的元素包含内核运行此进程需要的信息，包括 PID、指向用户栈的指针、可执行目标文件名、程序计数器等</p>
<p><code>task_struct</code> 中的 <code>mm</code> 元素指向一个 <code>mm_struct</code>，它描述虚拟内存的当前状态。其中</p>
<ul>
<li><code>pgd</code> 保存第一级页表（页全局目录）的基址。内核运行进程时，会<strong>将 <code>pgd</code> 存放在 CR3 控制寄存器中</strong></li>
<li><code>mmap</code> 指向一个 <code>vm_area_struct</code> 链表，每个 <code>vm_area_struct</code> 描述一个区域</li>
</ul>
<p><code>vm_area_struct</code> 包括：</p>
<ul>
<li><code>vm_start</code>：区域的起始地址</li>
<li><code>vm_end</code>：区域的结束地址</li>
<li><code>vm_prot</code>：区域内所有页的读写权限</li>
<li><code>vm_flags</code>：区域内的页是否可和其他进程共享，以及一些其他信息</li>
<li><code>vm_next</code>：指向下一个 <code>vm_area_struct</code> 的指针</li>
</ul>
<p><img src="./note-part2_files/9-27-linux虚拟内存.png" alt=""></p>
<h4 id="linux-缺页异常处理">Linux 缺页异常处理 </h4>
<p>如果 MMU 在翻译虚拟地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 时触发了缺页，那么控制会转移到内核的缺页处理程序。处理程序执行以下步骤：</p>
<ul>
<li>检查 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> <strong>是否合法</strong>：处理程序查找 <code>vm_area_struct</code> 链表，检查 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 是否包含在某对 <code>[vm_start, vm_end)</code> 中。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 不合法，处理程序触发一个<strong>段错误</strong>，终止进程</li>
</ul>
<p>由于进程可以通过 <code>mmap</code> 创建任意数量的新虚拟内存区域，所以 Linux 实现中在链表里构建了一棵树，用树来做查找。</p>
<ul>
<li>检查对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的<strong>内存访问是否合法</strong>：即检查进程是否有权限进行此访问（写只读页、用户模式进程读写内核虚拟内存等）。如果不合法，处理程序触发一个<strong>保护异常</strong>，终止进程</li>
<li>此时处理程序知道此次缺页是对合法地址的合法访问，它选择一个牺牲页（如果牺牲页被修改过，将它写回磁盘），换入新页并更新页表。然后处理程序返回到引起缺页的指令，并重新执行它，这一次会页命中</li>
</ul>
<p><img src="./note-part2_files/9-28-缺页.png" alt=""></p>
<h2 id="内存映射">内存映射 </h2>
<p>Linux 通过将一个虚拟内存区域与一个磁盘上的<strong>对象</strong>（object）关联起来，从而初始化这个虚拟内存区域。这个过程称为<strong>内存映射</strong>（memory mapping）。对象可以是：</p>
<ul>
<li>Linux 文件系统中的<strong>普通文件</strong>：例如一个可执行目标文件。文件的节（section）被分为页大小的片，每一片包含一个虚拟页的初始内容。由于按需进行页面调度的机制，这些页只有在被 CPU 第一次引用时才被实际读入物理内存。区域如果比文件节更大，那么余下的部分被<strong>零初始化</strong></li>
<li><strong>匿名文件</strong>：匿名文件由内核创建，包含的全是二进制零。CPU 第一次引用被映射到匿名文件的区域时，内核会在物理内存中牺牲一个页（若修改过，写回它），用二进制零覆写它并更新页表，并令这个页<strong>驻留内存</strong>。被映射到匿名文件区域的页也叫<strong>请求二进制零的页</strong>（demand-zero page）</li>
</ul>
<p>一旦一个虚拟页被初始化，它就在一个由内核维护的<strong>交换文件</strong>（swap file）之间换来换去。交换文件也叫<strong>交换空间</strong>（swap space）或<strong>交换区域</strong>（swap area）。任何时刻，交换空间都限制着当前进程能够分配的虚拟页的总数。</p>
<h3 id="再看共享对象">再看共享对象 </h3>
<p>如果虚拟内存系统可以集成到传统的文件系统中，那么就可以简单而高效地将程序和数据加载到内存里。</p>
<p>一个被映射到虚拟内存区域的对象要么是<strong>共享对象</strong>，要么是<strong>私有对象</strong>。</p>
<p>一个进程对它虚拟地址空间内某个<strong>共享对象</strong>的更改<strong>会反映到磁盘上的原始对象</strong>上，且<strong>对其他共享了此对象的进程也可见</strong>。而对于<strong>私有对象</strong>，进程对它的更改<strong>不会反映到磁盘上的原始对象</strong>上，且<strong>对其他进程也不可见</strong>。</p>
<p>映射到共享对象的虚拟内存区域称为<strong>共享区域</strong>，类似地，也有<strong>私有区域</strong>。</p>
<p><img src="./note-part2_files/9-29-共享对象.png" alt=""></p>
<p>如上图，即使共享对象被映射到了多个共享区域，物理内存中也只需要存放它的<strong>一个副本</strong>（注意<strong>物理页不一定连续</strong>）</p>
<p>私有对象采用<strong>写时复制</strong>（copy on write）技术。私有对象开始生命周期的方式和共享对象基本一样，但<strong>私有区域的 PTE 被标记为只读</strong>，并且区域结构体 <code>vm_area_struct</code> 被标记为<strong>私有的写时复制</strong>。</p>
<p>如果有进程试图写自己私有区域的某个页，那么这个写就会<strong>触发一个保护故障</strong>。故障处理程序会在物理内存中创建此程序的一个新副本，更新页表条目，然后恢复这个副本的可写权限。处理程序返回时，故障指令重新执行，这一次会成功写入。</p>
<p>写时复制充分节约了物理内存资源。</p>
<p><img src="./note-part2_files/9-30-写时复制.png" alt=""></p>
<h3 id="再看-fork-函数">再看 <code>fork</code> 函数 </h3>
<p>当前进程调用 <code>fork</code> 时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。</p>
<p>为了为新进程创建虚拟内存，它创建了当前进程的 <code>mm_struct</code>、<code>vm_area_struct</code> 和页表的副本。它<strong>将两个进程的每个页面都标记为只读</strong>，并<strong>将两个进程的每个 <code>vm_area_struct</code> 标记为写时复制</strong>。</p>
<p><code>fork</code> 返回时，两个进程就拥有了独立且私有的虚拟地址空间。</p>
<h3 id="再看-execve-函数">再看 <code>execve</code> 函数 </h3>
<p>假设当前进程调用了</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">"a.out"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>则：</p>
<ul>
<li>内核<strong>删除已存在的用户区域</strong>：删除当前虚拟地址空间用户部分中已存在的 <code>vm_area_struct</code></li>
<li><strong>映射私有区域</strong>：为新程序的代码（code）区域、数据区域、bss 区域和栈区域创建新的 <code>vm_area_struct</code>，它们是<strong>私有、写时复制的</strong>。
<ul>
<li>代码区域和数据区域被映射为 <code>a.out</code> 的 <code>.text</code> 段和 <code>.data</code> 段。</li>
<li>bss 区域是请求二进制零的，映射到匿名文件（匿名文件的大小也被包含在 <code>a.out</code> 中）</li>
<li>栈区域和堆区域也请求二进制零，初始长度为零。</li>
</ul>
</li>
<li><strong>映射共享区域</strong>：如果 <code>a.out</code> 与共享对象（目标）链接，例如 <code>libc.so</code>，那么这些对象会动态链接到程序，然后再映射到用户虚拟地址空间中的共享区域内。</li>
<li><strong>设置程序计数器（PC）</strong>：将 PC 设置为代码区域的入口点</li>
</ul>
<p><img src="./note-part2_files/9-31-加载器内存映射.png" alt=""></p>
<h3 id="使用-mmap-的用户级内存映射">使用 <code>mmap</code> 的用户级内存映射 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>

<span class="token comment">// 创建新的虚拟内存区域，并将 fd 所指定对象 offset 偏移处起 length 字节长度的连续的片映射到此区域</span>
<span class="token comment">// 返回：若成功，返回指向映射区域的指针；若出错，返回 MAP_FAILED（-1）</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> prot<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> flags<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><img src="./note-part2_files/9-32-mmap用法.png" alt=""></p>
<p><code>start</code> 参数向内核建议新虚拟内存区域的起始地址，内核可以忽略这个建议。</p>
<p><code>prot</code> 描述新区域的访问权限位，即相应 <code>vm_area_struct</code> 的 <code>vm_prot</code> 字段：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PROT_EXEC</mtext></mrow><annotation encoding="application/x-tex">\text{PROT\_EXEC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">PROT_EXEC</span></span></span></span></span>：区域内的页可执行</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PROT_READ</mtext></mrow><annotation encoding="application/x-tex">\text{PROT\_READ}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">PROT_READ</span></span></span></span></span>：区域内的页可读</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PROT_WRITE</mtext></mrow><annotation encoding="application/x-tex">\text{PROT\_WRITE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">PROT_WRITE</span></span></span></span></span>：区域内的页可写</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PROT_NONE</mtext></mrow><annotation encoding="application/x-tex">\text{PROT\_NONE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">PROT_NONE</span></span></span></span></span>：区域内的页不可访问</li>
</ul>
<p><code>flags</code> 描述被映射对象的类型：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>MAP_ANON</mtext></mrow><annotation encoding="application/x-tex">\text{MAP\_ANON}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">MAP_ANON</span></span></span></span></span>：匿名对象（相应的虚拟页请求二进制零）</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>MAP_PRIVATE</mtext></mrow><annotation encoding="application/x-tex">\text{MAP\_PRIVATE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">MAP_PRIVATE</span></span></span></span></span>：私有对象，写时复制</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>MAP_SHARED</mtext></mrow><annotation encoding="application/x-tex">\text{MAP\_SHARED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">MAP_SHARED</span></span></span></span></span>：共享对象</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>

<span class="token comment">// 删除 start 起 length 字节长度的区域</span>
<span class="token comment">// 返回：若成功，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>访问被 <code>munmap</code> 删除的区域会导致段错误。</p>
<h2 id="动态内存分配">动态内存分配 </h2>
<p>动态内存分配器维护进程的<strong>堆</strong>（heap）。我们假设堆是一个<strong>请求二进制零</strong>的区域，紧接着 bss 区域之后，向上（地址增加）生长。</p>
<p>动态内存分配器将堆视为一组不同大小<strong>块</strong>（block）的集合。每个块都是一个<strong>连续的虚拟内存片</strong>（chunk）。</p>
<p>一个块要么是<strong>已分配的</strong>，要么是<strong>空闲的</strong>。已分配的块供应用程序使用，它保持已分配状态，直到被<strong>释放</strong>。空闲块保持空闲，直到被应用程序显式地<strong>分配</strong>。</p>
<p>分配器有两种风格：</p>
<ul>
<li><strong>显式分配器</strong>（explicit allocator）：要求应用显式地释放已分配的块。例如 C 的 <code>malloc</code> 和 <code>free</code> 函数、C++ 的 <code>new</code> 和 <code>delete</code> 运算符</li>
<li><strong>隐式分配器</strong>（implicit allocator）：又叫<strong>垃圾收集器</strong>（garbage collector），由分配器检测已分配块何时不再被使用，自动释放它们。</li>
</ul>
<h3 id="malloc-和-free-函数"><code>malloc</code> 和 <code>free</code> 函数 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token comment">// 返回：若成功，返回指向大小至少为 size 字节的已分配块的指针；若出错，返回 NULL</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>返回指针，指向大小至少为 <code>size</code> 字节的块。这个块为可能包含在其中的任何数据对象对齐：</p>
<ul>
<li>在 32 位模式中，块的地址是 8 的倍数</li>
<li>在 64 位模式中，块的地址是 16 的倍数。</li>
</ul>
<blockquote>
<p>Intel 将 4 字节对象称为双字，在这里，我们假设字是 4 字节的</p>
</blockquote>
<p>如果 <code>malloc</code> 出错（例如要求的内存块大于可用的虚拟内存），它就会返回 <code>NULL</code>，并设置 <code>errno</code>。</p>
<p><code>malloc</code> 不会执行初始化，<code>calloc</code> 是一个基于 <code>malloc</code> 的瘦包装函数，会将分配的内存<strong>零初始化</strong>。</p>
<p>可以用 <code>realloc</code> 改变已分配块的大小：</p>
<p>动态内存分配器可以使用 <code>mmap</code> 和 <code>munmap</code> 显式地分配和释放堆内存。还可以使用 <code>sbrk</code> 函数</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// incr 可以为正数、负数或零</span>
<span class="token comment">// 返回：若成功，返回 brk 的旧值；若出错，返回 -1</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token class-name">intptr_t</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>sbrk</code> 通过改变 <code>brk</code> 指针来扩展和收缩堆。如果成功，它返回 <code>brk</code> 指针的旧值，否则返回 <code>−1</code>，并设置 <code>errno</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ENOMEM</mtext></mrow><annotation encoding="application/x-tex">\text{ENOMEM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">ENOMEM</span></span></span></span></span>。</p>
<p><code>free</code> 释放已分配的内存块。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>ptr</code> 必须指向一个从 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 获得的已分配块的基址，否则行为未定义。</p>
<p><img src="./note-part2_files/9-34-动态内存分配.png" alt=""></p>
<p>我们假设分配器返回的块是 8 字节双字边界对齐的。注意在 9-34b 中，<code>malloc</code> 会分配一个 6 字的块。</p>
<h3 id="分配器的要求和目标">分配器的要求和目标 </h3>
<ul>
<li><strong>处理任意请求序列</strong>：分配器必须能够处理任意的 <code>malloc</code> 和 <code>free</code> 请求序列，只要它们是合法的</li>
<li><strong>立即响应请求</strong>：即不允许分配器为了性能重新排列或缓冲请求</li>
<li><strong>只使用堆</strong>：为了可扩展性。任何非标量数据结构都必须被保存在堆上</li>
<li><strong>对齐块</strong>：块必须对齐，以便它们可以保存任何类型的对象</li>
<li><strong>不修改已分配的块</strong>：只能操作或改变空闲的块，压缩已分配块等操作是不允许的</li>
</ul>
<p>在以上限制下，分配器需要实现<strong>吞吐率最大化</strong>和<strong>内存使用率最大化</strong>。</p>
<ul>
<li><strong>吞吐率</strong>：单位时间内完成的请求（分配或释放）数量</li>
</ul>
<p>合理性能：分配请求的最糟糕情况时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（和空闲块的数量成线性关系），释放请求的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<ul>
<li><strong>内存使用率</strong>：可以用<strong>峰值利用率</strong>（peek utilization）衡量。</li>
</ul>
<p>例如，给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个分配或释放请求的序列</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>R</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>R</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_0, R_1, \cdots, R_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>一个分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 字节块的请求对应的<strong>有效载荷</strong>（payload）是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 字节。</p>
<p>请求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">R_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 完成后的<strong>聚集有效载荷</strong>（aggregate payload）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">P_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为当前已分配块的有效载荷之和。</p>
<p>记 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为堆的当前大小，它是单调非减的。那么前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个请求的峰值利用率为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mi>i</mi><mo>≤</mo><mi>k</mi></mrow></munder><msub><mi>P</mi><mi>i</mi></msub></mrow><msub><mi>H</mi><mi>k</mi></msub></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">U_k=\frac{\max_{i\leq k} P_i}{H_k}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2452em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p>
<p>分配器的目标是在整个序列中使峰值利用率最大化。</p>
<blockquote>
<p>也可以取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个请求过程中最大的堆大小，从而放宽堆大小单调非减的假设</p>
</blockquote>
<h3 id="碎片化">碎片化 </h3>
<p>碎片化（fragmentation）会造成堆利用率降低。碎片化分为<strong>内部碎片化</strong>（internal fragmentation）和<strong>外部碎片化</strong>（external fragmentation）。</p>
<p>内部碎片化：已分配块比它的有效载荷大。例如，分配器可能对已分配块强加一个最小的大小，或者为了对齐块而增加了块大小。</p>
<p>内部碎片化只取决于请求的模式和分配器的实现。</p>
<p>外部碎片化：空闲内存合计起来足够满足一个分配请求，但每个单独的空闲块都不够大。</p>
<p>外部碎片化难以量化且无法预测，分配器采用启发式策略，试图维护少量的大空闲块，而不是大量的小空闲块。</p>
<h3 id="实现问题">实现问题 </h3>
<p>最简单的分配器：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>由于 <code>malloc</code> 和 <code>free</code> 极其简单，吞吐率会极好。但分配器从不重复利用任何块，内存利用率会极差。</p>
<p>实际的分配器必须考虑以下问题：</p>
<ul>
<li><strong>空闲块的组织</strong></li>
<li><strong>放置</strong>：选择哪个空闲块来满足当前的分配请求</li>
<li><strong>分割</strong>：将新分配的块放置到空闲块后，如何处理空闲块剩余的部分</li>
<li><strong>合并</strong>：如何处理刚刚被释放的块</li>
</ul>
<h3 id="隐式空闲链表">隐式空闲链表 </h3>
<p>大多数分配器将块的元数据嵌入块本身：</p>
<p><img src="./note-part2_files/9-35-简单堆块的格式.png" alt=""></p>
<p>一个块由一个单字大小的<strong>头部</strong>、有效载荷，以及一些可能的额外<strong>填充</strong>组成。</p>
<p>头部编码了块（包含头部和填充）的<strong>总大小</strong>以及块的<strong>状态</strong>（已分配或空闲）</p>
<p>如果我们要求块<strong>双字对齐</strong>，那么块大小就总是 8 的倍数，其二进制表示的最低 3 位总是 0。因此，我们只需要 29 个高位来编码块大小。剩余的 3 位用于编码块的状态。</p>
<p><img src="./note-part2_files/9-36-隐式空闲链表.png" alt=""></p>
<p>堆被组织成连续的已分配块和空闲块的序列。这种结构称为<strong>隐式空闲链表</strong>（implicit free list），因为空闲块通过头部的大小字段隐式地连接在一起。</p>
<p>我们需要一个特殊标记的结束块，此例中即一个设置了分配位而大小为零的终止头部（terminating header）</p>
<p>隐式空闲链表很简单，但任何操作的开销，例如放置分配的块，都需要搜索空闲链表，其<strong>时间复杂度和块的总数成线性关系</strong>。而且，对齐要求导致<strong>块大小至少是双字</strong>，这会导致<strong>内部碎片化</strong>。</p>
<h3 id="放置已分配的块">放置已分配的块 </h3>
<p>处理一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 字节块的分配请求时，分配器搜索空闲链表，查找合适的空闲块放置新分配的块。搜索的方式取决于分配器的<strong>放置策略</strong>。</p>
<p><strong>首次适配</strong>（first fit）从头开始搜索空闲链表，选择首个合适的空闲块。</p>
<p>首次分配趋向于将大的空闲块保留在链表尾部，但容易在链表前部留下小空闲块的碎片，从而增加了对较大快的搜索时间。</p>
<p><strong>下一次适配</strong>（next fit）从<strong>上次搜索结束的地方</strong>开始搜索，选择首个合适的空闲块。</p>
<p>下一次适配由 Donald Knuth 提出，作为首次适配的改进。它基于一个简单的想法：上一次发现的空闲块很可能也能被下一次使用。下一次适配的性能明显地更快，但是内存利用率要低得多。</p>
<p><strong>最佳适配</strong>（best fit）搜索<strong>整个</strong>空闲链表，选择<strong>最小</strong>的满足要求的空闲块。</p>
<p>最佳适配的内存利用率好，但性能很差，因为它必须搜索整个空闲链表。</p>
<h3 id="分割空闲块">分割空闲块 </h3>
<p>分配器找到匹配的空闲块后，需要决定应分配空闲块中多少空间。</p>
<p>如果用整个空闲块，那么会造成<strong>内部碎片化</strong>。如果放置策略能产生好的匹配，额外的内部碎片是可以接受的。</p>
<p>如果匹配不太好，分配器通常会将空闲块分割成两部分，一部分作为分配块，另一部分变成新的空闲块。</p>
<h3 id="获取额外的堆内存">获取额外的堆内存 </h3>
<p>如果分配器不能为请求找到合适的空闲块，那么它可以通过合并物理上相邻的空闲块来创建一些更大的空闲块。如果这样还不行，分配器就用 <code>sbrk</code> 向内核请求额外的堆内存，将其转化为一个新的空闲块，插入空闲链表。</p>
<h3 id="合并空闲块">合并空闲块 </h3>
<p>当分配器释放已分配块时，可能有其他空闲块与之相邻。这种相邻的空闲块可能引起<strong>假碎片化</strong>（fault fragmentation）。</p>
<p>分配器需要合并（coalescing）相邻的空闲块。</p>
<p><strong>立即合并</strong>（immediate coalescing）：每次释放块时执行合并</p>
<p><strong>推迟合并</strong>（deferred coalescing）：无法满足某个分配请求时，扫描整个堆，合并所有相邻的空闲块</p>
<p>立即合并可能产生一种抖动：块反复的合并和分割。</p>
<p>快速的分配器通常会选择某种形式的推迟合并。</p>
<h3 id="带边界标记的合并">带边界标记的合并 </h3>
<p>由于我们的目前隐式链表是单向的，所以合并前驱空闲块时会有困难。</p>
<p>Knuth 提出了<strong>边界标记</strong>（boundary tag）的方法：在每个块的尾部添加一个<strong>脚部</strong>（footer）作为头部的一个副本。</p>
<p><img src="./note-part2_files/9-39-带边界标记的块.png" alt=""></p>
<p>释放当前块时，根据前驱块和后继块的状态可以有四种情况：</p>
<ol>
<li>前驱块已分配，后继块已分配</li>
<li>前驱块已分配，后继块空闲</li>
<li>前驱块空闲，后继块已分配</li>
<li>前驱块空闲，后继块空闲</li>
</ol>
<p><img src="./note-part2_files/9-40-合并.png" alt=""></p>
<p>每种情况下，合并的时间复杂度都是常数级的。</p>
<p>边界标记简单而优雅，但对于频繁请求小块的应用，为每个块同时维护两个字大小的头部和脚部有些浪费。</p>
<p>注意到，<strong>只有当前驱块空闲时</strong>，我们才会用到它的脚部。如果<strong>将前驱块的已分配 / 空闲位存放在当前块中多余的空位</strong>，那么已分配的块就不需要脚部了（不过空闲块仍然需要脚部）。</p>
<h3 id="综合实现一个简单的分配器">综合：实现一个简单的分配器 </h3>
<p>最大的块大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mtext>GB</mtext></mrow><annotation encoding="application/x-tex">2^{32}=4 \text{GB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord text"><span class="mord">GB</span></span></span></span></span>，代码是 64 位 clean 的，即可以不加修改地运行在 32 位（<code>gcc -m32</code>）和 64 位（<code>gcc -m64</code>）的进程上。</p>
<h4 id="通用分配器设计">通用分配器设计 </h4>
<p><code>memlib.c</code> 包提供了一个内存系统模型：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/* memlib.c */</span>

<span class="token comment">/* Private global variables */</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> mem_heap<span class="token punctuation">;</span>    <span class="token comment">/* Points to first byte of heap */</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> mem_brk<span class="token punctuation">;</span>    <span class="token comment">/* Points to last byte of heap plus 1 */</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> mem_max_addr<span class="token punctuation">;</span>  <span class="token comment">/* Max legal heap addr plus 1 */</span>

<span class="token comment">/*
 * mem_init - Initialize the memory system model
 */</span>
<span class="token keyword keyword-void">void</span> <span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mem_heap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">Malloc</span><span class="token punctuation">(</span>MAX_HEAP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem_brk <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span>mem_heap<span class="token punctuation">;</span>
    mem_max_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>mem_heap <span class="token operator">+</span> MAX_HEAP<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * mem_sbrk - Simple model of the sbrk function. Extends the heap
 *    by incr bytes and returns the start address of the new area. In
 *    this model, the heap cannot be shrunk.
 */</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token class-name">intptr_t</span> incr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> old_brk <span class="token operator">=</span> mem_brk<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>incr <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem_brk <span class="token operator">+</span> incr<span class="token punctuation">)</span> <span class="token operator">&gt;</span> mem_max_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        errno <span class="token operator">=</span> ENOMEM<span class="token punctuation">;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"ERROR: mem_sbrk failed. Ran out of memory...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mem_brk <span class="token operator">+=</span> incr<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>old_brk<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>分配器包含在 <code>mm.c</code> 中，它提供三个接口：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-extern">extern</span> <span class="token keyword keyword-int">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-extern">extern</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-extern">extern</span> <span class="token keyword keyword-void">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>mm_init</code> 函数初始化分配器，若成功返回 0，否则返回 -1。<code>mm_malloc</code> 和 <code>mm_free</code> 的语义和 <code>malloc</code> 和 <code>free</code> 相同。</p>
<p>最小的块大小是 16 字节，空闲链表组织为一个隐式空闲链表。</p>
<p><img src="./note-part2_files/9-42-隐式空闲链表格式.png" alt=""></p>
<p>第一个字是一个双字边界对齐的填充字。后面是一个<strong>序言块</strong>（prologue block），它是一个已分配块，大小为 8 字节，只包含一个头部和一个脚部。它在初始化时被创建，永不释放。</p>
<p>序言块后是由 <code>malloc</code> 或者 <code>free</code> 调用创建的普通块。</p>
<p>堆总是以一个<strong>结尾块</strong>（epilogue block）结束，它是一个已分配块，大小为零，只包含一个头部。</p>
<p>序言块和结尾块是一种消除合并边界条件的技巧。分配器使用一个 <code>static</code> 的全局变量 <code>heap_listp</code>，指向序言块。（也可以让它指向下一个块）</p>
<h4 id="操作空闲链表的基本常数和宏">操作空闲链表的基本常数和宏 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/* Basic constants and macros */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">WSIZE</span>    <span class="token expression"><span class="token number">4</span>    </span><span class="token comment">/* Word and header/footer size (bytes) */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DSIZE</span>    <span class="token expression"><span class="token number">8</span>    </span><span class="token comment">/* Double word size (bytes) */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHUNKSIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">)</span>  </span><span class="token comment">/* Extend heap by this amount (bytes) */</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/* Pack a size and allocated bit into a word */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PACK</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">,</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/* Read and write a word at address p */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PUT</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/* Read the size and allocated fields from address p */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_SIZE</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_ALLOC</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/* Given block ptr bp, compute address of its header and footer */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HDRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FTRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span></span></span>

<span class="token comment">/* Given block ptr bp, compute address of next and previous blocks */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre><p>注意块指针指向块有效载荷的基址，而不是块的基址。</p>
<h4 id="创建初始空闲链表">创建初始空闲链表 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Create the initial empty heap */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_listp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Alignment padding */</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Prologue header */</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Prologue footer */</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Epilogue header */</span>
    heap_listp <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> bp<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>

    <span class="token comment">/* Allocate an even number of words to maintain alignment */</span>
    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment">/* Initialize free block header/footer and the epilogue header */</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Free block header */</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Free block footer */</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* New epilogue header */</span>

    <span class="token comment">/* Coalesce if the previous block was free */</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><code>extend_heap</code> 会在两种情况下调用：</p>
<ul>
<li>堆初始化</li>
<li><code>mm_malloc</code> 无法找到合适的匹配块</li>
</ul>
<h4 id="释放和合并块">释放和合并块 </h4>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* Case 1 */</span>
        <span class="token keyword keyword-return">return</span> bp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* Case 2 */</span>
        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* Case 3 */</span>
        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>    <span class="token comment">/* Case 4 */</span>
        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> bp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="分配块">分配块 </h4>
<p>最小块大小是 16 字节：8 字节用于对齐，8 字节用于头部和脚部。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> asize<span class="token punctuation">;</span>    <span class="token comment">/* Adjusted block size */</span>
    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token comment">/* Amount to extend heap if no fit */</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> bp<span class="token punctuation">;</span>

    <span class="token comment">/* Ignore spurious requests */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment">/* Adjust block size to include overhead and alignment reqs. */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> DSIZE<span class="token punctuation">)</span>
        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span>
        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Search the free list for a fit */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> bp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* No fit found. Get more memory and place the block */</span>
    extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> bp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* First-fit search */</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> bp<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>bp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>asize <span class="token operator">&lt;=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-return">return</span> bp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">/* No fit */</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> csize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>csize <span class="token operator">-</span> asize<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>csize <span class="token operator">-</span> asize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>csize <span class="token operator">-</span> asize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>csize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>csize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="显式空闲链表">显式空闲链表 </h3>
<p>我们不需要空闲块有效载荷中的数据，因此可以利用它存储一些额外的信息</p>
<p><img src="./note-part2_files/9-48-双向链表堆块.png" alt=""></p>
<p>在每个空闲块中包含一个 <code>pred</code> 指针和一个 <code>succ</code> 指针，指向<strong>前驱空闲块</strong>和<strong>后继空闲块</strong>，构造一个<strong>显式的双向空闲链表</strong></p>
<p>这使得 first fit 的分配时间从块总数的线性时间降低到了空闲块的线性时间。</p>
<p>取决于空闲链表中块的<strong>排序策略</strong>，释放块的时间可能是线性的，也可能是常数的：</p>
<p><strong>后进先出</strong>（LIFO）：新释放的块放置在链表的开始处。搜索时，分配器先检查到的是最近使用过的块，释放块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。</p>
<p><strong>地址顺序</strong>（address-ordered）：空闲块按地址顺序排列。释放块需要线性时间，但内存利用率更高，接近 best fit。</p>
<p>显式链表要求了更大的最小块大小，提高了内部碎片化的程度。</p>
<h3 id="分离的空闲链表">分离的空闲链表 </h3>
<p><strong>分离存储</strong>（segregated storage）：维护多个空闲链表，每个链表中的块有大致相等的大小。</p>
<p>一般将所有可能的块大小分成一些等价类，称为<strong>大小类</strong>（size class）。以下是一个例子，其中小的块单独成类，大的块按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的幂分类：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>2</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>3</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>1023</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>1024</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>1025</mn><mo>∼</mo><mn>2048</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>2049</mn><mo>∼</mo><mn>4096</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mn>4097</mn><mo>∼</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1\}, \{2\}, \{3\}, \cdots, \{1023\}, \{1024\}, \{1025\sim2048\}, \{2049\sim4096\}, \{4097\sim\infty\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">2</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">1023</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">1024</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">1025</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2048</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">2049</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4096</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord">4097</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∞</span><span class="mclose">}</span></span></span></span></span></p>
<p>每个大小类都有一个对应的空闲链表。</p>
<h4 id="简单分离存储">简单分离存储 </h4>
<p>每个大小类的空闲链表的块大小相等，都等于大小类中最大元素的大小。若大小类为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>17</mn><mo>∼</mo><mn>32</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{17\sim32\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">17</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">32</span><span class="mclose">}</span></span></span></span>，则相应链表的块大小都是 32 字节。</p>
<p>对于分配请求，我们检查相应的空闲链表：</p>
<ul>
<li>若链表非空：分配其第一个块的<strong>全部</strong></li>
<li>若链表为空：向内核请求一个固定大小的额外的片，将其分成大小相等的块，组成新的空闲链表</li>
</ul>
<p>对于释放请求，分配器简单地将这个块插入到相应空闲链表的头部。</p>
<p>简单分离存储<strong>不分割、不合并</strong>。</p>
<p>优点：</p>
<ul>
<li>分配和释放的时间很短</li>
<li><strong>块不需要头部</strong>：因为每个片都只有大小相同的块，所以已分配块的大小可以直接从地址推断。因为不用合并，所以块也不需要已分配 / 空闲的标记。</li>
<li><strong>块也不需要尾部</strong>，因为不用合并</li>
<li>唯一需要的字段是空闲块携带的 <code>succ</code> 指针，因此最小块大小就是一个字</li>
</ul>
<p>缺点：不分割会造成<strong>内部碎片化</strong>，不合并又会造成<strong>外部碎片化</strong></p>
<h4 id="分离适配">分离适配 </h4>
<p>分配器维护一个空闲链表的数组。每个空闲链表和一个大小类关联，包含潜在的大小不同的块，其大小是大小类的成员。</p>
<p>对于分配请求，我们对适当的大小类对应的空闲链表 first fit 搜索：</p>
<ul>
<li>若找到，就（可选地）分割它，将剩余部分插入到适当的空闲链表中</li>
<li>若找不到，搜索下一个大小类对应的空闲链表</li>
<li>若查找完所有的空闲链表仍找不到，向内核请求额外的片，从其中分配出一个块，将剩余部分放置在适当大小类对应的空闲链表中</li>
</ul>
<p>对于释放请求，我们执行合并，并将结果放置在适当的空闲链表中</p>
<p>GNU <code>malloc</code> 采用的就是分离适配方法。对分离空闲链表的简单的 first fit 搜索的内存利用率近似于对整个堆的 best fit 搜索。</p>
<h4 id="伙伴系统">伙伴系统 </h4>
<p>伙伴系统（buddy system）是分离适配的特例，其中每个大小类都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的幂。</p>
<p>假设一个堆的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个字，我们为每个块大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 维护一个分离空闲链表，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0\leq k\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p>
<p>初始时只有一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> 个字的空闲块。</p>
<p>对于一个分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 大小的块的请求，我们找到第一个可用的块，其大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，那么分配完成</li>
<li>否则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j&gt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，我们递归地二分它，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，每次二分后剩下的半块（称为<strong>伙伴</strong>）放置在相应的空闲链表中</li>
</ul>
<p>对于一个释放 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 大小的块的请求，我们继续合并空闲的伙伴，直到遇到一个已分配的伙伴。</p>
<p>对于伙伴系统，如果给定地址和块大小，那么其伙伴的地址很容易计算。例如，若一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 字节的块的地址为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mi>x</mi><mi>x</mi><mo>⋯</mo><mi>x</mi><mn>00000</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">xxx\cdots x00000,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">xxx</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord">00000</span><span class="mpunct">,</span></span></span></span></span></p>
<p>那么它的伙伴的地址就是</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mi>x</mi><mi>x</mi><mo>⋯</mo><mi>x</mi><mn>10000.</mn></mrow><annotation encoding="application/x-tex">xxx\cdots x10000.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">xxx</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord">10000.</span></span></span></span></span></p>
<p>伙伴系统可以快速搜索并快速合并。然而它要求块大小全都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的幂，可能导致显著的内部碎片化。它不适合通用目的的工作负载，但对某些特定的应用场景效率很高。</p>
<h2 id="垃圾收集">垃圾收集 </h2>
<p><strong>垃圾收集器</strong>（garbage collector）是一种动态内存分配器，它定期识别并回收不再使用的已分配块（垃圾）。</p>
<h3 id="垃圾收集器的基本知识">垃圾收集器的基本知识 </h3>
<p>垃圾收集器将内存视为一张<strong>有向可达图</strong>（reachability graph）。</p>
<p>图的结点被分成一组根结点和一组堆结点，<strong>每个堆结点对应一个已分配块</strong>。有向边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>→</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\rightarrow q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 意味着块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 中的某个位置指向块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 中的某个位置。</p>
<p>根结点对应于<strong>不在堆中，但指向堆中的块的指针</strong>。这些指针可以是位于寄存器、栈中的局部变量，或虚拟内存数据区域中的全局变量。</p>
<p><img src="./note-part2_files/9-49-有向可达图.png" alt=""></p>
<p>如果可以从根结点到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 就是可达的。不可达结点就是垃圾。</p>
<p>ML 和 Java 的垃圾收集器对指针的创建的使用有严格的控制，能够精确地维护可达图，可以回收所有垃圾。但 C/C++ 的收集器通常无法精确地维护可达图，它们被称为<strong>保守的垃圾收集器</strong>（conservative garbage collector）。它们<strong>将每个可达块都正确地识别为可达</strong>，<strong>但可能会将一些不可达块也识别为可达的</strong>。</p>
<p>保守的垃圾收集器可以作为 <code>malloc</code> 和 <code>free</code> 之间的一个<strong>中间模块</strong>。</p>
<p>当 <code>malloc</code> 处理分配请求时，如果它找不到合适的空闲块，那么它就调用垃圾收集器，回收一些垃圾，然后再次搜索空闲块。如果仍然失败，那么它就向内核请求额外的堆内存。</p>
<h3 id="marksweep-垃圾收集器">Mark&amp;Sweep 垃圾收集器 </h3>
<p>Mark&amp;Sweep 垃圾收集器由<strong>标记</strong>阶段和<strong>清除</strong>阶段组成。</p>
<p>标记阶段标记出根结点的所有可达且已分配的后继。清除阶段释放所有未被标记的已分配块。</p>
<p>通常用块头部中空闲低位中的一位来标记块。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>

<span class="token comment">// If p points to some word in an allocated block, returns the base address of that block. Otherwise, returns NULL</span>
ptr <span class="token function">isPtr</span><span class="token punctuation">(</span>ptr p<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Returns 1 if block b is marked</span>
<span class="token keyword keyword-int">int</span> <span class="token function">blockMarked</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Returns 1 if block b is allocated</span>
<span class="token keyword keyword-int">int</span> <span class="token function">blockAllocated</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Marks block b</span>
<span class="token keyword keyword-void">void</span> <span class="token function">markBlock</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Returns the length in words (excluding the header) of block b</span>
<span class="token keyword keyword-int">int</span> <span class="token function">length</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Unmarks block b</span>
<span class="token keyword keyword-void">void</span> <span class="token function">unmarkBlock</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Returns the address of the next block of block b</span>
ptr <span class="token function">nextBlock</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// If p points to a allocated &amp; unmarked block, marks it and recursively marks all blocks that the block points to</span>
<span class="token keyword keyword-void">void</span> <span class="token function">mark</span><span class="token punctuation">(</span>ptr p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">isPtr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">blockMarked</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token function">markBlock</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    len <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">mark</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">sweep</span><span class="token punctuation">(</span>ptr b<span class="token punctuation">,</span> ptr end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">blockMarked</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">unmarkBlock</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">blockAllocated</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token function">nextBlock</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>标记阶段对<strong>每个根结点</strong>调用 <code>mark</code>。如果 <code>p</code> 没有指向已分配且未标记的块，立即返回；否则，标记块 <code>b</code>，并递归地检查块 <code>b</code> 中的每个字。</p>
<p>最后，任何未标记的已分配块都被认为是垃圾。</p>
<p>清除阶段调用 <code>sweep</code>，清除堆中所有的垃圾块。</p>
<p><img src="./note-part2_files/9-52-mark&amp;sweep.png" alt=""></p>
<p>上图中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">1\sim 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 初始都为已分配块。第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 个块是不可达的，因此在清除阶段被回收到空闲链表。</p>
<h3 id="c-程序的保守-marksweep">C 程序的保守 Mark&amp;Sweep </h3>
<ul>
<li>C 不会用类型信息标记内存位置，因此 <code>isPtr</code> 难以明确地判断其参数 <code>p</code> 是不是指针。即使 <code>p</code> 是指针，也无法判断它指向的是不是<strong>已分配块的有效载荷</strong></li>
</ul>
<p>我们将已分配块的集合维护成一颗<strong>平衡二叉树</strong>，其中左子树的块都被存放在小地址处，右子树的块都被存放在大地址处。</p>
<p>这要求块头部中附加 <code>left</code> 字段和 <code>right</code> 字段，通过在平衡二叉树中二分查找 <code>p</code> 确定它是否指向已分配块的有效载荷。</p>
<p>像 <code>int</code> 和 <code>float</code> 的变量可以伪装成指针，这对收集器而言是无法区分的。因此 C/C++ 垃圾收集器只能是保守的。</p>
<h2 id="c-程序中常见的与内存有关的错误">C 程序中常见的与内存有关的错误 </h2>
<h3 id="解引用坏指针">解引用坏指针 </h3>
<p>进程的虚拟地址空间中有很多较大的<strong>洞</strong>，它们没有映射到任何有意义的数据。解引用这些地址会导致<strong>段错误</strong>（segmentation fault）。</p>
<p>另一方面，试图写虚拟内存中的只读区域会导致<strong>保护异常</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// scanf bug 是常见的解引用坏指针错误</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// ok</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 可能 segfault，可能 protection fault，最糟糕的情况会静默地 corrupt 内存</span>
</code></pre><h3 id="读未初始化的内存">读未初始化的内存 </h3>
<p><code>malloc</code> 分配的堆内存是未初始化的。</p>
<h3 id="允许栈缓冲区溢出">允许栈缓冲区溢出 </h3>
<p>不要使用 <code>gets</code> 函数，换用 <code>fgets</code>。</p>
<h3 id="在类型大小上犯错">在类型大小上犯错 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token operator">*</span> A <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">Malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 应该是 n * sizeof(int*)</span>
</code></pre><p>这导致 <code>malloc</code> 分配的内存大小不够，我们可能写到超出数组 <code>A</code> 结尾的地方。如果写操作因此<strong>覆写了这个已分配块的脚部</strong>，那么在<strong>释放</strong>这个块时（这通常已经在很远的地方了），分配器就会出错。</p>
<p>这是典型的“action at distance”的示例，很难调试。</p>
<h3 id="造成错位错误">造成错位错误 </h3>
<p>错位（off-by-one）错误是另一种写越界的错误：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token operator">*</span> A <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">Malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token comment">// 应该是 i &lt; n</span>
    A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">Malloc</span><span class="token punctuation">(</span>m <span class="token operator">*</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="错误地解引用指针">错误地解引用指针 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token operator">*</span>size<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token comment">// 应该是 (*size)--</span>
</code></pre><p>一元运算符 <code>--</code> 和 <code>*</code> 的优先级相同，它们<strong>从右向左</strong>结合，造成了错误。</p>
<h3 id="错误地增减指针">错误地增减指针 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token comment">/* some address */</span><span class="token punctuation">;</span>
<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> target<span class="token punctuation">)</span>
    p <span class="token operator">+=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 应该是 p++</span>
</code></pre><h3 id="悬垂指针">悬垂指针 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span> <span class="token function">dangling</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>函数返回一个悬垂指针，它指向栈上一个已经消亡了的局部变量，写它的解引用可能污染栈上的其他数据。</p>
<h3 id="引用已经被释放的内存">引用已经被释放的内存 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span><span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token operator">*</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><p>如果 <code>x</code> 存储的地址后来又成为了已分配块的一部分，那么写操作就会污染这个块。</p>
<h3 id="内存泄漏">内存泄漏 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">Malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><code>leak</code> 返回后，<code>p</code> 所分配的内存就再也无法访问到了。如果 <code>leak</code> 被经常调用，堆中就会充满这样的垃圾。对于长时间运行的程序影响很大。</p>
<h1 id="系统级-io">系统级 I/O </h1>
<p>I/O 是在主存和外部设备（磁盘驱动、终端、网络）之间复制数据的过程。</p>
<h2 id="unix-io">Unix I/O </h2>
<p>一个 Linux <strong>文件</strong>是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 字节的序列。</p>
<p>Linux 中，一切 I/O 设备都被视为文件，而所有的 I/O 操作都被视为对文件的读和写。这种优雅的映射使得 Linux 内核可以提供一个简单且底层的应用程序接口，称为 Unix I/O。</p>
<p><strong>打开文件</strong>：应用程序通过要求内核打开相应的文件来宣告它想要访问某个 I/O 设备。内核返回一个用于标识对应文件的<strong>文件描述符</strong>（file descriptor），它是<strong>非负整数</strong>。内核维护有关此已打开文件的所有信息，应用程序只需要保存文件描述符。</p>
<p>Linux shell 创建的每个进程，在开始时都有三个已打开的文件：</p>
<ul>
<li>标准输入（standard input）：文件描述符为 0</li>
<li>标准输出（standard output）：文件描述符为 1</li>
<li>标准错误（standard error）：文件描述符为 2</li>
</ul>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 以下常量可以代替显式的描述符值</span>
STDIN_FILENO    <span class="token comment">// standard input</span>
STDOUT_FILENO    <span class="token comment">// standard output</span>
STDERR_FILENO    <span class="token comment">// standard error</span>
</code></pre><p><strong>改变当前的文件位置</strong>：对于每个已打开文件，内核维护一个<strong>文件位置</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，初始值为 0，表示<strong>从文件开头起的字节偏移量</strong>。应用程序可以通过 <code>seek</code> 操作显式地设置文件的当前位置</p>
<p><strong>读写文件</strong>：</p>
<ul>
<li>读就是从当前文件位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 起复制 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 个字节到主存，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 增加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。若文件大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 字节，则当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k\geq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 时读操作会<strong>触发 EOF 条件</strong>（文件末尾并没有明确的 EOF 字符）</li>
<li>类似地，写就是从主存复制 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 个字节到当前文件位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，然后更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></li>
</ul>
<p><strong>关闭文件</strong>：应用程序通过要求内核关闭文件来指明它已经完成了对此文件的访问。内核释放文件打开时创建的数据结构，将描述符恢复到可用的描述符池。无论进程因何终止，内核都会关闭所有打开的文件，并释放它们的内存</p>
<h2 id="文件">文件 </h2>
<p>Linux 文件有一个<strong>类型</strong>（type），包括：</p>
<ul>
<li><strong>普通文件</strong>（regular file）：包含任意数据，在 <code>ls</code> 里用 <code>-</code> 指示。应用程序经常需要区分<strong>文本文件</strong>（只含有 ASCII 或 Unicode 字符的普通文件）和<strong>二进制文件</strong>（所有非文本文件）。对内核来说，文本文件和二进制文件没有区别</li>
<li><strong>目录</strong>（directory）：包含一组<strong>链接</strong>（link）的文件，每个链接都将一个文件名映射到一个文件（可以也是目录），在 <code>ls</code> 里用 <code>d</code> 指示。每个目录至少含有两个条目：<code>.</code> 是到目录自身的链接，<code>..</code> 是到父目录的链接</li>
<li><strong>套接字</strong>（socket）：用于进程间的跨网络通信</li>
<li>其他文件类型：命名通道（named pipe）、符号链接（symbolic link）、字符和块设备（character and block device）</li>
</ul>
<p>Linux 内核将所有文件组织成一个<strong>目录层次结构</strong>（directory hierarchy）</p>
<p>每个进程都有一个<strong>当前工作目录</strong>（current working directory），这是它<strong>上下文的一部分</strong>。</p>
<p><strong>路径名</strong>是一个字符串，包含一系列 <code>/</code> 分隔的文件名，分为<strong>绝对路径名</strong>（<code>/home/xm/helloc.c</code>）和<strong>相对路径名</strong>（<code>./hello.c</code>）</p>
<h2 id="打开和关闭文件">打开和关闭文件 </h2>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token comment">// 打开路径名 filename 的文件</span>
<span class="token comment">// 返回：若成功，返回文件描述符；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>由 <code>open</code> 返回的文件描述符总是<strong>当前进程中最小的未用描述符</strong>，也就是说，如果已经打开了两个文件，其描述符是 <code>3</code> 和 <code>4</code>，那么下一次调用 <code>open</code> 就会返回 <code>5</code>。</p>
<p><code>flags</code> 指示进程如何访问文件：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_RDONLY</mtext></mrow><annotation encoding="application/x-tex">\text{O\_RDONLY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_RDONLY</span></span></span></span></span>：只读</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_WRONLY</mtext></mrow><annotation encoding="application/x-tex">\text{O\_WRONLY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_WRONLY</span></span></span></span></span>：只写</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_RDWR</mtext></mrow><annotation encoding="application/x-tex">\text{O\_RDWR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_RDWR</span></span></span></span></span>：可读可写</li>
</ul>
<p>可以用或运算将以上标志与下列标志组合：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_CREAT</mtext></mrow><annotation encoding="application/x-tex">\text{O\_CREAT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_CREAT</span></span></span></span></span>：如果文件不存在，则创建它的一个<strong>截断的</strong>文件（即创建一个大小为 <code>0</code> 的空文件）</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_TRUNC</mtext></mrow><annotation encoding="application/x-tex">\text{O\_TRUNC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_TRUNC</span></span></span></span></span>：如果文件存在，就<strong>截断</strong>它。<strong>这会导致文件内容丢失</strong>！</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_APPEND</mtext></mrow><annotation encoding="application/x-tex">\text{O\_APPEND}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_APPEND</span></span></span></span></span>：每次写时都追加到文件的末尾（设置当前文件位置为文件末尾）</li>
</ul>
<p>注意：没有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_RDONLY</mtext><mo>∣</mo><mtext>O_WRONLY</mtext></mrow><annotation encoding="application/x-tex">\text{O\_RDONLY}\mid\text{O\_WRONLY}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_RDONLY</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_WRONLY</span></span></span></span></span> 这种东西，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>O_RDWR</mtext></mrow><annotation encoding="application/x-tex">\text{O\_RDWR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">O_RDWR</span></span></span></span></span>。</p>
<p><strong>截断</strong>（truncate）：是置空（empty）的同义词，清除文件内容，但不删除文件。文件大小会被置为零。</p>
<p><code>mode</code> 参数<strong>只有在创建文件时</strong>才有意义，它指定新文件的<strong>访问权限</strong>（access permission）：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IRUSR</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IRUSR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IRUSR</span></span></span></span></span>：Owner 可读</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IWUSR</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IWUSR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IWUSR</span></span></span></span></span>：Owner 可写</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IXUSR</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IXUSR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IXUSR</span></span></span></span></span>：Owner 可执行</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IRGRP</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IRGRP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IRGRP</span></span></span></span></span>：Owner's group 可读</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IWGRP</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IWGRP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IWGRP</span></span></span></span></span>：Owner's group 可写</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IXGRP</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IXGRP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IXGRP</span></span></span></span></span>：Owner's group 可执行</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IROTH</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IROTH}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IROTH</span></span></span></span></span>：Others 可读</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IWOTH</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IWOTH}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IWOTH</span></span></span></span></span>：Others 可写</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S_IXOTH</mtext></mrow><annotation encoding="application/x-tex">\text{S\_IXOTH}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">S_IXOTH</span></span></span></span></span>：Others 可执行</li>
</ul>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>S</mtext></mrow><annotation encoding="application/x-tex">\text{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">S</span></span></span></span></span> 代表 STAT，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>I</mtext></mrow><annotation encoding="application/x-tex">\text{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">I</span></span></span></span></span> 代表 INODE。</p>
<p>每个进程都有一个 <code>umask</code>，它是通过调用 <code>umask</code> 函数来设置的，它是<strong>进程上下文的一部分</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEF_MODE</span> <span class="token expression">S_IRUSR <span class="token operator">|</span> S_IWUSR <span class="token operator">|</span> S_IRGRP <span class="token operator">|</span> S_IWGRP <span class="token operator">|</span> S_IROTH <span class="token operator">|</span> S_IWOTH</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEF_UMASK</span> <span class="token expression">S_IWGRP <span class="token operator">|</span> S_IWOTH</span></span>

<span class="token function">umask</span><span class="token punctuation">(</span>DEF_UMASK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// set process's umask</span>
fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_TRUNC <span class="token operator">|</span> O_WRONLY<span class="token punctuation">,</span> DEF_MODE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// permissions will be set to mode &amp; ~umask</span>
<span class="token comment">// fd's permissions: rw-r--r--</span>
</code></pre><p>新文件的权限位是 <code>mode &amp; ~umask</code>，<code>umask</code> 中置位的权限位会被屏蔽，总是被置零。</p>
<p><code>close</code> 函数关闭文件。<strong>关闭已经关闭的文件会出错</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 关闭文件</span>
<span class="token comment">// 返回：若成功，返回 0；若出错，返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h2 id="读和写文件">读和写文件 </h2>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 从 fd 的当前文件位置复制至多 n 字节到 buf</span>
<span class="token comment">// 返回：实际读到的字节数。若 EOF 则返回 0，若出错则返回 -1</span>
<span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 从 buf 复制至多 n 字节到 fd 的当前文件位置</span>
<span class="token comment">// 返回：实际写入的字节数。若出错则返回 -1</span>
<span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>lseek</code> 函数可以让应用程序显式地修改当前文件位置。</p>
<blockquote>
<p><code>size_t</code> 在 x86-64 中被定义为 <code>unsigned long</code>，而 <code>ssize_t</code> 被定义为 <code>long</code>。</p>
</blockquote>
<p>有时，<code>read</code> 和 <code>write</code> 传送的字节比应用程序要求的少，此时的返回值称为<strong>不足值</strong>（short count），原因有：</p>
<ul>
<li><strong>读时遇到 EOF</strong>：文件从当前文件位置起只剩 20 字节，我们却要求读 50 字节，那么此次调用 <code>read</code> 就会返回 20，下次调用 <code>read</code> 就会返回 0（EOF）。</li>
<li><strong>从终端读文本行</strong>：如果打开的文件和终端相关联（如键盘和显示器），那么每个 <code>read</code> 函数将<strong>一次传送一个文本行</strong>，返回的不足值是文本行的大小</li>
<li><strong>读写网络套接字</strong>（socket）：如果打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起 <code>read</code> 和 <code>write</code> 返回不足值。</li>
</ul>
<p>除 EOF 以外，读写磁盘文件时不会遇到不足值。</p>
<h2 id="用-rio-包健壮地读写">用 RIO 包健壮地读写 </h2>
<p>RIO (Robust I/O) 包可以自动处理不足值，在像网络程序这样容易出现不足值的应用中非常有用。</p>
<p>RIO 提供了：</p>
<ul>
<li><strong>无缓冲的输入输出函数</strong>：直接在内存和文件之间传送数据。对于将二进制数据在网络和内存之间传送非常有用</li>
<li><strong>带缓冲的输入函数</strong>：高效地从文件中读取文本行和二进制数据。它们是<strong>线程安全</strong>的，在同一个描述符上可以被交错调用：可以在同一个描述符中读一些文本行，然后读一些二进制数据，然后再读一些文本行。</li>
</ul>
<h3 id="rio-的无缓冲的输入输出函数">RIO 的无缓冲的输入输出函数 </h3>
<p>如果 <code>rio_readn</code> 和 <code>rio_writen</code> 被一个信号<strong>中断</strong>，那么它们会显式地重启 <code>read</code> 和 <code>write</code> 函数。这是为了代码的可移植性。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token comment">// 从 fd 的当前文件位置直接复制至多 n 个字节到 buf</span>
<span class="token class-name">ssize_t</span> <span class="token function">rio_readn</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> usrbuf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> nleft <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token class-name">ssize_t</span> nread<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> bufp <span class="token operator">=</span> usrbuf<span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>nleft <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> bufp<span class="token punctuation">,</span> nleft<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>  <span class="token comment">// interrupted by sig handler return</span>
                nread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// call read() again</span>
            <span class="token keyword keyword-else">else</span>
                <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">// errno set by read()</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">// EOF</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        nleft <span class="token operator">-=</span> nread<span class="token punctuation">;</span>
        bufp <span class="token operator">+=</span> nread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> nleft<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// return &gt;= 0</span>
<span class="token punctuation">}</span>

<span class="token comment">// 从 buf 直接复制 n 个字节到 fd 的当前文件位置</span>
<span class="token class-name">ssize_t</span> <span class="token function">rio_writen</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> usrbuf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> nleft <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token class-name">ssize_t</span> nwritten<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> bufp <span class="token operator">=</span> usrbuf<span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>nleft <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nwritten <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> bufp<span class="token punctuation">,</span> nleft<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>  <span class="token comment">// interrupted by sig handler return</span>
                nwritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// and call write() again</span>
            <span class="token keyword keyword-else">else</span>
                <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">// errno set by write()</span>
        <span class="token punctuation">}</span>
        nleft <span class="token operator">-=</span> nwritten<span class="token punctuation">;</span>
        bufp <span class="token operator">+=</span> nwritten<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><code>rio_readn</code> <strong>只会在 EOF 情形下返回不足值</strong>，<code>rio_writen</code> <strong>从不返回不足值</strong>。</p>
<p>对同一个描述符，可以任意地交错调用 <code>rio_readn</code> 和 <code>rio_writen</code>。</p>
<h3 id="rio-的带缓冲的输入函数">RIO 的带缓冲的输入函数 </h3>
<p>带缓冲区的 I/O 函数可以提高性能。</p>
<p><code>rio_t</code> 结构体存放一个内部缓冲区。使用时先调用 <code>rio_readinitb</code> 注册一个 <code>rio_t</code> 结构体，然后调用 <code>rio_readlineb</code> 或 <code>rio_readnb</code> 读取数据。</p>
<p><code>rio_read</code> 是 helper function，它从内部缓冲区向用户缓冲区复制数据。内部缓冲区一旦为空，就会自动从 <code>rio_t</code> 指示的文件描述符中重新装填满。</p>
<p><code>rio_read</code> 和 <code>rio_t</code> 为 <code>rio_readlineb</code> 和 <code>rio_readnb</code> 提供了一层抽象，后两个函数可以将 <code>rio_read</code> 看成是系统调用 <code>read</code> 的一个等价替代。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RIO_BUFSIZE</span> <span class="token expression"><span class="token number">8192</span></span></span>

<span class="token comment">// Internal buffer data structure</span>
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> rio_fd<span class="token punctuation">;</span>                <span class="token comment">// descriptor for this internal buf</span>
    <span class="token keyword keyword-int">int</span> rio_cnt<span class="token punctuation">;</span>               <span class="token comment">// unread bytes in internal buf</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> rio_bufptr<span class="token punctuation">;</span>          <span class="token comment">// next unread byte in internal buf</span>
    <span class="token keyword keyword-char">char</span> rio_buf<span class="token punctuation">[</span>RIO_BUFSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// internal buffer</span>
<span class="token punctuation">}</span> <span class="token class-name">rio_t</span><span class="token punctuation">;</span>

<span class="token comment">// Helper function</span>
<span class="token comment">// Initializes internal buffer</span>
<span class="token keyword keyword-void">void</span> <span class="token function">rio_readinitb</span><span class="token punctuation">(</span><span class="token class-name">rio_t</span><span class="token operator">*</span> rp<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rp<span class="token operator">-&gt;</span>rio_fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>
    rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    rp<span class="token operator">-&gt;</span>rio_bufptr <span class="token operator">=</span> rp<span class="token operator">-&gt;</span>rio_buf<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Helper function</span>
<span class="token comment">// Read up to n bytes from internal buf to usrbuf</span>
<span class="token comment">// Automatically refills when buf is empty</span>
<span class="token keyword keyword-static">static</span> <span class="token class-name">ssize_t</span> <span class="token function">rio_read</span><span class="token punctuation">(</span><span class="token class-name">rio_t</span><span class="token operator">*</span> rp<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> usrbuf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> cnt<span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// refill if buf is empty</span>
        rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>rp<span class="token operator">-&gt;</span>rio_fd<span class="token punctuation">,</span> rp<span class="token operator">-&gt;</span>rio_buf<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span> rp<span class="token operator">-&gt;</span>rio_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span>  <span class="token comment">// interrupted by sig handler return</span>
                <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// EOF</span>
            <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-else">else</span>
            rp<span class="token operator">-&gt;</span>rio_bufptr <span class="token operator">=</span> rp<span class="token operator">-&gt;</span>rio_buf<span class="token punctuation">;</span>  <span class="token comment">// reset buffer ptr to the beginning of the buffer</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf</span>
    cnt <span class="token operator">=</span> rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">&lt;</span> n <span class="token operator">?</span> rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">:</span> n<span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>usrbuf<span class="token punctuation">,</span> rp<span class="token operator">-&gt;</span>rio_bufptr<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rp<span class="token operator">-&gt;</span>rio_bufptr <span class="token operator">+=</span> cnt<span class="token punctuation">;</span>
    rp<span class="token operator">-&gt;</span>rio_cnt <span class="token operator">-=</span> cnt<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Read a whole line (of at most maxlen bytes) from internal buffer to usrbuf</span>
<span class="token class-name">ssize_t</span> <span class="token function">rio_readlineb</span><span class="token punctuation">(</span><span class="token class-name">rio_t</span><span class="token operator">*</span> rp<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> usrbuf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> maxlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> n<span class="token punctuation">;</span>     <span class="token comment">// num of lines read</span>
    <span class="token keyword keyword-int">int</span> rc<span class="token punctuation">;</span>    <span class="token comment">// char read by rio_read</span>
    <span class="token keyword keyword-char">char</span> c<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> bufp <span class="token operator">=</span> usrbuf<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> maxlen<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">rio_read</span><span class="token punctuation">(</span>rp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// read 1 byte</span>
            <span class="token operator">*</span>bufp<span class="token operator">++</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                n<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// EOF, no data read</span>
            <span class="token keyword keyword-else">else</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>     <span class="token comment">// EOF, some data was read</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span>
            <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// error</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>bufp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Append a NULL byte to the end of usrbuf</span>
    <span class="token keyword keyword-return">return</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Read up to n bytes from internal buffer to usrbuf</span>
<span class="token class-name">ssize_t</span> <span class="token function">rio_readnb</span><span class="token punctuation">(</span><span class="token class-name">rio_t</span><span class="token operator">*</span> rp<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> usrbuf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> nleft <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token class-name">ssize_t</span> nread<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> bufp <span class="token operator">=</span> usrbuf<span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>nleft <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nread <span class="token operator">=</span> <span class="token function">rio_read</span><span class="token punctuation">(</span>rp<span class="token punctuation">,</span> bufp<span class="token punctuation">,</span> nleft<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// errno set by read()</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">// EOF</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        nleft <span class="token operator">-=</span> nread<span class="token punctuation">;</span>
        bufp <span class="token operator">+=</span> nread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> nleft<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// return &gt;= 0</span>
<span class="token punctuation">}</span>
</code></pre><p>对同一描述符，<strong>对以上两个带缓冲的输入函数的调用可以任意交错进行</strong>，但是对带缓冲的输入函数的调用<strong>不应和无缓冲的 <code>rio_readn</code> 函数交错调用</strong></p>
<h2 id="读取文件元数据">读取文件元数据 </h2>
<p>应用程序可以调用 <code>stat</code> 和 <code>fstat</code> 函数，获得文件的<strong>元数据</strong>（metadata）</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token comment">// metadata returned by stat and fstat</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">{</span>
    <span class="token class-name">dev_t</span> st_dev<span class="token punctuation">;</span>         <span class="token comment">// device number</span>
    <span class="token class-name">ino_t</span> st_ino<span class="token punctuation">;</span>         <span class="token comment">// inode number</span>
    <span class="token class-name">mode_t</span> st_mode<span class="token punctuation">;</span>       <span class="token comment">// protection and file types</span>
    <span class="token class-name">nlink_t</span> st_nlink<span class="token punctuation">;</span>     <span class="token comment">// number of hard links</span>
    <span class="token class-name">uid_t</span> st_uid<span class="token punctuation">;</span>         <span class="token comment">// user ID of owner</span>
    <span class="token class-name">gid_t</span> st_gid<span class="token punctuation">;</span>         <span class="token comment">// group ID of owner</span>
    <span class="token class-name">dev_t</span> st_rdev<span class="token punctuation">;</span>        <span class="token comment">// device type (if inode device)</span>
    <span class="token class-name">off_t</span> st_size<span class="token punctuation">;</span>        <span class="token comment">// total size, in bytes</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> st_blksize<span class="token punctuation">;</span> <span class="token comment">// blocksize for filesystem I/O</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> st_blocks<span class="token punctuation">;</span>   <span class="token comment">// number of blocks allocated</span>
    <span class="token class-name">time_t</span> st_atime<span class="token punctuation">;</span>      <span class="token comment">// time of last access</span>
    <span class="token class-name">time_t</span> st_mtime<span class="token punctuation">;</span>      <span class="token comment">// time of last modification</span>
    <span class="token class-name">time_t</span> st_ctime<span class="token punctuation">;</span>      <span class="token comment">// time of last status change</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 这两个函数分别以路径名和文件描述符为输入，将文件元数据填充在 buf 参数中</span>
<span class="token comment">// 返回：若成功则返回 0，若出错则返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>st_size</code>：文件的字节数大小<br>
<code>st_mode</code>：文件访问权限和文件类型</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token class-name">mode_t</span> m <span class="token operator">=</span> buf<span class="token punctuation">.</span>st_mode<span class="token punctuation">;</span>

<span class="token comment">// 确定 st_mode 指示的文件类型的宏谓词</span>
<span class="token function">S_ISREG</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>    <span class="token comment">// is this a regular file?</span>
<span class="token function">S_ISDIR</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>    <span class="token comment">// is this a directory file?</span>
<span class="token function">S_ISSOCK</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>    <span class="token comment">// is this a network socket?</span>
</code></pre><p>一个展示文件元数据的示例程序：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token comment">// Usage: ./showstat &lt;filename&gt;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span> stat<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> type<span class="token punctuation">,</span> <span class="token operator">*</span>readok<span class="token punctuation">;</span>

    <span class="token function">Stat</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stat<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">S_ISREG</span><span class="token punctuation">(</span>stat<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// determine file type</span>
        type <span class="token operator">=</span> <span class="token string">"regular"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">S_ISDIR</span><span class="token punctuation">(</span>stat<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        type <span class="token operator">=</span> <span class="token string">"directory"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span>
        type <span class="token operator">=</span> <span class="token string">"other"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stat<span class="token punctuation">.</span>st_mode <span class="token operator">&amp;</span> S_IRUSR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// check read access</span>
        readok <span class="token operator">=</span> <span class="token string">"yes"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span>
        readok <span class="token operator">=</span> <span class="token string">"no"</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"type: %s, read: %s\n"</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> readok<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="读取目录内容">读取目录内容 </h2>
<p><strong>流</strong>是对一个有序列表的抽象，<strong>目录流</strong>（directory stream）就是一个目录中文件的列表。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dirent.h&gt;</span></span>

<span class="token comment">// 打开目录</span>
<span class="token comment">// 返回：若成功则返回指向目录流的指针，若出错则返回 NULL</span>
DIR<span class="token operator">*</span> <span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 目录的项</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">dirent</span> <span class="token punctuation">{</span>
    <span class="token class-name">ino_t</span> d_ino<span class="token punctuation">;</span>       <span class="token comment">// inode number</span>
    <span class="token keyword keyword-char">char</span> d_name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// null-terminated filename</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 读取目录中的下一项</span>
<span class="token comment">// 返回：指向目录中下一项的指针，若已到达目录尾或出错则返回 NULL</span>
<span class="token comment">// 如果出错，还会设置 errno</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">dirent</span><span class="token operator">*</span> <span class="token function">readdir</span><span class="token punctuation">(</span>DIR<span class="token operator">*</span> dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 关闭目录流并释放资源</span>
<span class="token comment">// 返回：若成功则返回 0，若出错则返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR<span class="token operator">*</span> dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>区分 <code>readdir</code> 调用出错和流结束情况的<strong>唯一</strong>方法是检查 <code>errno</code> 是否被修改。</p>
<p>一个打印目录中所有文件的程序示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    DIR<span class="token operator">*</span> streamp<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">dirent</span><span class="token operator">*</span> dep<span class="token punctuation">;</span>

    streamp <span class="token operator">=</span> <span class="token function">Opendir</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dep <span class="token operator">=</span> <span class="token function">readdir</span><span class="token punctuation">(</span>streamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Found file: %s\n"</span><span class="token punctuation">,</span> dep<span class="token operator">-&gt;</span>d_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">unix_error</span><span class="token punctuation">(</span><span class="token string">"readdir error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">Closedir</span><span class="token punctuation">(</span>streamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="共享文件">共享文件 </h2>
<p>内核用三个数据结构标识打开的文件：</p>
<ul>
<li><strong>描述符表</strong>（descriptor table）：每个进程有一张独立的描述符表，表项的<strong>索引是打开的文件描述符</strong>，表项是<strong>指向文件表</strong>的指针</li>
<li><strong>文件表</strong>（file table）：包含已打开的文件，所有进程共享文件表。表项包括<strong>当前文件位置</strong>、<strong>引用计数</strong>和一个<strong>指向 v-node 表项的指针</strong>。引用计数是指向此文件表表项的描述符表表项的个数。内核只会在其引用计数归零时删除文件表表项</li>
<li><strong>v-node 表</strong>（v-node table）：所有进程共享 v-node 表。v-node 表项包括 <code>stat</code> 结构中的大多数信息，包括 <code>st_mode</code> 和 <code>st_size</code> 等。</li>
</ul>
<p>如果用同一个 <code>filename</code> 调用 <code>open</code> 两次，那么两个描述符表表项所指向的两个文件表表项会指向同一个 v-node 表表项。</p>
<p><img src="./note-part2_files/10-12-file-sharing.png" alt=""></p>
<p>如果父进程调用 <code>fork</code> 创建子进程，那么子进程会继承父进程的描述符表，如下图。必须等到父子进程均关闭文件后，内核才能删除相应的文件表表项。</p>
<p><img src="./note-part2_files/10-14-父子进程共享文件.png" alt=""></p>
<h2 id="io-重定向">I/O 重定向 </h2>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 用描述表表项 oldfd 覆写描述符表表项 newfd</span>
<span class="token comment">// 如果 newfd 已经打开，dup2 会在覆写前将其关闭</span>
<span class="token comment">// 返回：若成功则返回 newfd，若出错则返回 -1 并设置 errno</span>
<span class="token keyword keyword-int">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> oldfd<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果调用 <code>dup2(4, 1)</code> 之前的状态如图 10-12，那么调用之后的状态如图 10-15，此时文件 A 已经被关闭，它的文件表表项和 v-node 表表项也被删除，文件 B 的引用计数增加到 2。从此，任何写到标准输出的数据都会被重定向到文件 B。</p>
<p><img src="./note-part2_files/10-15-重定向输出.png" alt=""></p>
<h2 id="标准-io">标准 I/O </h2>
<p><strong>标准 I/O 库</strong>是 C 定义的一组高级输入输出函数。</p>
<p>它将一个已打开的文件视为一个<strong>流</strong>，即一个指向 <code>FILE</code> 对象的指针。每个 ANSI C 程序开始时都有三个已打开的流：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-extern">extern</span> FILE<span class="token operator">*</span> <span class="token constant">stdin</span><span class="token punctuation">;</span>    <span class="token comment">// standard input</span>
<span class="token keyword keyword-extern">extern</span> FILE<span class="token operator">*</span> <span class="token constant">stdout</span><span class="token punctuation">;</span>   <span class="token comment">// standard output</span>
<span class="token keyword keyword-extern">extern</span> FILE<span class="token operator">*</span> <span class="token constant">stderr</span><span class="token punctuation">;</span>   <span class="token comment">// standard error</span>
</code></pre><p>流是<strong>对文件描述符和流缓冲区的抽象</strong>。流缓冲区和 RIO 读缓冲区类似，都是为了减少高开销的 Linux I/O 系统调用的次数，使局部性好的访问尽可能多从缓冲区得到服务。</p>
<h2 id="我该使用哪些-io-函数">我该使用哪些 I/O 函数？ </h2>
<ul>
<li>尽量使用标准 I/O。对磁盘和终端设备 I/O 来说，这是最优解（不过标准 I/O 库没有与 <code>stat</code> 对应的函数）。</li>
<li>不要用 <code>scanf</code> 或 <code>rio_readlineb</code> 读二进制文件。二进制文件中可能包含许多 <code>0xa</code> 字节，这会被误认为是换行符。</li>
<li>对于网络套接字，使用 RIO 包。</li>
</ul>
<p>标准 I/O 流是<strong>全双工</strong>（full duplex）的，即程序可以在同一个流上执行输入和输出。但对流的限制和对套接字的限制有时会冲突。</p>
<p>大多数情况下，我们从流的开头读，在流的结尾写。在这种情形下，</p>
<ul>
<li><strong>输出函数之后的输入函数</strong>：写操作之后需要先调用 <code>fflush</code>、<code>fseek</code>、<code>fsetpos</code> 或 <code>rewind</code>，然后才能开始读。<code>fflush</code> 清空与流相关的缓冲区，而后三者使用 Unix I/O <code>lseek</code> 函数来重置当前文件位置。</li>
<li><strong>输入函数之后的输出函数</strong>：读操作之后需要先调用 <code>fseek</code>、<code>fsetpos</code> 或 <code>rewind</code> 改变当前文件位置，然后才能开始写，<strong>除非输入函数遭遇了 EOF</strong>。</li>
</ul>
<p>这两个限制给网络应用带来了麻烦。而且，套接字本质是全双工的，不能很好地用标准库流来抽象。</p>
<p>第一个限制可以通过每次输入前调用 <code>fflush</code> 解决，然而由于对套接字调用 <code>lseek</code> 函数是非法的，解决第二个限制的唯一办法是<strong>对同一个打开的套接字描述符打开两个流</strong>，一个读，一个写。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>FILE<span class="token operator">*</span> fpin<span class="token punctuation">;</span>
FILE<span class="token operator">*</span> fpout<span class="token punctuation">;</span>

fpin <span class="token operator">=</span> <span class="token function">fdopen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fpout <span class="token operator">=</span> <span class="token function">fdopen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 这又要求应用程序必须对两个流都调用 fclose，从而释放两个流的内存资源</span>
<span class="token function">fclose</span><span class="token punctuation">(</span>fpin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fclose</span><span class="token punctuation">(</span>fpout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 由于 sockfd 已经被关闭，所以第二次 fclose 会失败</span>
<span class="token comment">// 对顺序的程序，这不是问题。</span>
<span class="token comment">// 但是在线程化的程序中关闭一个已关闭的描述符会导致灾难</span>
<span class="token comment">// 因此：不要在网络套接字上使用标准 I/O 函数，换用 RIO 函数完成 I/O 操作</span>
<span class="token comment">// 如果需要格式化输出，使用 sprintf 格式化一个字符串，再用 rio_writen 将它发送到套接口。</span>
<span class="token comment">// 如果需要格式化输入，使用 rio_readlineb 读取一个完整的文本行，再用 sscanf 解析它</span>
</code></pre><h1 id="网络编程">网络编程 </h1>
<h2 id="客户端-服务器编程模型">客户端-服务器编程模型 </h2>
<p>每个网络应用都基于<strong>客户端-服务器模型</strong>（client-server model）。</p>
<p>一个应用由一个<strong>服务器</strong>进程和一个或多个<strong>客户端</strong>进程组成。服务器管理并操作某种资源，为客户端提供服务。</p>
<p>客户端-服务器模型中的基本操作是<strong>事务</strong>（transaction）：</p>
<ul>
<li>客户端需要服务时，向服务器发送一个<strong>请求</strong>（request），发起一个事务</li>
<li>服务器收到请求，解释它，并操作它的资源</li>
<li>服务器返回客户端一个<strong>响应</strong>（response），并等待下一个请求</li>
<li>客户端收到响应，处理它</li>
</ul>
<p>客户端和服务器是<strong>进程</strong>，而不是<strong>主机</strong>（host）。</p>
<h2 id="网络">网络 </h2>
<p>客户端和服务器通常运行在不同的主机上，通过计算机网络的软硬件资源通信。</p>
<p>对主机而言，网络只是一种 I/O 设备。插在 I/O 总线扩展槽上的<strong>网络适配器</strong>（network adapter）提供了到网络的物理接口。数据在网络和主存之间通过 I/O 和内存总线传送（通常为 DMA 传送）。</p>
<p>物理上，网络是一个按照地理远近组成的层次系统。最底层是 <strong>LAN</strong>（Local Area Network，<strong>局域网</strong>），范围为一栋建筑或一个校园。最流行的局域网技术是<strong>以太网</strong>（Ethernet），它适应力极强，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mtext>&nbsp;Mb/s</mtext></mrow><annotation encoding="application/x-tex">3\text{ Mb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord text"><span class="mord">&nbsp;Mb/s</span></span></span></span></span> 演变到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mtext>&nbsp;Gb/s</mtext></mrow><annotation encoding="application/x-tex">10\text{ Gb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mord text"><span class="mord">&nbsp;Gb/s</span></span></span></span></span>。</p>
<p>一个<strong>以太网段</strong>（Ethernet segment）包括一些电缆（通常是双绞线）和一个<strong>集线器</strong>（hub）。</p>
<p>以太网段的范围通常较小，约为一个房间或一个楼层。每根电缆的<strong>最大位带宽</strong>相同，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mtext>&nbsp;Mb/s</mtext></mrow><annotation encoding="application/x-tex">100 \text{ Mb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">100</span><span class="mord text"><span class="mord">&nbsp;Mb/s</span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>&nbsp;Gb/s</mtext></mrow><annotation encoding="application/x-tex">1\text{ Gb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord text"><span class="mord">&nbsp;Gb/s</span></span></span></span></span>，一端连接到集线器的一个<strong>端口</strong>（port），另一端连接到主机的适配器。</p>
<p>集线器不加分辨地将从一个端口上收到的所有位复制到其他所有端口上，因此，每台主机都能看到每个位。</p>
<p>每个以太网适配器都有一个全球唯一的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>48</mn></mrow><annotation encoding="application/x-tex">48</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">48</span></span></span></span> 位地址，存储在这个适配器的非易失性存储器上。一台主机可以发送一段位（称为<strong>帧</strong>，frame）到同网段的其他任何主机。</p>
<p>每个帧包括一个固定长度的<strong>头部</strong>（header），标识帧的源、目的和长度。其后就是存储数据的<strong>有效载荷</strong>（payload）。每个主机适配器都能看到这个帧，但只有目的主机实际读取它。</p>
<p>使用一些电缆和<strong>网桥</strong>（bridge），可以将多个以太网段连接成较大的局域网，称为<strong>桥接以太网</strong>（bridged Ethernet），它的范围可以是一个建筑或一个校园。</p>
<p>桥接以太网中，有些电缆连接网桥与网桥，另外一些电缆连接网桥和集线器。下图中，前者的带宽为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>&nbsp;Gb/s</mtext></mrow><annotation encoding="application/x-tex">1\text{ Gb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord text"><span class="mord">&nbsp;Gb/s</span></span></span></span></span>，后者的带宽为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mtext>&nbsp;Mb/s</mtext></mrow><annotation encoding="application/x-tex">100\text{ Mb/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">100</span><span class="mord text"><span class="mord">&nbsp;Mb/s</span></span></span></span></span>。</p>
<p><img src="./note-part2_files/11-4-桥接以太网.png" alt=""></p>
<p>网桥比集线器更充分地利用了电缆带宽。它们可以学习哪个主机通过哪个端口可达，只在有必要时，有选择地将帧从一个端口复制到其他端口。</p>
<p>网桥先判断目的地址是否在表中，如果在表中，则复制到对应的端口；如果不在，将此帧复制到所有端口，被目的主机接收后更新表项。</p>
<p>例如，如果主机 A 发送一个帧到同网段的主机 B，那么当这个帧到达网桥 X 的输入端口时，X 就会丢弃它。如果 A 发送一个帧到另一个网段的主机 C，那么 X 只会将此帧复制到和网桥 Y 相连的端口上，Y 只会将此帧复制到和 C 所在的网段连接的端口。</p>
<p>我们将集线器和网桥以及电缆抽象为一根水平线，如图 11-5。</p>
<p>多个不兼容的局域网可以通过<strong>路由器</strong>（router）连接起来，组成一个 <strong>internet</strong>（互联网络）。路由器是一种特殊的计算机，每台路由器对于它连接到的每个网络都有一个适配器（端口）。路由器也能连接<strong>高速点到点电话连接</strong>（high-speed point-to-point phone connections），它是 <strong>WAN</strong>（Wide-Area-Network, <strong>广域网</strong>）的一个例子。</p>
<p>路由器可以由各种局域网和广域网构建 internet。如图 11-6，三台路由器连接了一对局域网和一对广域网。</p>
<p><img src="./note-part2_files/11-6-小型internet.png" alt=""></p>
<p>互联网络可以由采用完全不同且互不兼容技术的各种局域网和广域网组成，每台主机和其他主机都是<strong>物理相连</strong>的。</p>
<p>每台主机和路由器上运行着的<strong>协议软件</strong>（protocol software）消除了不同网络之间的差异，使得不兼容的网络中的主机之间也可以相互通信。协议软件实现一种协议，它有两种基本能力：</p>
<ul>
<li><strong>命名机制</strong>（naming scheme）：不同局域网技术有不同且不兼容的方式为主机分配地址。internet 协议定义了一种一致的主机地址格式，为每台主机分配至少一个 <strong>internet address</strong>（互联网络地址）</li>
<li><strong>传送机制</strong>（delivery mechanism）：不同的联网技术中，帧的编码格式不同且不兼容。internet 协议定义了一种将数据位捆扎成不连续的片（称为<strong>包</strong>，packet）的方式。一个包由<strong>包头</strong>和<strong>有效载荷</strong>组成，包头包括包的大小、源主机地址、目的主机地址。</li>
</ul>
<p><img src="./note-part2_files/11-7-internet主机通信.png" alt=""></p>
<p>当主机 A 的客户端进程向主机 B 的服务器进程发送一串数据字节时：</p>
<ol>
<li>主机 A 上的客户端进程进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区</li>
<li>主机 A 上的协议软件通过在数据前附加 internet 包头和 LAN1 帧头，创建一个 LAN1 的帧</li>
<li>LAN1 适配器复制此帧到网络上</li>
<li>到达路由器后，路由器的 LAN1 适配器从电缆上读取它，将它传送到协议软件</li>
<li>路由器从 internet 包头中提取出目的主机地址，作为路由表的索引，确定向哪里转发这个包（本例中为 LAN2）。路由器剥落 LAN1 帧头，附加寻址到主机 B 的 LAN2 帧头，创建一个 LAN2 帧，传送到 LAN2 适配器</li>
<li>路由器的 LAN2 适配器复制此帧到网络上</li>
<li>此帧到达主机 B 时，它的适配器从电缆上读到此帧，将它传送到协议软件</li>
<li>主机 B 的协议软件剥落包头和 LAN2 帧头。当服务器进程进行一个读取这些数据的系统调用时，协议软件将数据复制到主机 B 的虚拟地址空间</li>
</ol>
<h2 id="全球-ip-因特网">全球 IP 因特网 </h2>
<p>全球 IP 因特网（the global IP Internet）是最著名、最成功的 internet 实现。</p>
<p><img src="./note-part2_files/11-8-Internet应用的软硬件组织.png" alt=""></p>
<p>每台 Internet 主机都运行着实现 <strong>TCP/IP 协议</strong>（Transmission Control Protocol/Internet Protocol, 传输控制协议/互联网络协议）的软件。</p>
<p>Internet 的客户端和服务器混合使用<strong>套接字接口函数</strong>和 Unix I/O 函数通信。套接字接口函数通常被实现成系统调用，它们陷入内核，调用各种内核模式的 TCP/IP 函数。</p>
<p>TCP/IP 实际上是一个协议族，每个都提供一些不同的功能。</p>
<p>IP 协议提供基本的命名方法和传送机制。IP 协议中的包也叫<strong>数据报</strong>（datagram）。如果数据报在网络中丢失或重复，它并不会试图恢复，因此 IP 协议某种意义上并不可靠。<strong>UDP</strong>（Unreliable Datagram Protocol，<strong>不可靠数据报协议</strong>）是 IP 协议的扩展，它使得包可以在进程之间（而不是主机之间）传送。TCP 是构建在 IP 之上的复杂协议，提供了进程之间可靠的<strong>全双工连接</strong>（full duplex connections）。</p>
<p>我们不讨论 UDP，将 TCP/IP 整体看作一个协议。</p>
<p>从程序员角度，可以将 Internet 看作一个世界范围的主机集合，它：</p>
<ul>
<li>被映射为一组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位的 IP 地址</li>
<li>这组 IP 地址被映射为称为 <strong>Internet 域名</strong>（domain name）的标识符</li>
<li>Internet 主机上的进程可以通过<strong>连接</strong>（connection）和 Internet 上其他任何主机上的进程通信</li>
</ul>
<blockquote>
<p>最初的 Internet 协议使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位地址，称为 Internet Protocol Version 4, IPv4。Internet 工程任务组织（Internet Engineering Task Force, IETF）提出了一个新版本的 IP，称为 IPv6，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span></span></span></span> 位地址。<br>
现在（2023 年 12 月），Google 用户中 IPv6 的使用率约为 42%。</p>
</blockquote>
<h3 id="ip-地址">IP 地址 </h3>
<p>IP 地址是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位无符号整数，用于<strong>标识主机</strong>。它被存放在一个结构体中：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">in_addr</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> s_addr<span class="token punctuation">;</span>  <span class="token comment">// 32-bit IPv4 address (big-endian)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>这是一个失败的设计，为 IP 地址定义一个标量类型更有意义。</p>
<p>TCP/IP 为任意整数数据定义了统一的<strong>网络字节顺序</strong>（network byte order），即采用大端法存储。Unix 提供了转换字节顺序的函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>

<span class="token class-name">uint32_t</span> <span class="token function">htonl</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> hostint32<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// host to network long</span>
<span class="token class-name">uint16_t</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> hostint16<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// host to network short</span>

<span class="token class-name">uint32_t</span> <span class="token function">ntohl</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> netint32<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// network to host long</span>
<span class="token class-name">uint16_t</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> netint16<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// network to host short</span>

<span class="token comment">// there's no 64-bit versions of these functions</span>
</code></pre><p>IP 地址通常通过<strong>点分十进制表示法</strong>（dotted-decimal notation）表示，每个字节由它的十进制值表示，字节之间用点分隔。例如，<code>128.2.194.242</code> 就表示地址 <code>0x8002c2f2</code>。</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token function">hostname</span> <span class="token parameter variable">-i</span>    <span class="token comment"># print IP address</span>
</code></pre><p>可以用以下函数实现 IP 地址和点分十进制串的转换。函数名中，<code>n</code> 表示 network，代表 IP 地址；<code>p</code> 表示 presentation，代表点分十进制串。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AF_INET</mtext></mrow><annotation encoding="application/x-tex">\text{AF\_INET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AF_INET</span></span></span></span></span> 表示 IPv4 地址，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AF_INET6</mtext></mrow><annotation encoding="application/x-tex">\text{AF\_INET6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AF_INET6</span></span></span></span></span> 表示 IPv6 地址。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>

<span class="token comment">// 返回：若成功则返回 1，若 src 非法则返回 0，若出错则返回 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// size 规定了向 dst 复制的字节数的上限，得到的字符串以 NULL 结尾</span>
<span class="token comment">// 返回：若成功则返回指向 dst 的指针，若出错则返回 NULL</span>
<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">inet_ntop</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="internet-域名">Internet 域名 </h3>
<p>Internet 客户端和服务器互相通信时使用的是 IP 地址，它不方便记忆。Internet 定义了<strong>域名</strong>（domain name），它是一串句点分隔的标识符（标识符可以包含字母、数字和连字符），例如 <code>pku.edu.cn</code></p>
<p>域名集合形成了一个树形的层次结构。从树的叶结点到根结点的路径形成了域名，子树形成了<strong>子域名</strong>（subdomain）。</p>
<p><img src="./note-part2_files/11-10-Internet域名集合的一个子集.png" alt=""></p>
<p><strong>一级域名</strong>由非营利组织 ICANN（Internet Corporation for Assigned Names and Numbers）定义，包括 <code>com</code>、<code>edu</code>、<code>gov</code>、<code>net</code>、<code>org</code>。</p>
<p>二级域名，例如 <code>cmu.edu</code>，是由 ICANN 的各个授权代理按先到先服务的方式分配的。一旦一个组织得到了一个二级域名，它就可以在这个子域名下创建任何新域名了，例如 <code>cs.cmu.edu</code></p>
<p>Internet 定义了从域名集合到 IP 地址集合的映射，直到 1988 年，这个映射都是通过一个叫做 <code>HOSTS.TXT</code> 的文件手工维护的。1988 年起，这个映射通过分布在世界范围内的 DNS（Domain Name System）维护。</p>
<p>DNS 数据库由上百万的<strong>主机条目结构</strong>（host entry structure）组成，每条定义一组域名和一组 IP 地址之间的映射。</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token comment"># nslookup 打印某个域名对应的 IP 地址</span>
<span class="token function">nslookup</span> cs.mit.edu
</code></pre><p>每台 Internet 主机都有本地定义的域名 <code>localhost</code>，它被映射为<strong>回送地址</strong>（loopback address）<code>127.0.0.1</code></p>
<p>可以用 <code>hostname</code> 确定本地主机的实际域名</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code><span class="token function">hostname</span>
</code></pre><p>一个合法的域名可以映射到一个或多个 IP 地址，也可以不映射到任何 IP 地址（比如 <code>edu</code>）。多个域名也可以映射到同一个 IP 地址。</p>
<h3 id="internet-连接">Internet 连接 </h3>
<p>Internet 客户端和服务器通过在<strong>连接</strong>（connection）上发送和接收字节流来通信。连接是</p>
<ul>
<li><strong>点对点</strong>的：进程对进程</li>
<li><strong>全双工</strong>的：数据可以同时双向流动的</li>
<li><strong>可靠</strong>的：源进程发送的字节流最终会被目的进程接收到，且接收到的字节流的顺序保证与发送的顺序相同（除非电缆被切断了）</li>
</ul>
<p>一个<strong>套接字</strong>（socket）是连接的一个端点。每个套接字都有相应的<strong>套接字地址</strong>，由一个 Internet 地址和一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> 位整数<strong>端口</strong>组成，表示为 <code>address:port</code>。</p>
<p>客户端进程发起一个连接请求时，内核自动分配客户端套接字地址中的端口，称为<strong>临时端口</strong>（ephemeral port）。<strong>临时端口的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>∼</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">1024\sim 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5000</span></span></span></span></strong>。</p>
<p>服务器套接字地址中的端口通常是某个永久与该服务绑定的<strong>知名端口</strong>（well-known port），范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>1023</mn></mrow><annotation encoding="application/x-tex">0\sim 1023</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1023</span></span></span></span>。每个具有知名端口的服务都有一个对应的<strong>知名服务名</strong>（well-known service name）。例如，Web 服务器通常使用端口 <code>80</code>，知名服务名是 <code>http</code>，电子邮件服务器通常使用端口 <code>25</code>，知名服务名是 <code>smtp</code>。</p>
<p><code>/etc/services</code> 文件列出了机器提供的知名名字和知名端口的映射。</p>
<p>一个连接由它两端的套接字地址唯一确定，这对套接字地址称作<strong>套接字对</strong>（socket pair），表示为 <code>(cliaddr:cliport, servaddr:servport)</code></p>
<h2 id="套接字接口">套接字接口 </h2>
<p><strong>套接字接口</strong>（socket interface）是一组函数，它们可以和 Unix I/O 函数结合起来开发网络应用。</p>
<p><img src="./note-part2_files/11-12-socket接口概述.png" alt=""></p>
<h3 id="套接字地址结构体">套接字地址结构体 </h3>
<p>对于 Linux 内核来说，套接字就是通信的端点。</p>
<p>对于 Linux 程序来说，套接字就是一个打开的文件。</p>
<p>Internet 的套接字地址存放在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> 字节大的结构体 <code>sockaddr_in</code> 中。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// IP socket address structure</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> sin_family<span class="token punctuation">;</span>  <span class="token comment">// Protocol family (always AF_INET)</span>
    <span class="token class-name">uint16_t</span> sin_port<span class="token punctuation">;</span>    <span class="token comment">// Port number in network byte order</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">in_addr</span> sin_addr<span class="token punctuation">;</span>  <span class="token comment">// IP address in network byte order</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-char">char</span> sin_zero<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Pad to sizeof(struct sockaddr)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Generic socket address structure (for connect, bind, and accept)</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> sa_family<span class="token punctuation">;</span>  <span class="token comment">// Protocol family</span>
    <span class="token keyword keyword-char">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// Address data</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p><code>_in</code> 后缀是 internet 的缩写。</p>
<p><code>sa_family</code> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 字节的地址家族。</p>
<p>对于 Internet 应用，<code>sin_family</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AF_INET</mtext></mrow><annotation encoding="application/x-tex">\text{AF\_INET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AF_INET</span></span></span></span></span>，<code>sin_port</code> 为端口号，<code>sin_addr</code> 为 IP 地址。</p>
<p><code>connect</code>、<code>bind</code> 和 <code>accept</code> 函数要求一个指向与协议相关的 <code>sockaddr</code> 结构体的指针。这需要泛型，然而当时的 C 中连 <code>void*</code> 类型都没有。</p>
<p>因此，套接字函数被定义为接受一个 <code>sockaddr*</code> 类型的参数，然后要求应用程序将协议特定的结构体指针强制转换为该类型。它是所有协议特定的套接字地址结构体的<strong>虚父类</strong>。</p>
<p>为了简便：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span> SA<span class="token punctuation">;</span>
</code></pre><h3 id="socket-函数"><code>socket</code> 函数 </h3>
<p>客户端和服务器使用 <code>socket</code> 函数创建一个<strong>套接字描述符</strong>（socket descriptor）</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为非负描述符，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> domain<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> type<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>domain</code> 参数指明网络层地址家族，对于 IPv4 地址，它是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AF_INET</mtext></mrow><annotation encoding="application/x-tex">\text{AF\_INET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AF_INET</span></span></span></span></span>。</p>
<p><code>type</code> 参数指明传输层协议：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SOCK_STREAM</mtext></mrow><annotation encoding="application/x-tex">\text{SOCK\_STREAM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SOCK_STREAM</span></span></span></span></span>：TCP 字节流</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SOCK_DGRAM</mtext></mrow><annotation encoding="application/x-tex">\text{SOCK\_DGRAM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SOCK_DGRAM</span></span></span></span></span>：UDP 数据报</li>
</ul>
<p>例如，如果想要使套接字成为连接的一个端点：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>clientfd <span class="token operator">=</span> <span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>更好的方法是使用 <code>getaddrinfo</code>，使得代码拥有更好的可移植性。</p>
<p><code>socket</code> 返回的 <code>clientfd</code> 只是<strong>部分打开</strong>的，还不能用于读写。</p>
<h3 id="bind-函数"><code>bind</code> 函数 </h3>
<p>服务器调用 <code>bind</code> 函数来告诉内核将 <code>addr</code> 中的服务器套接字地址和套接字描述符 <code>sockfd</code> 绑定。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为 -1，并设置 errno</span>
<span class="token keyword keyword-int">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>addrlen</code> 还是 <code>sizeof sockaddr_in</code>。</p>
<p>客户程序不需要调用 <code>bind</code>，内核会自动为其在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>∼</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">1024\sim 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5000</span></span></span></span> 之间分配一个端口号。</p>
<h3 id="connect-函数"><code>connect</code> 函数 </h3>
<p>客户端调用 <code>connect</code> 函数向服务器发送连接请求。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> clientfd<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>addrlen</code> 是 <code>sizeof sockaddr_in </code>。</p>
<p><code>connect</code> 函数会阻塞，直到连接成功建立或发生错误。若成功，<code>clientfd</code> 就可以开始读写了，并且得到的连接由套接字对</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token punctuation">(</span>x<span class="token operator">:</span>y<span class="token punctuation">,</span> addr<span class="token punctuation">.</span>sin_addr<span class="token operator">:</span>addr<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span>
</code></pre><p>刻画，其中 <code>x</code> 是客户端的 IP 地址，<code>y</code> 是临时端口，它唯一确定了客户端进程。</p>
<p>和 <code>socket</code> 一样，最好用 <code>getaddrinfo</code> 为 <code>connect</code> 提供参数。</p>
<h3 id="listen-函数"><code>listen</code> 函数 </h3>
<p>默认地，内核认为 <code>socket</code> 函数创建的描述符对应于<strong>主动套接字</strong>（active socket），属于这个连接的客户端一方。</p>
<p>服务器调用 <code>listen</code> 函数，让内核将 <code>sockfd</code> 由主动套接字转换为<strong>监听套接字</strong>（listening socket），该套接字可以接受来自客户端的连接请求。</p>
<p><code>backlog</code> 参数设定了<strong>监听队列长度</strong>，通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn></mrow><annotation encoding="application/x-tex">1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span>。超过此长度后，内核开始拒绝连接请求。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="accept-函数"><code>accept</code> 函数 </h3>
<p>服务器调用 <code>accept</code> 函数等待来自客户端的连接请求到达<strong>监听描述符</strong>（listening descriptor），然后在 <code>addr</code> 中填写客户端的套接字地址，返回一个<strong>已连接描述符</strong>（connected descriptor）。</p>
<p>已连接描述符可以用来利用 Unix I/O 函数和客户端通信，它是临时的，需要在通信完毕后调用 <code>close</code> 关闭。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为非负描述符，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">,</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span><span class="token operator">*</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>监听描述符是客户端连接请求的一个端点，通常<strong>只被创建一次</strong>，存在于<strong>服务器的整个生命周期</strong>。</p>
<p>已连接描述符是客户端和服务器之间已经建立起来的连接的一个端点。<strong>服务器每次接受连接请求时都会被创建</strong>，只存在于<strong>服务器为一个客户端服务的过程中</strong>。</p>
<p><img src="./note-part2_files/11-14-监听描述符和已连接描述符.png" alt=""></p>
<p>客户端和服务器建立连接的过程：</p>
<ol>
<li>服务器调用 <code>accept</code>，等待连接请求到达监听描述符 <code>listenfd</code>（假设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>）</li>
<li>客户端调用 <code>connect</code>，向服务器发送一个连接请求</li>
<li><code>accept</code> 函数打开了一个新的<strong>已连接描述符</strong> <code>connfd</code>（假设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>），在 <code>clientfd</code> 和 <code>connfd</code> 之间建立连接，并返回 <code>connfd</code> 给应用程序。客户端也从 <code>connect</code> 返回。</li>
<li>此后，客户端和服务器就可以分别读写 <code>clientfd</code> 和 <code>connfd</code> 来回传送数据了</li>
</ol>
<blockquote>
<p>区别监听描述符和已连接描述符是很有必要的，它可以是我们建立并发服务器，同时处理许多客户端连接。</p>
</blockquote>
<h3 id="close-函数"><code>close</code> 函数 </h3>
<p>客户端和服务器调用 <code>close</code> 函数关闭一个套接字描述符。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果 <code>fd</code> 是 TCP 套接字描述符，调用 <code>close</code> 会引起<strong>本地进程向远程进程发送关闭连接的消息</strong>，连接关闭后，相关的资源被释放。</p>
<h3 id="主机和服务的转换">主机和服务的转换 </h3>
<h4 id="getaddrinfo-函数"><code>getaddrinfo</code> 函数 </h4>
<p><code>getaddrinfo</code> 将主机名、主机地址、服务名和端口号的字符串表示转化成 <code>sockaddr</code> 结构体。它是已弃用的 <code>gethostbyname</code> 和 <code>getservbyname</code> 的替代。</p>
<p><code>getaddrinfo</code> 是<strong>可重入</strong>的，适用于各种协议。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为非 0 的错误代码</span>
<span class="token keyword keyword-int">int</span> <span class="token function">getaddrinfo</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> host<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> service<span class="token punctuation">,</span>
                <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> hints<span class="token punctuation">,</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span><span class="token operator">*</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：无</span>
<span class="token keyword keyword-void">void</span> <span class="token function">freeaddrinfo</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：错误消息</span>
<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">gai_strerror</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> errcode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>result</code> 是一个指向 <code>struct addrinfo*</code> 类型的指针，或者说，一个指向 <code>addrinfo</code> 链表的指针。</p>
<p><code>getaddrinfo</code> 会在函数体内<strong>为 <code>*result</code> 赋值</strong>，如果将可能为 <code>NULL</code> 的 <code>result</code> 传给 <code>getaddrinfo</code>，那么就会触发 segfault。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// correct usage</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span> <span class="token operator">*</span>results<span class="token punctuation">;</span>
<span class="token function">getaddrinfo</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token string">"http"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>addrinfo</code> 结构体定义如下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> ai_flags<span class="token punctuation">;</span>           <span class="token comment">// Hints argument flags</span>
    <span class="token keyword keyword-int">int</span> ai_family<span class="token punctuation">;</span>          <span class="token comment">// First arg to socket function</span>
    <span class="token keyword keyword-int">int</span> ai_socktype<span class="token punctuation">;</span>        <span class="token comment">// Second arg to socket function</span>
    <span class="token keyword keyword-int">int</span> ai_protocol<span class="token punctuation">;</span>        <span class="token comment">// Third arg to socket function</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> ai_canonname<span class="token punctuation">;</span>     <span class="token comment">// Canonical hostname</span>
    <span class="token class-name">size_t</span> ai_addrlen<span class="token punctuation">;</span>      <span class="token comment">// Size of ai_addr struct</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> ai_addr<span class="token punctuation">;</span>   <span class="token comment">// Ptr to socket address structure</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> ai_next<span class="token punctuation">;</span>   <span class="token comment">// Next in linked list</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p><img src="./note-part2_files/11-15-addrinfo.png" alt=""></p>
<p><code>result</code> 指向的链表中，每个 <code>addrinfo</code> 结构体的 <code>ai_addr</code> 字段指向一个 <code>sockaddr</code> 结构体。</p>
<p>为了避免内存泄漏，必须调用 <code>freeaddrinfo</code> 释放 <code>getaddrinfo</code> 分配的内存。</p>
<p>如果 <code>getaddrinfo</code> 返回非零的错误代码，可以调用 <code>gai_strerror</code> 打印对应的错误消息。</p>
<p><code>host</code> 参数可以是域名，也可以是点分十进制的 IP 地址。<code>service</code> 参数可以是服务名（如 <code>http</code>），也可以是十进制端口号。如果不想将主机名转换成地址，可以将 <code>host</code> 设为 <code>NULL</code>；如果不想将服务名转换成端口号，也可以将 <code>service</code> 设为 <code>NULL</code>，但不能同时将两者都设为 <code>NULL</code>。</p>
<p><code>hints</code> 参数是可选的，它提供对返回的链表更好的控制。传递的 <code>hints</code> 参数指向的结构体只能设置以下字段，其余字段必须被置零：</p>
<ul>
<li><code>ai_family</code>：设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AF_INET</mtext></mrow><annotation encoding="application/x-tex">\text{AF\_INET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AF_INET</span></span></span></span></span> 将限制为 IPv4 地址，设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AF_INET6</mtext></mrow><annotation encoding="application/x-tex">\text{AF\_INET6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AF_INET6</span></span></span></span></span> 将限制为 IPv6 地址</li>
<li><code>ai_socktype</code>：<code>getaddrinfo</code> 默认最多返回三个 <code>addrinfo</code> 结构体，它们的 <code>ai_socktype</code> 字段不同：一个是连接，一个是数据报，一个是原始套接字。设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SOCK_STREAM</mtext></mrow><annotation encoding="application/x-tex">\text{SOCK\_STREAM}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SOCK_STREAM</span></span></span></span></span> 将限制为对每个地址最多一个 <code>addrinfo</code> 结构体，对应连接。</li>
<li><code>ai_flags</code>：一个位掩码，包括以下标志，它们可以用或运算组合：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AI_ADDRCONFIG</mtext></mrow><annotation encoding="application/x-tex">\text{AI\_ADDRCONFIG}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AI_ADDRCONFIG</span></span></span></span></span>：对于连接来说推荐。只返回适用于主机的地址，主机是 IPv4，就只返回 IPv4 地址；主机是 IPv6，就只返回 IPv6 地址。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AI_CANONNAME</mtext></mrow><annotation encoding="application/x-tex">\text{AI\_CANONNAME}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AI_CANONNAME</span></span></span></span></span>：<code>ai_canonname</code> 字段默认为 <code>NULL</code>，设置此标志将使得 <code>getaddrinfo</code> 将链表中首个 <code>addrinfo</code> 结构体的 <code>ai_canonname</code> 置为主机的规范名（canonical name）。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AI_NUMERICSERV</mtext></mrow><annotation encoding="application/x-tex">\text{AI\_NUMERICSERV}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AI_NUMERICSERV</span></span></span></span></span>：<code>service</code> 参数默认为服务名或端口号，此标志强制 <code>service</code> 参数为端口号。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AI_PASSIVE</mtext></mrow><annotation encoding="application/x-tex">\text{AI\_PASSIVE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AI_PASSIVE</span></span></span></span></span>：<code>getaddrinfo</code> 返回的默认为套接字地址，客户端可以在调用 <code>connect</code> 时将其用作主动套接字。设置此标志令 <code>getaddrinfo</code> 返回可以被服务器用作监听套接字的<strong>通配符地址</strong>（wildcard address），告诉内核这个服务器会接受发送到该主机所有 IP 地址的请求。此时，<code>host</code> 参数应为 <code>NULL</code></li>
</ul>
</li>
<li><code>ai_protocol</code></li>
</ul>
<p><code>getaddrinfo</code> 的一个重要好处在于 <code>addrinfo</code> 结构体的字段是<strong>不透明</strong>的，程序员可以直接将它们传递给套接字接口中的函数，使得代码可移植性更好。</p>
<p>客户端建立连接时，先调用 <code>getaddrinfo</code>，然后遍历返回的链表，依次对每个套接字地址尝试调用 <code>socket</code> 和 <code>connect</code>，直到成功建立连接。</p>
<p>服务器开始监听连接请求时，也先调用 <code>getaddrinfo</code>，遍历这个链表，依次对每个套接字地址尝试调用 <code>socket</code> 和 <code>bind</code>，直到描述符被绑定到合法的套接字地址。</p>
<h4 id="getnameinfo-函数"><code>getnameinfo</code> 函数 </h4>
<p><code>getnameinfo</code> 将 <code>sockaddr</code> 结构体转换成主机名和服务名。它是已弃用的 <code>gethostbyaddr</code> 和 <code>getservbyport</code> 的替代。</p>
<p><code>getnameinfo</code> 是<strong>可重入</strong>的，适用于各种协议。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为非 0 的错误代码</span>
<span class="token keyword keyword-int">int</span> <span class="token function">getnameinfo</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> sa<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> salen<span class="token punctuation">,</span>
                <span class="token keyword keyword-char">char</span><span class="token operator">*</span> host<span class="token punctuation">,</span> <span class="token class-name">size_t</span> hostlen<span class="token punctuation">,</span>
                <span class="token keyword keyword-char">char</span><span class="token operator">*</span> service<span class="token punctuation">,</span> <span class="token class-name">size_t</span> servlen<span class="token punctuation">,</span>
                <span class="token keyword keyword-int">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>getnameinfo</code> 函数将 <code>sa</code> 指向的 <code>sockaddr</code> 结构体转换成主机名和服务名，存放在 <code>host</code> 和 <code>service</code> 中。</p>
<p>如果 <code>getnameinfo</code> 返回非零的错误代码，可以调用 <code>gai_strerror</code> 打印对应的错误消息。</p>
<p>如果不想要主机名，可以将 <code>host</code> 置为 <code>NULL</code>，将 <code>hostlen</code> 置为 <code>0</code>；如果不想要服务名，可以将 <code>service</code> 置为 <code>NULL</code>，将 <code>servlen</code> 置为 <code>0</code>，但不能同时将两者都置为 <code>NULL</code>。</p>
<p><code>flags</code> 是一个位掩码，包括以下标志，它们可以用或运算组合：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>NI_NUMERICHOST</mtext></mrow><annotation encoding="application/x-tex">\text{NI\_NUMERICHOST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">NI_NUMERICHOST</span></span></span></span></span>：<code>getnameinfo</code> 默认返回 <code>host</code> 的域名，设置此标志将使得 <code>getnameinfo</code> 返回 <code>host</code> 的点分十进制 IP 地址</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>NI_NUMERICSERV</mtext></mrow><annotation encoding="application/x-tex">\text{NI\_NUMERICSERV}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">NI_NUMERICSERV</span></span></span></span></span>：<code>getnameinfo</code> 默认检查 <code>/etc/services</code>，优先返回 <code>service</code> 的服务名，设置此标志将使得 <code>getnameinfo</code> 跳过查找，直接返回 <code>service</code> 的端口号</li>
</ul>
<p>以下示例程序使用 <code>getaddrinfo</code> 和 <code>gethostinfo</code> 展示域名和它关联的 IP 地址的映射，类似于 <code>nslookup</code>：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> listp<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span> hints<span class="token punctuation">;</span>

    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> rc<span class="token punctuation">,</span> flags<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;domain name&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Get a list of addrinfo records */</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hints<span class="token punctuation">.</span>ai_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>  <span class="token comment">/* IPv4 only */</span>
    hints<span class="token punctuation">.</span>ai_socktype <span class="token operator">=</span> SOCK_STREAM<span class="token punctuation">;</span>  <span class="token comment">/* Connections only */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">getaddrinfo</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token operator">&amp;</span>listp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"getaddrinfo error: %s\n"</span><span class="token punctuation">,</span> <span class="token function">gai_strerror</span><span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Walk the list and display each IP address */</span>
    flags <span class="token operator">=</span> NI_NUMERICHOST<span class="token punctuation">;</span>  <span class="token comment">/* Display address string instead of domain name */</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> listp<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>ai_next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Getnameinfo</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ai_addr<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_addrlen<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Clean up */</span>
    <span class="token function">Freeaddrinfo</span><span class="token punctuation">(</span>listp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="套接字接口的辅助函数">套接字接口的辅助函数 </h3>
<h4 id="open_clientfd-函数"><code>open_clientfd</code> 函数 </h4>
<p>客户端调用 <code>open_clientfd</code> 与运行在 <code>hostname</code> 主机上、通过端口号 <code>port</code> 监听连接请求的服务器进程建立连接。它返回一个打开的套接字描述符，可以用 Unix I/O 函数进行读写。</p>
<p>以上的代码与 IP 版本无关，是干净可移植的。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token comment">// 返回：若成功则为套接字描述符，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">open_clientfd</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> hostname<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> clientfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span> hints
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> listp<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> p<span class="token punctuation">;</span>

    <span class="token comment">/* Get a list of potential server addresses */</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hints<span class="token punctuation">.</span>ai_socktype <span class="token operator">=</span> SOCK_STREAM<span class="token punctuation">;</span>  <span class="token comment">/* Open a connection */</span>
    hints<span class="token punctuation">.</span>ai_flags <span class="token operator">=</span> AI_NUMERICSERV<span class="token punctuation">;</span>  <span class="token comment">/* ... using a numeric port arg. */</span>
    hints<span class="token punctuation">.</span>ai_flags <span class="token operator">|=</span> AI_ADDRCONFIG<span class="token punctuation">;</span>  <span class="token comment">/* Recommended for connections */</span>
    <span class="token function">Getaddrinfo</span><span class="token punctuation">(</span>hostname<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token operator">&amp;</span>listp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Walk the list for one that we can successfully connect to */</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> listp<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>ai_next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Create a socket descriptor */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clientfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ai_family<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_socktype<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_protocol<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>  <span class="token comment">/* Socket failed, try the next */</span>

        <span class="token comment">/* Connect to the server */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_addr<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_addrlen<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>  <span class="token comment">/* Success */</span>

        <span class="token function">Close</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Connect failed, try another */</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Clean up */</span>
    <span class="token function">Freeaddrinfo</span><span class="token punctuation">(</span>listp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>  <span class="token comment">/* All connects failed */</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span>  <span class="token comment">/* The last connect succeeded */</span>
        <span class="token keyword keyword-return">return</span> clientfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="open_listenfd-函数"><code>open_listenfd</code> 函数 </h4>
<p>服务器调用 <code>open_listenfd</code> 打开一个与 <code>port</code> 端口关联的监听描述符，它监听来自任意 IP 地址的客户端的连接请求。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token comment">// 返回：若成功则为监听描述符，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">open_listenfd</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span> hints<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> listp<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">,</span> optval <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/* Get a list of potential server addresses */</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">addrinfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hints<span class="token punctuation">.</span>ai_socktype <span class="token operator">=</span> SOCK_STREAM<span class="token punctuation">;</span>  <span class="token comment">/* Accept connections */</span>
    hints<span class="token punctuation">.</span>ai_flags <span class="token operator">=</span> AI_PASSIVE <span class="token operator">|</span> AI_ADDRCONFIG<span class="token punctuation">;</span>  <span class="token comment">/* ... on any IP address */</span>
    hints<span class="token punctuation">.</span>ai_flags <span class="token operator">|=</span> AI_NUMERICSERV<span class="token punctuation">;</span>  <span class="token comment">/* ... using port number */</span>
    <span class="token function">Getaddrinfo</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hints<span class="token punctuation">,</span> <span class="token operator">&amp;</span>listp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Walk the list for one that we can bind to */</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> listp<span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>ai_next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Create a socket descriptor */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ai_family<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_socktype<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_protocol<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>  <span class="token comment">/* Socket failed, try the next */</span>

        <span class="token comment">/* Eliminates "Address already in use" error from bind */</span>
        <span class="token function">Setsockopt</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>optval<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Bind the descriptor to the address */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_addr<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>ai_addrlen<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>  <span class="token comment">/* Success */</span>

        <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Bind failed, try the next */</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Clean up */</span>
    <span class="token function">Freeaddrinfo</span><span class="token punctuation">(</span>listp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>  <span class="token comment">/* No address worked */</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/* Make it a listening socket ready to accept connection requests */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> listenfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>我们使用了 <code>setsockopt</code> 函数配置服务器，使得服务器可以被立即终止、重启，并且可以立即开始接受连接请求。一个重启的服务器默认将在约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">30</span></span></span></span> 秒内开始拒绝客户端的连接请求，这不利于调试。</p>
<p>我们使用了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>AI_PASSIVE</mtext></mrow><annotation encoding="application/x-tex">\text{AI\_PASSIVE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">AI_PASSIVE</span></span></span></span></span> 标志，并将 <code>host</code> 置为了 <code>NULL</code>，这使得 <code>getaddrinfo</code> 返回一个通配符地址，告诉内核这个服务器会接受发送到该主机所有 IP 地址的请求。</p>
<h3 id="echo-客户端和服务器的示例">echo 客户端和服务器的示例 </h3>
<p>echo 客户端先和服务器建立连接，然后进入循环，反复从标准输入读取文本行，发送给服务器，再从服务器接收回送的文本行，打印到标准输出。</p>
<p>当 <code>fgets</code> 在标准输入中遇到 EOF，或用户键入 <code>Ctrl+D</code> 时，循环终止，客户端关闭套接字描述符，这会发送一个 EOF 通知给服务器。</p>
<p>对于此程序，实际上不需要显式地调用 <code>Close</code> 来关闭套接字描述符，因为程序终止时，客户端的内核会自动将其关闭。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> clientfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> host<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> port<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">rio_t</span> rio<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;host&gt; &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    host <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    port <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    clientfd <span class="token operator">=</span> <span class="token function">Open_clientfd</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_readinitb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> clientfd<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">Fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Rio_writen</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Fputs</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Close</span><span class="token punctuation">(</span>clientfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>echo 服务器先打开一个监听描述符，然后进入循环，等待一个来自客户端的连接请求，输出连接到的客户端的域名和 IP 地址，并调用 <code>echo</code> 函数为它们提供服务。</p>
<p>我们将 <code>clientaddr</code> 声明成了 <code>struct sockaddr_storage</code>（而不是 <code>struct sockaddr_in</code>），这是一个足够大的结构体，可以容纳任何套接字地址，使得代码协议无关。</p>
<p>此服务器一次只能处理一个客户端，即它一次一个地在客户端之间迭代，称为<strong>迭代服务器</strong>（iterative server）</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> n<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">rio_t</span> rio<span class="token punctuation">;</span>

    <span class="token function">Rio_readinitb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"server received %d bytes\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Rio_writen</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>    <span class="token comment">// Enough space for any address</span>
    <span class="token keyword keyword-char">char</span> client_hostname<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> client_port<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Getnameinfo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> clientlen<span class="token punctuation">,</span> client_hostname<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> client_port<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Connected to (%s, %s)\n"</span><span class="token punctuation">,</span> client_hostname<span class="token punctuation">,</span> client_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">echo</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><blockquote>
<p>并不存在 EOF 字符。EOF 是内核检测的一种条件。应用程序在调用 <code>read</code> 得到零返回值时、读磁盘文件超出文件长度时、Internet 连接时进程关闭套接字描述符时，都会发生 EOF 条件。</p>
</blockquote>
<h2 id="web-服务器">Web 服务器 </h2>
<h3 id="web-基础">Web 基础 </h3>
<p>Web 客户端和服务器之间使用 <strong>HTTP</strong>（HyperText Transfer Protocol）协议通信。</p>
<p>Web 客户端（浏览器）打开一个到服务器的 Internet 连接，请求某些<strong>内容</strong>。服务器响应此请求，关闭连接。浏览器读取这些内容，将它们显示在屏幕上。</p>
<p>Web 内容可以用 <strong>HTML</strong>（HyperText Markup Language）编写，它是一种用于描述文档的标记语言。HTML 可以包含超链接，指向存放在任何 Internet 主机上的内容。</p>
<blockquote>
<p>万维网（World Wide Web）由 Tim Berners-Lee 在 1989 年发明，是一种基于超文本的分布式信息系统。</p>
</blockquote>
<h3 id="web-内容">Web 内容 </h3>
<p><strong>内容</strong>是一个与 MIME（Multipurpose Internet Mail Extensions）类型相关联的字节序列。</p>
<p>常用的 MIME 类型：</p>
<ul>
<li><code>text/html</code>：HTML 页面</li>
<li><code>text/plain</code>：纯文本</li>
<li><code>application/postscript</code>：PostScript 文档</li>
<li><code>image/jpeg</code>：JPEG 图像</li>
<li><code>image/gif</code>：GIF 图像</li>
<li><code>image/png</code>：PNG 图像</li>
</ul>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件（称为<strong>静态内容</strong>，static content），将其内容返回给客户端（称为<strong>服务静态内容</strong>，serving static content）。</li>
<li>运行一个可执行文件，将其输出（称为动态内容，dynamic content）返回给客户端（称为<strong>服务动态内容</strong>，serving dynamic content）。</li>
</ul>
<p>由 Web 服务器返回的内容都与它管理的某个文件关联，每个这样的文件都被一个唯一的 <strong>URL</strong>（Universal Resource Locator）标识。例如，以下 URL 标识 Internet 主机 <code>www.google.com</code> 上的 <code>/index.html</code> 文件，它受到监听端口为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>80</mn></mrow><annotation encoding="application/x-tex">80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">80</span></span></span></span> 的 Web 服务器的管理。<strong>端口号是可选的</strong>，默认为知名的 HTTP 端口号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>80</mn></mrow><annotation encoding="application/x-tex">80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">80</span></span></span></span>。</p>
<pre data-role="codeBlock" data-info="md" class="language-gfm md"><code>http://www.google.com:80/index.html
</code></pre><p>可执行文件的 URL 可以在文件名之后包含程序参数。<code>?</code> 分隔文件名和参数，<code>&amp;</code> 分隔两个参数。例如，以下 URL 标识了可执行文件 <code>/cgi-bin/adder</code>，它会被以参数 <code>15000</code> 和 <code>213</code> 调用。</p>
<pre data-role="codeBlock" data-info="md" class="language-gfm md"><code>http://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213
</code></pre><p>事务过程中，客户端使用 URL 的前缀部分（如 <code>http://www.google.com:80</code>）来决定与什么服务器的什么端口建立连接。服务器通过 URL 的后缀部分（如 <code>/index.html</code>）来寻找它文件系统中的文件。</p>
<p><strong>没有标准的规则来确定一个 URL 指向的是静态内容还是动态内容</strong>。经典的方法是指定一组目录，所有可执行文件必须存放在这些目录中</p>
<p>URL 后缀中开头的 <code>/</code> 不表示 Linux 根目录。它表示被请求内容类型的主目录。例如，可以将所有静态内容存放在 <code>/usr/httpd/html</code>，将所有动态内容存放在 <code>/usr/httpd/cgi-bin</code>。</p>
<p>最小的 URL 后缀是 <code>/</code>，所有服务器将其扩展成某个默认的主页，例如 <code>/index.html</code>。当用户只输入了一个域名时，浏览器在 URL 后添加 <code>/</code>，然后发送请求，服务器又将 <code>/</code> 扩展到它默认的文件名</p>
<h3 id="http-事务">HTTP 事务 </h3>
<p>HTTP 基于在 Internet 连接上传送的文本行，可以使用 Linux <code>telnet</code> 程序和 Internet 上的任何 Web 服务器交互。</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>telnet www.aol.com <span class="token number">80</span>
Trying <span class="token number">205.188</span>.146.23<span class="token punctuation">..</span>.
Connected to aol.com.
Escape character is <span class="token string">'^]'</span><span class="token builtin class-name">.</span>
GET / HTTP/1.0
Host: www.aol.com

HTTP/1.0 <span class="token number">200</span> OK
MIME-Version: <span class="token number">1.0</span>
Date: Mon, <span class="token number">8</span> Jan <span class="token number">2010</span> <span class="token number">4</span>:59:42 GMT
Server: Apache-Coyote/1.1
Content-Type: text/html
Content-Length: <span class="token number">42092</span>

<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
<span class="token punctuation">..</span>.
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
Connection closed by foreign host.
</code></pre><p>HTTP 标准要求每个文本行以 <code>\r\n</code> 结尾。每次输入一个文本行后，<code>telnet</code> 会读取该行，并在后面追加 <code>\r\n</code>，然后发送给服务器。</p>
<h4 id="http-请求">HTTP 请求 </h4>
<p>一个 HTTP <strong>请求</strong>（request）包括：</p>
<ul>
<li><strong>请求行</strong>（request line）：形如 <code>method URI version</code></li>
<li>零个或多个<strong>请求报头</strong>（request header）：形如 <code>header-name: header-data</code></li>
<li>空文本行，表示报头终止</li>
</ul>
<p>HTTP 支持多种<strong>方法</strong>（method），包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>GET</mtext><mo separator="true">,</mo><mtext>POST</mtext><mo separator="true">,</mo><mtext>OPTIONS</mtext><mo separator="true">,</mo><mtext>HEAD</mtext><mo separator="true">,</mo><mtext>PUT</mtext><mo separator="true">,</mo><mtext>DELETE</mtext><mo separator="true">,</mo><mtext>TRACE</mtext></mrow><annotation encoding="application/x-tex">\text{GET}, \text{POST}, \text{OPTIONS}, \text{HEAD}, \text{PUT}, \text{DELETE}, \text{TRACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">GET</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">POST</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">OPTIONS</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">HEAD</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">PUT</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">DELETE</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">TRACE</span></span></span></span></span>。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>GET</mtext></mrow><annotation encoding="application/x-tex">\text{GET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">GET</span></span></span></span></span> 方法指导服务器生成并返回 URI（Uniform Resource Identifier）标识的内容。URI 是相应 URL 的后缀（对于浏览器如此，代理服务器请求内容时需要使用完整的 URL）。</p>
<p>请求行中的 <code>version</code> 字段表明 HTTP 版本，最新版本为 HTTP/1.1。HTTP/1.1 定义了一些附加报头，支持缓冲、安全等高级特性，还允许客户端和服务器在同一条<strong>持久连接</strong>（persistent connection）上执行多个事务。两个版本互相兼容，HTTP/1.0 的客户端会简单忽略 HTTP/1.1 报头。</p>
<p>上例中的请求行向服务器请求 <code>/</code>，即 <code>/index.html</code>。</p>
<p>请求报头为服务器提供额外信息。<code>Host</code> 报头只在 HTTP/1.1 中是需要的。</p>
<p><strong>代理缓存</strong>（proxy cache）会使用 <code>Host</code> 报头，它有时作为浏览器和管理被请求文件的<strong>原始服务器</strong>（origin server）的中介。客户端和原始服务器之间可以由多个代理，即<strong>代理链</strong>（proxy chain）。<code>Host</code> 报头中的数据指示了原始服务器的域名，代理可以利用它判断是否可以在本地缓存中拥有一个被请求内容的副本。</p>
<h4 id="http-响应">HTTP 响应 </h4>
<p>一个 HTTP <strong>响应</strong>（response）包括：</p>
<ul>
<li><strong>响应行</strong>（response line）：形如 <code>version status-code status-message</code></li>
<li>零个或多个<strong>响应报头</strong>（response header）：形如 <code>header-name: header-data</code></li>
<li>空文本行，表示报头终止</li>
<li><strong>响应主体</strong>（response body）：响应的内容</li>
</ul>
<p>对于响应行，<code>version</code> 字段描述响应的 HTTP 版本。<strong>状态码</strong>（status-code）是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 位正整数，指明对请求的处理结果。<strong>状态消息</strong>（status message）给出状态码的描述。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">状态消息</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">OK</td>
<td style="text-align:left">请求成功</td>
</tr>
<tr>
<td style="text-align:center">301</td>
<td style="text-align:center">Moved Permanently</td>
<td style="text-align:left">内容已移动到 location 头中指明的主机</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">Bad Request</td>
<td style="text-align:left">错误请求</td>
</tr>
<tr>
<td style="text-align:center">403</td>
<td style="text-align:center">Forbidden</td>
<td style="text-align:left">服务器无权访问所请求的文件</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:center">Not Found</td>
<td style="text-align:left">服务器无法找到所请求的文件</td>
</tr>
<tr>
<td style="text-align:center">501</td>
<td style="text-align:center">Not Implemented</td>
<td style="text-align:left">服务器不支持所请求的方法</td>
</tr>
<tr>
<td style="text-align:center">505</td>
<td style="text-align:center">HTTP Version Not Supported</td>
<td style="text-align:left">服务器不支持请求的 HTTP 版本</td>
</tr>
</tbody>
</table>
<h3 id="服务动态内容">服务动态内容 </h3>
<p><strong>CGI</strong>（Common Gateway Interface，通用网关接口）定义了服务器提供动态内容的标准方法。</p>
<h4 id="客户端将程序参数传递给服务器">客户端将程序参数传递给服务器 </h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>GET</mtext></mrow><annotation encoding="application/x-tex">\text{GET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">GET</span></span></span></span></span> 请求的参数在 URI 中传递。参数中不允许空格，空格用 <code>%20</code> 表示。其他特殊字符也有特殊的编码。</p>
<blockquote>
<p>HTTP <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>POST</mtext></mrow><annotation encoding="application/x-tex">\text{POST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">POST</span></span></span></span></span> 请求的参数在请求主体中传递，而不是 URI</p>
</blockquote>
<h4 id="服务器将参数传递给子进程">服务器将参数传递给子进程 </h4>
<p>服务器接收到如下的请求后：</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash bash"><code>GET /cgi-bin/adder?15000<span class="token operator">&amp;</span><span class="token number">213</span> HTTP/1.1
</code></pre><p>它调用 <code>fork</code> 创建子进程，将子进程中的 CGI 环境变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>QUERY_STRING</mtext></mrow><annotation encoding="application/x-tex">\text{QUERY\_STRING}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">QUERY_STRING</span></span></span></span></span> 设置为 <code>15000&amp;213</code>， 并调用 <code>execve</code> 加载程序。<code>adder</code> 可以在运行时用 Linux <code>getenv</code> 函数引用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>QUERY_STRING</mtext></mrow><annotation encoding="application/x-tex">\text{QUERY\_STRING}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">QUERY_STRING</span></span></span></span></span>。</p>
<p><code>adder</code> 这类程序遵守 CGI 标准，常被称为 <strong>CGI 程序</strong>。很多 CGI 程序由 Perl 脚本编写，也常被称为 CGI 脚本。</p>
<h4 id="服务器如何将其他信息传递给子进程">服务器如何将其他信息传递给子进程 </h4>
<p>CGI 定义了大量的环境变量。</p>
<table>
<thead>
<tr>
<th style="text-align:center">环境变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>QUERY_STRING</mtext></mrow><annotation encoding="application/x-tex">\text{QUERY\_STRING}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">QUERY_STRING</span></span></span></span></span></td>
<td style="text-align:left">程序参数</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SERVER_PORT</mtext></mrow><annotation encoding="application/x-tex">\text{SERVER\_PORT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">SERVER_PORT</span></span></span></span></span></td>
<td style="text-align:left">父进程监听的端口号</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>REQUEST_METHOD</mtext></mrow><annotation encoding="application/x-tex">\text{REQUEST\_METHOD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">REQUEST_METHOD</span></span></span></span></span></td>
<td style="text-align:left">请求方法</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>REMOTE_HOST</mtext></mrow><annotation encoding="application/x-tex">\text{REMOTE\_HOST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">REMOTE_HOST</span></span></span></span></span></td>
<td style="text-align:left">客户端域名</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>REMOTE_ADDR</mtext></mrow><annotation encoding="application/x-tex">\text{REMOTE\_ADDR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">REMOTE_ADDR</span></span></span></span></span></td>
<td style="text-align:left">客户端点分十进制 IP 地址</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>CONTENT_TYPE</mtext></mrow><annotation encoding="application/x-tex">\text{CONTENT\_TYPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">CONTENT_TYPE</span></span></span></span></span></td>
<td style="text-align:left">只对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>POST</mtext></mrow><annotation encoding="application/x-tex">\text{POST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">POST</span></span></span></span></span> 有意义：请求体的 MIME 类型</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>CONTENT_LENGTH</mtext></mrow><annotation encoding="application/x-tex">\text{CONTENT\_LENGTH}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">CONTENT_LENGTH</span></span></span></span></span></td>
<td style="text-align:left">只对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>POST</mtext></mrow><annotation encoding="application/x-tex">\text{POST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">POST</span></span></span></span></span> 有意义：请求体的字节长度</td>
</tr>
</tbody>
</table>
<h4 id="子进程将其输出发送到哪里">子进程将其输出发送到哪里 </h4>
<p>CGI 程序将它的动态内容发送到标准输出。但在 CGI 程序被子进程加载并运行之前，标准输出会被<strong>重定向到客户端的已连接描述符</strong>。因此，CGI 程序的输出会被发送到客户端。</p>
<p>父进程不知道子进程内容的类型和大小，子进程需要负责生成 <code>Content-type</code> 和 <code>Content-length</code> 响应报头，以及终止报头的空行。</p>
<p>以下为一个 CGI 程序示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> buf<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> arg1<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> arg2<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> content<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> n1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">/* Extract the two arguments */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>buf <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"QUERY_STRING"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token char">'&amp;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>arg2<span class="token punctuation">,</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        n1 <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n2 <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Make the response body */</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"QUERY_STRING=%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"Welcome to add.com: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"%sTHE Internet addition portal.\r\n&lt;p&gt;"</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"%sThe answer is: %d + %d = %d\r\n&lt;p&gt;"</span><span class="token punctuation">,</span> content<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n1<span class="token operator">+</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"%sThanks for visiting!\r\n"</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Generate the HTTP response */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Connection: close\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Content-length: %d\r\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Content-type: text/html\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><blockquote>
<p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>POST</mtext></mrow><annotation encoding="application/x-tex">\text{POST}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">POST</span></span></span></span></span> 请求，子进程也需要重定向标准输入到已连接描述符。之后，CGI 程序从标准输入读取请求体。</p>
</blockquote>
<h2 id="综合tiny-web-服务器">综合：TINY Web 服务器 </h2>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
 *     GET method to serve static and dynamic content.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">doit</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">read_requesthdrs</span><span class="token punctuation">(</span><span class="token class-name">rio_t</span><span class="token operator">*</span> rp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">parse_uri</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> uri<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> cgiargs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">serve_static</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> filesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">get_filetype</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">serve_dynamic</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> cgiargs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">clienterror</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> cause<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> errnum<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> shortmsg<span class="token punctuation">,</span>
                 <span class="token keyword keyword-char">char</span><span class="token operator">*</span> longmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">doit</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> is_static<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span> sbuf<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> method<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> uri<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> version<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> filename<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> cgiargs<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">rio_t</span> rio<span class="token punctuation">;</span>

    <span class="token comment">/* Read request line and headers */</span>
    <span class="token function">Rio_readinitb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// read request line</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Request headers:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sscanf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%s %s %s"</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> uri<span class="token punctuation">,</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clienterror</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token string">"501"</span><span class="token punctuation">,</span> <span class="token string">"Not Implemented"</span><span class="token punctuation">,</span>
                    <span class="token string">"Tiny does not implement this method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">read_requesthdrs</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Parse URI from GET request */</span>
    is_static <span class="token operator">=</span> <span class="token function">parse_uri</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> cgiargs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sbuf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clienterror</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token string">"404"</span><span class="token punctuation">,</span> <span class="token string">"Not found"</span><span class="token punctuation">,</span>
                    <span class="token string">"Tiny couldn't find this file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>is_static<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Serve static content */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">S_ISREG</span><span class="token punctuation">(</span>sbuf<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>S_IRUSR <span class="token operator">&amp;</span> sbuf<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clienterror</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token string">"403"</span><span class="token punctuation">,</span> <span class="token string">"Forbidden"</span><span class="token punctuation">,</span>
                        <span class="token string">"Tiny couldn't read the file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">serve_static</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> sbuf<span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span> <span class="token comment">/* Serve dynamic content */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">S_ISREG</span><span class="token punctuation">(</span>sbuf<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>S_IXUSR <span class="token operator">&amp;</span> sbuf<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clienterror</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token string">"403"</span><span class="token punctuation">,</span> <span class="token string">"Forbidden"</span><span class="token punctuation">,</span>
                        <span class="token string">"Tiny couldn't run the CGI program"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">serve_dynamic</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> cgiargs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_requesthdrs</span><span class="token punctuation">(</span><span class="token class-name">rio_t</span><span class="token operator">*</span> rp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span>rp<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// if not empty line</span>
        <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span>rp<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">parse_uri</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> uri<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> cgiargs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strstr</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> <span class="token string">"cgi-bin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Static content */</span>
        <span class="token comment">// cgiargs = ""</span>
        <span class="token comment">// filename = ".{uri}"</span>
        <span class="token comment">// if uri ends with '/', then filename = ".{uri}home.html"</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>cgiargs<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">strcat</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>uri<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token function">strcat</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"home.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span> <span class="token comment">/* Dynamic content */</span>
        <span class="token comment">// uri = "{_filename}?{cgiargs}"</span>
        <span class="token comment">// filename = ".{_filename}"</span>
        ptr <span class="token operator">=</span> <span class="token function">index</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> <span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">strcpy</span><span class="token punctuation">(</span>cgiargs<span class="token punctuation">,</span> ptr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span>
            <span class="token function">strcpy</span><span class="token punctuation">(</span>cgiargs<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">strcat</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> uri<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">serve_static</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> filesize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> srcfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> srcp<span class="token punctuation">,</span> filetype<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">[</span>MAXBUF<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* Send response headers to client */</span>
    <span class="token function">get_filetype</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> filetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"HTTP/1.0 200 OK\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%sServer: Tiny Web Server\r\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%sConnection: close\r\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%sContent-length: %d\r\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> filesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%sContent-type: %s\r\n\r\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> filetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Response headers:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Send response body to client */</span>
    srcfd <span class="token operator">=</span> <span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    srcp <span class="token operator">=</span> <span class="token function">Mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> filesize<span class="token punctuation">,</span> PROT_READ<span class="token punctuation">,</span> MAP_PRIVATE<span class="token punctuation">,</span> srcfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Close</span><span class="token punctuation">(</span>srcfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Don't forget!</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> srcp<span class="token punctuation">,</span> filesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Munmap</span><span class="token punctuation">(</span>srcp<span class="token punctuation">,</span> filesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">get_filetype</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filetype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">".html"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filetype<span class="token punctuation">,</span> <span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">".gif"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filetype<span class="token punctuation">,</span> <span class="token string">"image/gif"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">".png"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filetype<span class="token punctuation">,</span> <span class="token string">"image/png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">".jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filetype<span class="token punctuation">,</span> <span class="token string">"image/jpeg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>filetype<span class="token punctuation">,</span> <span class="token string">"text/plain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">serve_dynamic</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> cgiargs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>emptylist<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/* Return first part of HTTP response */</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"HTTP/1.0 200 OK\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"Server: Tiny Web Server\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Child */</span>
        <span class="token comment">/* Real server would set all CGI vars here */</span>
        <span class="token function">setenv</span><span class="token punctuation">(</span><span class="token string">"QUERY_STRING"</span><span class="token punctuation">,</span> cgiargs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Redirect stdout to client */</span>
        <span class="token function">Execve</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> emptylist<span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Run CGI program */</span>
    <span class="token punctuation">}</span>
    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Parent waits for and reaps child */</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">clienterror</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> cause<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> errnum<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> shortmsg<span class="token punctuation">,</span>
                 <span class="token keyword keyword-char">char</span><span class="token operator">*</span> longmsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> body<span class="token punctuation">[</span>MAXBUF<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* Build the HTTP response body */</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span>
            <span class="token string">"%s&lt;body bgcolor="</span>
            <span class="token string">"ffffff"</span>
            <span class="token string">"&gt;\r\n"</span><span class="token punctuation">,</span>
            body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"%s%s: %s\r\n"</span><span class="token punctuation">,</span> body<span class="token punctuation">,</span> errnum<span class="token punctuation">,</span> shortmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"%s&lt;p&gt;%s: %s\r\n"</span><span class="token punctuation">,</span> body<span class="token punctuation">,</span> longmsg<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token string">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Print the HTTP response */</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"HTTP/1.0 %s %s\r\n"</span><span class="token punctuation">,</span> errnum<span class="token punctuation">,</span> shortmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"Content-type: text/html\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"Content-length: %d\r\n\r\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_writen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> body<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> hostname<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> port<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>

    <span class="token comment">/* Check command line args */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span> clientaddr<span class="token punctuation">;</span>
        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Getnameinfo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> clientlen<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> port<span class="token punctuation">,</span>
                    MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Accepted connection from (%s, %s)\n"</span><span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">doit</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>TINY 只支持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>GET</mtext></mrow><annotation encoding="application/x-tex">\text{GET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">GET</span></span></span></span></span> 方法。</p>
<p>我们为所有输出都使用健壮的 <code>rio_writen</code> 函数。</p>
<p>通过后缀判断文件类型并不靠谱。</p>
<p>我们没有考虑 CGI 程序遇到错误的可能性。</p>
<blockquote>
<p>如果服务器写一个已经被客户端关闭了的连接，那么第一次写会正常返回，但第二次写就会导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGPIPE</mtext></mrow><annotation encoding="application/x-tex">\text{SIGPIPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGPIPE</span></span></span></span></span> 信号。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGPIPE</mtext></mrow><annotation encoding="application/x-tex">\text{SIGPIPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGPIPE</span></span></span></span></span> 信号的默认行为是终止进程。如果捕获或忽略它，那么第二次写会返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，并将 <code>errno</code> 设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>EPIPE</mtext></mrow><annotation encoding="application/x-tex">\text{EPIPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">EPIPE</span></span></span></span></span>。<code>strerror</code> 和 <code>perror</code> 将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>EPIPE</mtext></mrow><annotation encoding="application/x-tex">\text{EPIPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">EPIPE</span></span></span></span></span> 解释为 <code>Broken pipe</code>。<br>
健壮的服务器必须捕获这些 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SIGPIPE</mtext></mrow><annotation encoding="application/x-tex">\text{SIGPIPE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SIGPIPE</span></span></span></span></span> 信号，并检查 <code>write</code> 调用是否产生错误。</p>
</blockquote>
<h1 id="并发编程">并发编程 </h1>
<p><strong>并发</strong>（concurrency）：逻辑控制流在时间上重叠。</p>
<p>操作系统为使用应用级并发的程序提供了三种实现并发的机制：</p>
<ul>
<li><strong>进程</strong>。控制流需要使用<strong>进程间通信</strong>（InterProcess communication, IPC）机制来交换信息。</li>
<li><strong>I/O 多路复用</strong>（I/O multiplexing）。应用程序在一个进程的上下文中显式地调度其逻辑流。逻辑流被模型化为状态机。</li>
<li><strong>线程</strong>（thread）。线程是运行在单一进程上下文的逻辑流，由内核调度。</li>
</ul>
<p>我们使用迭代 echo 服务器为例，介绍这三种并发机制。</p>
<h2 id="基于进程的并发编程">基于进程的并发编程 </h2>
<p>服务器每次通过 <code>accept</code> 接受某个客户端的连接请求后，派生一个子进程为该客户端服务。<strong>子进程关闭它的监听描述符</strong>，<strong>父进程关闭它的已连接描述符</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> sigchld_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">Fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">/* Child */</span>
            <span class="token function">Close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Child closes its listening socket */</span>
            <span class="token function">echo</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Child services client */</span>
            <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Child closes connection with client */</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Child exits */</span>
        <span class="token punctuation">}</span>
        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Parent closes connected socket (important!) */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="进程的优劣">进程的优劣 </h3>
<p>父子进程<strong>共享文件描述符表</strong>，但拥有独立的地址空间。一个进程不会不小心覆盖另一个进程的虚拟内存，这是一个明显的优点。</p>
<p>但独立的地址空间使得进程之间共享状态信息变得困难，我们不得不使用开销较大的 IPC 机制。</p>
<blockquote>
<p>Unix IPC 通常指所有允许进程和同一台主机的其他进程通信的技术，包括管道、FIFO、System V shared memory、System V semaphores。</p>
</blockquote>
<h2 id="基于-io-多路复用的并发编程">基于 I/O 多路复用的并发编程 </h2>
<p>如果需要服务器在服务客户端的同时，也能对用户从标准输入键入的命令做出响应，就需要使用 I/O 多路复用技术。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为描述符数目，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> n<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> fdset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>参数 <code>fdset</code> 指定了<strong>描述符集合</strong>。逻辑地，描述符集合被看作一个大小为 <code>n</code> 的位向量，每一位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 指示描述符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是否在集合中。</p>
<p><code>n</code> 指明描述符集合的最大基数，此处即 <code>fd_set</code> 的基数。</p>
<p><code>select</code> 函数阻塞，直到<strong>读集合</strong>（read set） <code>fdset</code> 中的某个描述符准备好开始读时（即当从该描述符读取一个字节的请求不会阻塞时）。</p>
<p><code>select</code> 将 <code>fdset</code> 修改为<strong>准备好集合</strong>（ready set），它包括已准备好的描述符。<code>select</code> 函数的返回值是准备好的描述符的数目。我们需要在每次调用 <code>select</code> 时都更新读集合。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 操作描述符集合的宏</span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Clear all bits in fdset */</span>
<span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Clear bit fd in fdset */</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Turn on bit fd in fdset */</span>
<span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Is bit fd in fdset on? */</span>
</code></pre><p>读集合由<strong>监听描述符和标准输入</strong>组成。我们调用 <code>select</code>。如果监听描述符准备好了，我们就调用 <code>accept</code> 接受连接请求。如果标准输入准备好了，我们就调用 <code>command</code> 处理命令。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>
    fd_set read_set<span class="token punctuation">,</span> ready_set<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Clear read set */</span>
    <span class="token function">FD_SET</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Add stdin to read set */</span>
    <span class="token function">FD_SET</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Add listenfd to read set */</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ready_set <span class="token operator">=</span> read_set<span class="token punctuation">;</span>
        <span class="token function">Select</span><span class="token punctuation">(</span>listenfd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ready_set<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ready_set<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ready_set<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">echo</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* EOF */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Process the input command */</span>
<span class="token punctuation">}</span>
</code></pre><p>以上服务器的一个缺点是，它一旦连接到某客户端，就会一直为该客户端服务，直到客户端关闭连接。此过程中，它不会响应从标准输入键入的命令。</p>
<p>可以使用更细粒度的多路复用，服务器每次循环至多只回送一个文本行。</p>
<blockquote>
<p>程序阻塞在 <code>select</code> 时，如果在标准输入键入 <code>Ctrl+D</code>（表示 EOF），也会导致 <code>select</code> 返回，此时准备好集合包含标准输入。</p>
</blockquote>
<h2 id="基于-io-多路复用的并发事件驱动服务器">基于 I/O 多路复用的并发事件驱动服务器 </h2>
<p>在<strong>事件驱动</strong>（event-driven）程序中，事件导致流向前推进。逻辑流被模型化为状态机（state machine），包括一组状态（state）、输入事件（input event）和转移（transition）。</p>
<p>对于每个新客户端 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，并发服务器创建状态机 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将它和已连接描述符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 绑定。状态机 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的初始状态是“等待 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 准备好读”，它的输入事件是“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 已准备好读”，转移是“从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 读取一个文本行”。</p>
<p>以下示例中，<code>select</code> 函数检测输入事件，<code>add_client</code> 函数创建新的逻辑流（状态机），<code>check_clients</code> 回送文本行，执行状态转移，并负责删除状态机。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token comment">/* A pool of connected descriptors */</span>
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> maxfd<span class="token punctuation">;</span>  <span class="token comment">/* Largest descriptor in read_set */</span>
    fd_set read_set<span class="token punctuation">;</span>  <span class="token comment">/* Set of all active descriptors */</span>
    fd_set ready_set<span class="token punctuation">;</span>  <span class="token comment">/* Subset of descriptors ready for reading */</span>
    <span class="token keyword keyword-int">int</span> nready<span class="token punctuation">;</span>  <span class="token comment">/* Number of ready descriptors from select */</span>
    <span class="token keyword keyword-int">int</span> maxi<span class="token punctuation">;</span>  <span class="token comment">/* Highwater index into client array */</span>
    <span class="token keyword keyword-int">int</span> clientfd<span class="token punctuation">[</span>FD_SETSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* Set of active descriptors */</span>
    <span class="token class-name">rio_t</span> clientrio<span class="token punctuation">[</span>FD_SETSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* Set of active read buffers */</span>
<span class="token punctuation">}</span> pool<span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> byte_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">/* Counts total bytes received by server */</span>

<span class="token keyword keyword-void">void</span> <span class="token function">init_pool</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">,</span> pool<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Initially, there are no connected descriptors */</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>maxi <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> FD_SETSIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        p<span class="token operator">-&gt;</span>clientfd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/* Initially, listenfd is only member of select read set */</span>
    p<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> listenfd<span class="token punctuation">;</span>
    <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">FD_SET</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">add_client</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">,</span> pool<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>nready<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> FD_SETSIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">/* Find an available slot */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>clientfd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/* Add connected descriptor to the pool */</span>
            p<span class="token operator">-&gt;</span>clientfd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> connfd<span class="token punctuation">;</span>
            <span class="token function">Rio_readinitb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>clientrio<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Add the descriptor to descriptor set */</span>
            <span class="token function">FD_SET</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Update max descriptor and pool highwater mark */</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">&gt;</span> p<span class="token operator">-&gt;</span>maxfd<span class="token punctuation">)</span> p<span class="token operator">-&gt;</span>maxfd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> p<span class="token operator">-&gt;</span>maxi<span class="token punctuation">)</span> p<span class="token operator">-&gt;</span>maxi <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> FD_SETSIZE<span class="token punctuation">)</span>  <span class="token comment">/* Couldn't find an empty slot */</span>
        <span class="token function">app_error</span><span class="token punctuation">(</span><span class="token string">"add_client error: Too many clients"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">check_clients</span><span class="token punctuation">(</span>pool<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">,</span> connfd<span class="token punctuation">,</span> n<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">rio_t</span> rio<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> p<span class="token operator">-&gt;</span>maxi<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>nready <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        connfd <span class="token operator">=</span> p<span class="token operator">-&gt;</span>clientfd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        rio <span class="token operator">=</span> p<span class="token operator">-&gt;</span>clientrio<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">/* If the descriptor is ready, echo a text line from it */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>connfd <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>ready_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p<span class="token operator">-&gt;</span>nready<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                byte_cnt <span class="token operator">+=</span> n<span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Server received %d (%d total) bytes on fd %d\n"</span><span class="token punctuation">,</span>
                       n<span class="token punctuation">,</span> byte_cnt<span class="token punctuation">,</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">Rio_writen</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>  <span class="token comment">/* EOF detected, remove descriptor from pool */</span>
                <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">FD_CLR</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>read_set<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token operator">-&gt;</span>clientfd<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> pool pool<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init_pool</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Wait for listening/connected descriptor(s) to become ready */</span>
        pool<span class="token punctuation">.</span>ready_set <span class="token operator">=</span> pool<span class="token punctuation">.</span>read_set<span class="token punctuation">;</span>
        pool<span class="token punctuation">.</span>nready <span class="token operator">=</span> <span class="token function">Select</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span>maxfd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pool<span class="token punctuation">.</span>ready_set<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* If listening descriptor ready, add new client to pool */</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pool<span class="token punctuation">.</span>ready_set<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">add_client</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/* Echo a text line from each ready connected descriptor */</span>
        <span class="token function">check_clients</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote>
<p>现代高性能服务器（Node.js、nginx 和 Tornado）都基于 I/O 多路复用的事件驱动的编程方式。这相比于进程和线程具有更好的性能。</p>
</blockquote>
<h3 id="io-多路复用技术的优劣">I/O 多路复用技术的优劣 </h3>
<p>基于 I/O 多路复用的事件驱动设计更加<strong>灵活</strong>，例如，可以为某些客户端提供特定的服务，为其他客户端提供其他的服务。这在基于进程的并发编程中是很困难的。</p>
<p>另一方面，基于 I/O 多路复用的事件驱动服务器运行在单一进程上下文中，每个逻辑流处于同样的地址空间，流之间共享数据很容易。可以用 gdb 等工具调试服务器。</p>
<p>但事件驱动设计的编码较为复杂，随着并发粒度的减小，复杂性还会上升。在故意只发送部分文本行然后就停止的恶意客户端攻击面前，服务器很脆弱。</p>
<p>事件驱动设计也不能充分地利用多核处理器的性能。</p>
<h2 id="基于线程的并发编程">基于线程的并发编程 </h2>
<p><strong>线程</strong>（thread）就是运行在进程上下文中的逻辑流，由内核自动调度。</p>
<p>每个线程有自己的<strong>线程上下文</strong>（thread context），包括线程 ID（Thread ID，<strong>TID</strong>）、栈、栈指针、程序计数器、通用目的寄存器和条件码。</p>
<p>所有运行在同一个进程内的线程共享此进程的虚拟地址空间。</p>
<h3 id="线程执行模型">线程执行模型 </h3>
<p>每个进程开始其生命周期时都只有一个线程，称为<strong>主线程</strong>（main thread）。主线程可以创建一个<strong>对等线程</strong>（peer thread），此后，两个线程并发地运行。它们之间的调度由内核控制。</p>
<p>线程的上下文比进程小得多，因此线程上下文切换更快。</p>
<p>线程之间也不是按照严格的父子层次组织的，和某个线程相关的线程被组织成一个对等<strong>池</strong>（pool），独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程中首个运行的线程。</p>
<p>一个线程可以杀死它的任何对等线程，或等待它的任何对等线程终止。</p>
<p>每个对等线程可以读写相同的共享数据。</p>
<h3 id="posix-线程">Posix 线程 </h3>
<p>Posix 线程（Pthreads）是在 C 中处理线程的一个标准接口。Pthreads 定义了大约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn></mrow><annotation encoding="application/x-tex">60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">60</span></span></span></span> 个函数，包括创建、杀死、回收线程，与对等线程安全地共享数据，通知对等线程系统状态变化等。</p>
<p>主线程通过 <code>Pthread_create</code> 创建一个对等线程，并为它指定例程。</p>
<p>主线程调用 <code>Pthread_join</code> 等待对等线程终止。</p>
<p>最后，主线程调用 <code>exit</code>，终止了当前进程中的所有线程（此例中，只有主线程）。</p>
<p>线程的代码和本地数据被封装在一个<strong>线程例程</strong>（thread routine）中，它的类型应当是 <code>void*(void*)</code>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>
    <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="创建线程">创建线程 </h3>
<p><code>pthread_create</code> 创建一个新线程，在新线程的上下文中以 <code>arg</code> 参数运行线程例程 <code>f</code>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：若成功则为 0，若出错则非零</span>
<span class="token keyword keyword-int">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span><span class="token operator">*</span> tid<span class="token punctuation">,</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span>
                   func<span class="token operator">*</span> f<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span> argp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>attr</code> 参数可以指定新线程的默认属性。我们不作讨论，总置为 <code>NULL</code>。</p>
<p><code>tid</code> 参数存放新线程的 TID。</p>
<p>新线程可以调用 <code>pthread_self</code> 获得它的 TID。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token comment">// 返回：调用线程的 TID</span>
<span class="token class-name">pthread_t</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="终止线程">终止线程 </h3>
<p>当顶层的线程例程返回时，线程会<strong>隐式地终止</strong></p>
<p>通过调用 <code>pthread_exit</code>，线程可以<strong>显式地终止</strong>。如果主线程调用 <code>pthread_exit</code>，它会等待所有对等线程终止，然后再终止主线程和整个进程。</p>
<p>可选参数 <code>thread_return</code> 指定了线程例程的返回值。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token comment">// 无返回值</span>
<span class="token keyword keyword-void">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> thread_return<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>某个对等线程调用 Linux <code>exit</code> 函数时，进程以及进程中的所有线程都会终止。</p>
<p>线程可以以它对等线程的 TID 作为参数调用 <code>pthread_cancel</code> 函数，终止这个对等线程。</p>
<h3 id="回收已终止线程的资源">回收已终止线程的资源 </h3>
<p>线程调用 <code>pthread_join</code> 等待其他线程终止</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则非零</span>
<span class="token keyword keyword-int">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> tid<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token operator">*</span> thread_return<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>pthread_join</code> 会阻塞，直到线程 <code>tid</code> 终止。线程例程的返回值被存放在 <code>*thread_return</code> 中。此后，线程 <code>tid</code> 的资源被回收。</p>
<p><code>pthread_join</code> 只能等待某个指定线程终止，这是一个设计缺陷。</p>
<h3 id="分离线程">分离线程 </h3>
<p>线程要么是<strong>可结合的</strong>（joinable），要么是<strong>分离的</strong>（detached）。</p>
<p>可结合的线程可以被其他线程回收和杀死，在被回收之前，它的内存资源（例如栈）不会释放。分离的线程不能被其他线程回收或杀死，它的内存资源在终止后由系统自动释放。</p>
<p>线程默认是可结合的，可以通过调用 <code>pthread_detach</code> 将可结合线程设置为分离的。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则非零</span>
<span class="token keyword keyword-int">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>高性能 Web 服务器可能在每次收到 Web 浏览器的连接请求时都创建一个新的对等线程，服务器不会愿意显式地等待每个对等线程终止，因此每个对等线程都应该分离它自身。</p>
<h3 id="初始化线程">初始化线程 </h3>
<p>线程例程的初始化由 <code>pthread_once</code> 函数完成，它保证参数函数 <code>init_routine</code> 只被调用一次。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token class-name">pthread_once_t</span> once_control <span class="token operator">=</span> PTHREAD_ONCE_INIT<span class="token punctuation">;</span>

<span class="token comment">// 返回：总是 0</span>
<span class="token keyword keyword-int">int</span> <span class="token function">pthread_once</span><span class="token punctuation">(</span><span class="token class-name">pthread_once_t</span><span class="token operator">*</span> once_control<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>init_routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>once_control</code> 变量是一个全局或静态变量，总是被初始化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PTHREAD_ONCE_INIT</mtext></mrow><annotation encoding="application/x-tex">\text{PTHREAD\_ONCE\_INIT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">PTHREAD_ONCE_INIT</span></span></span></span></span>。</p>
<p>第一次用 <code>once_control</code> 调用 <code>pthread_once</code> 时，它调用 <code>init_routine</code>。之后用 <code>once_control</code> 对 <code>pthread_once</code> 的调用将不再调用 <code>init_routine</code>。</p>
<p>这可以用于动态初始化多个线程共享的全局变量。</p>
<h3 id="基于线程的并发服务器">基于线程的并发服务器 </h3>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span><span class="token operator">*</span> connfdp<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        connfdp <span class="token operator">=</span> <span class="token function">Malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>connfdp <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> connfdp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> connfd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Pthread_detach</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Free</span><span class="token punctuation">(</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">echo</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>如果以以下方式将 <code>connfd</code> 传递给对等线程：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> connfd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><p>就会<strong>引入竞争</strong>！</p>
<p>对等线程的<strong>例程中的赋值语句</strong>和<strong>主线程下一次循环的 <code>Accept</code> 调用</strong>之间存在竞争。如果赋值语句先于下一次 <code>Accept</code>，那么程序行为是正确的。否则，赋值语句将会把已经被下一次 <code>Accept</code> 调用更新了的已连接描述符赋值给 <code>connfd</code>，导致对等线程得到错误的描述符。</p>
<p>因此，上例中我们在每次循环中，都为局部变量 <code>connfd</code> 分配一块新内存。</p>
<p>另一方面，服务器必须小心地避免内存泄漏。例程需要将自己分离，并释放参数 <code>vargp</code> 指向的内存。</p>
<h2 id="多线程程序中的共享变量">多线程程序中的共享变量 </h2>
<p>变量是<strong>共享的</strong>（shared），如果它可以被一个以上的线程访问。静态存储期的变量可以被共享，自动存储期的变量（栈上局部变量）也可以被共享。</p>
<p>我们使用以下示例介绍多线程程序中的共享变量。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">2</span></span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment">/* Global variable */</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> msgs<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token string">"Hello from foo"</span><span class="token punctuation">,</span>
        <span class="token string">"Hello from bar"</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    ptr <span class="token operator">=</span> msgs<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> myid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span>vargp<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d]: %s (cnt=%d)\n"</span><span class="token punctuation">,</span> myid<span class="token punctuation">,</span> ptr<span class="token punctuation">[</span>myid<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">++</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="线程内存模型">线程内存模型 </h3>
<p>一组并发线程运行在一个进程的上下文中，每个线程有独立的线程上下文，包括 <strong>TID、栈、栈指针、程序计数器、通用目的寄存器、条件码</strong>。</p>
<p>每个线程和其他线程共享此进程上下文的剩余部分，包括整个用户虚拟地址空间：只读的代码、可读写的数据、堆以及所有的共享库的代码和数据区域。线程也共享相同的打开文件的集合。</p>
<p>任何线程都可以访问共享虚拟内存的任意位置。</p>
<p><strong>线程的栈之间是不设防的</strong>，如果一个线程以某种方式得到了另一个线程的栈的内存地址，那么它就可以读写这个栈的任意位置。例如示例程序中对等线程可以直接通过 <code>ptr</code> 读主线程栈中的内容。</p>
<h2 id="用信号量同步线程">用信号量同步线程 </h2>
<p>以下程序展示了<strong>同步错误</strong>（synchronization error）</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// This code is buggy</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-volatile">volatile</span> <span class="token keyword keyword-long">long</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">/* Counter */</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> niters<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> tid1<span class="token punctuation">,</span> tid2<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;niters&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    niters <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>niters<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>niters<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Pthread_join</span><span class="token punctuation">(</span>tid1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Pthread_join</span><span class="token punctuation">(</span>tid2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> niters<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"BOOM! cnt=%ld\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-else">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK cnt=%ld\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> niters <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> niters<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>实际运行时，<code>cnt</code> 的值却不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mtext>niters</mtext></mrow><annotation encoding="application/x-tex">2 \times \text{niters}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord text"><span class="mord">niters</span></span></span></span></span>，这是因为 <code>cnt++</code> 不是原子操作。</p>
<p>我们将线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的循环代码分解成五部分：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>L</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>U</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i, L_i, U_i, S_i, T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> niters<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    cnt<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token comment">// x86-64 asm</span>
<span class="token function">movq</span>    <span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rcx       <span class="token comment">// H_i: Head (load niters)</span>
testq   <span class="token operator">%</span>rcx<span class="token punctuation">,</span> <span class="token operator">%</span>rcx
jle      <span class="token punctuation">.</span>L2
movl    $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax
<span class="token punctuation">.</span>L3<span class="token operator">:</span>
movq    <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token operator">%</span>rip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdx    <span class="token comment">// L_i: Load cnt</span>
addq    <span class="token operator">%</span>eax               <span class="token comment">// U_i: Update cnt</span>
movq    <span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token operator">%</span>rip<span class="token punctuation">)</span>    <span class="token comment">// S_i: Store cnt</span>
addq    $<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax           <span class="token comment">// T_i: Tail</span>
cmpq    <span class="token operator">%</span>rcx<span class="token punctuation">,</span> <span class="token operator">%</span>rax
jne     <span class="token punctuation">.</span>L3
</code></pre><p><strong>一般而言，无法预测操作系统执行线程指令的顺序是否正确</strong>。例如，下图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> 指示的顺序会产生正确的结果，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 指示的顺序中，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之前被执行，两个线程最终存储的值都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p><img src="./note-part2_files/12-18-不正确的顺序.png" alt=""></p>
<h3 id="进度图">进度图 </h3>
<p><strong>进度图</strong>（progress graph）将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个并发线程的执行模型化为一条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 维笛卡尔空间中的轨迹线。</p>
<p>进度图的每条坐标轴 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 对应于线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的进度，每个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(I_1, \cdots, I_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 代表状态：线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 已经完成了指令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">I_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>转换</strong>（transition）是从一个点到另一个相邻点的有向边，它只能是向右或者向上的。</p>
<p><img src="./note-part2_files/12-20-示例轨迹线.png" alt=""></p>
<p>对于线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，指令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>L</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>U</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L_i, U_i, S_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 构成了一个关于 <code>cnt</code> 的<strong>临界区</strong>（critival section），它不应该和其他进程的临界区交替执行。我们需要确保每个线程在执行其临界区中的指令时，拥有对共享变量<strong>互斥的访问</strong>（mutually exclusive access）。这种现象称为<strong>互斥</strong>（mutual exclusion）。</p>
<p>进度图中，两个临界区的交集形成的状态空间区域称为<strong>不安全区</strong>（unsafe region）。</p>
<p>绕开不安全去或沿不安全区边界线的轨迹线是<strong>安全的</strong>，穿过不安全区的轨迹线是<strong>不安全的</strong>。</p>
<p><img src="./note-part2_files/12-21-安全和不安全轨迹线.png" alt=""></p>
<h3 id="信号量">信号量 </h3>
<p><strong>信号量</strong>（semaphore）是一种非负整数类型的全局变量，只能由两种特殊的操作来处理：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>：
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 非零，则将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，返回</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 为零，则挂起此线程，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 变为非零后一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作重启此线程，重启后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，返回</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>：
<ul>
<li>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。如果有线程因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 为零而被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 操作挂起，则重启<strong>其中的一个</strong></li>
</ul>
</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 的测试和减法操作整体是原子的，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的加法操作（加载、加法、存储）也是原子的。</p>
<p>有多个线程等待同一个信号量时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作<strong>选择重启的线程是任意的</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 保证了正确初始化的<strong>信号量永远不会是负值</strong>，称为<strong>信号量不变式</strong>（semaphore invariant）。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 来自于荷兰语的 Proberen，意为测试<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 来自于荷兰语的 Verhogen，意为增加</p>
</blockquote>
<p>Posix 标准定义了操作信号量的函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semephore.h&gt;</span></span>

<span class="token comment">// 返回：若成功则为 0，若出错则为 -1</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// P(s)</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// V(s)</span>
</code></pre><p><code>sem_init</code> 将信号量 <code>sem</code> 初始化为 <code>value</code>。中间的参数我们总置零。</p>
<p><code>sem_wait</code> 和 <code>sem_post</code> 分别对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作，我们定义它们的 wrapper function：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token comment">// 返回：无返回值</span>
<span class="token keyword keyword-void">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">V</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="使用信号量实现互斥">使用信号量实现互斥 </h3>
<p>将每个共享变量（每组共享变量）与一个初始为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的信号量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 关联起来，然后用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作将相应的临界区包围起来</p>
<p>这种信号量称为<strong>二元信号量</strong>（binary semaphore），因为它的值只能是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。以提供互斥为目的的二元信号量也称为<strong>互斥锁</strong>（mutex）。</p>
<p>在互斥锁上执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 操作称为对互斥锁<strong>加锁</strong>，执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作称为对互斥锁<strong>解锁</strong>。称对互斥锁加了锁但还没有解锁的线程<strong>占用</strong>这个互斥锁。一个被用作一组可用资源的计数器的信号量称为<strong>计数信号量</strong>。信号量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的不可行状态定义了一个<strong>禁止区</strong>，它覆盖了不安全区。</p>
<p><img src="./note-part2_files/12-22-信号量互斥锁.png" alt=""></p>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 操作前，执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 操作；在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 操作后，执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 操作。某个线程读写共享资源时，信号量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。多个线程同时读写共享资源的状态对应的信号量为负值，因此不可能进入。</p>
<p>示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-volatile">volatile</span> <span class="token keyword keyword-long">long</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">sem_t</span> mutex<span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> i<span class="token punctuation">,</span> niters <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> niters<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><blockquote>
<p>进度图有局限性。多处理器系统中，一组 CPU / 高速缓存对共享同一个主存，这是进度图不能描述的</p>
</blockquote>
<h3 id="利用信号量来调度共享资源">利用信号量来调度共享资源 </h3>
<h4 id="生产者-消费者问题">生产者-消费者问题 </h4>
<p>生产者和消费者共享一个有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个<strong>槽</strong>的<strong>有限缓冲区</strong>。生产者线程不断生成新的<strong>项目</strong>（item），并将它们插入缓冲区。消费者线程不断从缓冲区取出并使用项目。</p>
<p>插入和取出项目都涉及更新共享变量，因此必须保证互斥。</p>
<p>如果缓冲区已满，生产者必须等待空槽出现；如果缓冲区为空，消费者必须等待新项目被插入。</p>
<p>我们开发一个简单 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SBUF</mtext></mrow><annotation encoding="application/x-tex">\text{SBUF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SBUF</span></span></span></span></span> 包，用于构造生产者-消费者程序。</p>
<p>插入时，空槽数减少，项目数增加；取出时，空槽数增加，项目数减少。我们将空槽数 <code>slots</code> 和 <code>items</code> 实现为信号量，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo separator="true">,</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">P, V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作来更新它们。</p>
<p><code>mutex</code> 是用来保护缓冲区的互斥锁</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sbuf.h"</span></span>

<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span><span class="token operator">*</span> buf<span class="token punctuation">;</span>       <span class="token comment">/* Buffer array */</span>
    <span class="token keyword keyword-int">int</span> n<span class="token punctuation">;</span>          <span class="token comment">/* Maximum number of slots */</span>
    <span class="token keyword keyword-int">int</span> front<span class="token punctuation">;</span>      <span class="token comment">/* buf[(front + 1) % n] is first item */</span>
    <span class="token keyword keyword-int">int</span> rear<span class="token punctuation">;</span>       <span class="token comment">/* buf[rear % n] is last item */</span>
    <span class="token class-name">sem_t</span> mutex<span class="token punctuation">;</span>    <span class="token comment">/* Protects accesses to buf */</span>
    <span class="token class-name">sem_t</span> slots<span class="token punctuation">;</span>    <span class="token comment">/* Counts available slots */</span>
    <span class="token class-name">sem_t</span> items<span class="token punctuation">;</span>    <span class="token comment">/* Counts available items */</span>
<span class="token punctuation">}</span> <span class="token class-name">sbuf_t</span><span class="token punctuation">;</span>

<span class="token comment">/* Create an empty, bounded, shared FIFO buffer with n slots */</span>
<span class="token keyword keyword-void">void</span> <span class="token function">sbuf_init</span><span class="token punctuation">(</span><span class="token class-name">sbuf_t</span><span class="token operator">*</span> sp<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sp<span class="token operator">-&gt;</span>buf <span class="token operator">=</span> <span class="token function">Calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sp<span class="token operator">-&gt;</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>                  <span class="token comment">/* Buffer holds max of n items */</span>
    sp<span class="token operator">-&gt;</span>front <span class="token operator">=</span> sp<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">/* Empty buffer iff front == rear */</span>
    <span class="token function">Sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Binary semaphore for locking */</span>
    <span class="token function">Sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>slots<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Initially, buf has n empty slots */</span>
    <span class="token function">Sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>items<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Initially, buf has 0 items */</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Clean up buffer sp */</span>
<span class="token keyword keyword-void">void</span> <span class="token function">sbuf_deinit</span><span class="token punctuation">(</span><span class="token class-name">sbuf_t</span><span class="token operator">*</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Free</span><span class="token punctuation">(</span>sp<span class="token operator">-&gt;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Insert item onto the rear of shared buffer sp */</span>
<span class="token keyword keyword-void">void</span> <span class="token function">sbuf_insert</span><span class="token punctuation">(</span><span class="token class-name">sbuf_t</span><span class="token operator">*</span> sp<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>slots<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Wait for available slot */</span>
    <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Lock the buffer */</span>
    sp<span class="token operator">-&gt;</span>buf<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">++</span>sp<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>sp<span class="token operator">-&gt;</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span> <span class="token comment">/* Insert the item */</span>
    <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Unlock the buffer */</span>
    <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Announce available item */</span>
<span class="token punctuation">}</span>

<span class="token comment">/* Remove and return the first item from buffer sp */</span>
<span class="token keyword keyword-int">int</span> <span class="token function">sbuf_remove</span><span class="token punctuation">(</span><span class="token class-name">sbuf_t</span><span class="token operator">*</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> item<span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Wait for available item */</span>
    <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Lock the buffer */</span>
    item <span class="token operator">=</span> sp<span class="token operator">-&gt;</span>buf<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">++</span>sp<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>sp<span class="token operator">-&gt;</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Remove the item */</span>
    <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Unlock the buffer */</span>
    <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sp<span class="token operator">-&gt;</span>slots<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">/* Announce available slot */</span>
    <span class="token keyword keyword-return">return</span> item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="读者-写者问题">读者-写者问题 </h4>
<p>一组线程访问一个共享对象，有的线程只读对象（称为<strong>读者</strong>），有的线程修改对象（称为<strong>写者</strong>）。写者必须拥有对对象独占的访问，而读者可以和无限多个其他读者共享对象。</p>
<p>第一类读者-写者问题：<strong>读者优先</strong>，除非已经将适用对象的权限赋予了一个写者。读者不会因为有一个写者在等待而等待。</p>
<p>以下是对第一类读者-写者问题的解答。</p>
<p><code>mutex</code> 保护对 <code>readcnt</code> 的访问，<code>readcnt</code> 统计当前在临界区中的读者数量。</p>
<p>通过维护 <code>readcnt</code>，读者自动形成了一个读序列。</p>
<p>第一个进入临界区的读者对 <code>w</code> 加锁，阻止写者进入临界区。最后一个离开临界区的读者对 <code>w</code> 解锁，允许写者进入临界区。同时，写者也通过 <code>w</code> 阻塞其他写者。<code>w</code> 同时实现了读序列和写者的互斥以及写者之间的互斥。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/* Solution to the first readers-writers problem */</span>

<span class="token comment">/* Global variables */</span>
<span class="token keyword keyword-int">int</span> readcnt<span class="token punctuation">;</span>        <span class="token comment">/* Initially = 0 */</span>
<span class="token class-name">sem_t</span> mutex<span class="token punctuation">,</span> w<span class="token punctuation">;</span>     <span class="token comment">/* Both initially = 1 */</span>

<span class="token keyword keyword-void">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>readcnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">/* First in */</span>
            <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Critical section */</span>
        <span class="token comment">/* Reading happens */</span>

        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>readcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Critical section */</span>
        <span class="token comment">/* Writing happens */</span>

        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>第二类读者-写者问题：<strong>写者优先</strong>，一旦有写者准备好写，它就会优先使写者完成写操作。在写者后到达的读者必须等待，即便这个写者也在等待。</p>
<p>写序列通过 <code>r</code> 对读序列加锁，读序列的入列操作需要强制获取 <code>r</code>，从而使得写序列优先于读序列。依然通过 <code>w</code> 实现读写互斥和写者之间的互斥。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> readcnt<span class="token punctuation">,</span> writecnt<span class="token punctuation">;</span>       <span class="token comment">/* Initially 0 */</span>
<span class="token class-name">sem_t</span> rmutex<span class="token punctuation">,</span> wmutex<span class="token punctuation">,</span> r<span class="token punctuation">,</span> w<span class="token punctuation">;</span>  <span class="token comment">/* Initially 1 */</span>

<span class="token keyword keyword-void">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>readcnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">/* First in */</span>
            <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span>

        <span class="token comment">/* Reading happens here */</span>

        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>readcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">/* Last out */</span>
            <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writecnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>writecnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* Writing here */</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writecnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>writecnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>对这两种读者-写者问题的正确解答可能造成<strong>饥饿</strong>（starvation），即某个线程被无限期地阻塞。例如，第一类读者-写者问题中，如果有读者不断地到达，写者就可能饥饿。</p>
<p>狒狒过峡谷问题: 狒狒分布在峡谷的东西侧，它们都想要到达对侧。峡谷之间有一条可供通过的绳索，但同时只能有一个方向的狒狒可以在绳索上，即如果绳索上同时有向西和向东的狒狒，则会死锁。</p>
<p><code>mutex</code> 表示绳索资源，<code>Wcnt</code> 和 <code>Ecnt</code> 分别表示向东和向西的狒狒的数量。<code>W</code> 和 <code>E</code> 保护对 <code>Wcnt</code> 和 <code>Ecnt</code> 的访问。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token class-name">sem_t</span> W<span class="token punctuation">,</span> E<span class="token punctuation">;</span>    <span class="token comment">/* Initially 1 */</span>
<span class="token class-name">sem_t</span> mutex<span class="token punctuation">;</span>   <span class="token comment">/* Initially 1 */</span>
<span class="token keyword keyword-int">int</span> Wcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> Ecnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">West</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>Wcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Wcnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Cross the rope */</span>

        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Wcnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>Wcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">East</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>Ecnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Ecnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Cross the rope */</span>

        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Ecnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>Ecnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote>
<p>信号量是简单、经典的同步线程的方法，但不是唯一的。<br>
Java 线程通过 Java Monitor 机制同步，它提供了对信号量互斥和调度能力更高级别的抽象。不过，它可以用信号量实现。</p>
</blockquote>
<h3 id="综合基于预线程化的并发服务器">综合：基于预线程化的并发服务器 </h3>
<p>之前的示例中，我们为每个新客户端创建一个新线程，这代价较大。</p>
<p>基于<strong>预线程化</strong>（prethreading）技术的服务器通过生产者-消费者模型降低这一开销。服务器由一个主线程和一组工作者线程组成，主线程不断地接受客户端的连接请求，并将得到的已连接描述符放在一个有限缓冲区内。工作者线程反复从这个共享的缓冲区内取出已连接描述符，为客户端提供服务。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sbuf.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NTHREADS</span> <span class="token expression"><span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SBUFSIZE</span> <span class="token expression"><span class="token number">16</span></span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">echo_cnt</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">sbuf_t</span> sbuf<span class="token punctuation">;</span>    <span class="token comment">/* Shared buffer of connected descriptors */</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clientlen<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span> clientaddr<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;port&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listenfd <span class="token operator">=</span> <span class="token function">Open_listenfd</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">sbuf_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sbuf<span class="token punctuation">,</span> SBUFSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NTHREADS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        clientlen <span class="token operator">=</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        connfd <span class="token operator">=</span> <span class="token function">Accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clientlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sbuf_insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sbuf<span class="token punctuation">,</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Pthread_detach</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> connfd <span class="token operator">=</span> <span class="token function">sbuf_remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">echo_cnt</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在开发 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>SBUF</mtext></mrow><annotation encoding="application/x-tex">\text{SBUF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">SBUF</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>RIO</mtext></mrow><annotation encoding="application/x-tex">\text{RIO}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">RIO</span></span></span></span></span> 包时，我们要求主程序显式调用初始化函数以完成初始化。而这里对于 <code>byte_cnt</code> 和 <code>mutex</code> 的初始化，我们则利用了 <code>pthread_once</code> 函数。</p>
<p>这样做的好处是使得程序包使用更加方便，代价是增加了很多对 <code>pthread_once</code> 的无效调用。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> byte_cnt<span class="token punctuation">;</span>   <span class="token comment">/* Byte counter */</span>
<span class="token keyword keyword-static">static</span> <span class="token class-name">sem_t</span> mutex<span class="token punctuation">;</span>    <span class="token comment">/* and the mutex that protects it */</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">init_echo_cnt</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    byte_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">echo_cnt</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> connfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">rio_t</span> rio<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> <span class="token class-name">pthread_once_t</span> once <span class="token operator">=</span> PTHREAD_ONCE_INIT<span class="token punctuation">;</span>

    <span class="token function">Pthread_once</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>once<span class="token punctuation">,</span> init_echo_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Rio_readinitb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">Rio_readlineb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rio<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        byte_cnt <span class="token operator">+=</span> n<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"server received %d (%d total) bytes on fd %d\n"</span><span class="token punctuation">,</span>
               n<span class="token punctuation">,</span> byte_cnt<span class="token punctuation">,</span> connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Rio_writen</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote>
<p>I/O 多路复用不是编写事件驱动程序的唯一方法。这个基于预线程化的服务器实际上也是一个事件驱动服务器。</p>
</blockquote>
<h2 id="使用线程提高并行性">使用线程提高并行性 </h2>
<p><strong>并行</strong>（parallel）程序是在同一时刻有多条逻辑流在运行的程序，它是并发程序的真子集，可以更好地利用多核处理器的性能。</p>
<p>作为示例，我们讨论如何并行地计算前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个自然数的和。</p>
<p>我们将序列划分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 个不相交的段，分配给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 个线程计算（假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的倍数）。我们将新创建线程的 TID 作为参数传递给线程例程，线程例程通过其 TID 确定自己负责的段。最后，主程序验证计算结果的正确性。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTHREADS</span> <span class="token expression"><span class="token number">32</span></span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">sum_mutex</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-long">long</span> gsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment">/* Global sum */</span>
<span class="token keyword keyword-long">long</span> nelems_per_thread<span class="token punctuation">;</span> <span class="token comment">/* Number of elements to sum */</span>
<span class="token class-name">sem_t</span> mutex<span class="token punctuation">;</span>            <span class="token comment">/* Mutex to protect global sum */</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> i<span class="token punctuation">,</span> nelems<span class="token punctuation">,</span> log_nelems<span class="token punctuation">,</span> nthreads<span class="token punctuation">,</span> myid<span class="token punctuation">[</span>MAXTHREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">[</span>MAXTHREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* Get input arguments */</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: %s &lt;nthreads&gt; &lt;log_nelems&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    nthreads <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    log_nelems <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    nelems <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> log_nelems<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nelems_per_thread <span class="token operator">=</span> nelems <span class="token operator">/</span> nthreads<span class="token punctuation">;</span>
    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Create peer threads and wait for them to finish */</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nthreads<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        myid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> sum_mutex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nthreads<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>gsum <span class="token operator">!=</span> <span class="token punctuation">(</span>nelems <span class="token operator">*</span> <span class="token punctuation">(</span>nelems <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error: result=%ld\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// psum-mutex</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">sum_mutex</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> myid <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> start <span class="token operator">=</span> myid <span class="token operator">*</span> nelems_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> end <span class="token operator">=</span> start <span class="token operator">+</span> nelems_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> i<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        gsum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在四核系统上对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">n=2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span> 的序列求和，发现结果非常古怪：<strong>多线程版本运行得比单线程还慢</strong>，而且线程数越多，性能越差。</p>
<p>这是因为<strong>同步操作（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>）的开销太大，超过了内存更新的开销</strong>。并行编程中，要尽量避免同步操作，若无法避免，则用尽可能多的有效计算弥补同步操作的开销。</p>
<p>作为改进，我们令每个对等线程在一个私有的变量中计算它们的部分和，主线程将这些部分和相加得到最终结果。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// psum-array</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> myid <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> start <span class="token operator">=</span> myid <span class="token operator">*</span> nelems_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> end <span class="token operator">=</span> start <span class="token operator">+</span> nelems_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> i<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        psum<span class="token punctuation">[</span>myid<span class="token punctuation">]</span> <span class="token operator">+=</span> i<span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>重新测试后，我们发现它比 <code>psum-mutex</code> 快了好几个数量级。</p>
<p>用局部变量消除对 <code>psum</code> 的不必要的内存引用，性能还会进一步提高。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// psum-local</span>
<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">sum_local</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-long">long</span> myid <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-long">long</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> start <span class="token operator">=</span> myid <span class="token operator">*</span> nelems_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> end <span class="token operator">=</span> start <span class="token operator">+</span> nelems_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-long">long</span> i<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    psum<span class="token punctuation">[</span>myid<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><img src="./note-part2_files/12-34-并行psum性能.png" alt=""></p>
<h3 id="刻画并行程序的性能">刻画并行程序的性能 </h3>
<p><img src="./note-part2_files/12-35-psum-local的性能.png" alt=""></p>
<p><code>psum-local</code> 的性能在线程数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 时到达最低，这是因为我们的系统是四核的。在线程数少于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 时，线程数翻倍，运行时间近似地减半；在线程数多于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 时，随着线程数增加，运行时间略微增加。</p>
<p>并行程序的<strong>加速比</strong>（speedup）定义为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo>=</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><msub><mi>T</mi><mi>p</mi></msub></mfrac><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">S_p = \frac{T_1}{T_p},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3324em;vertical-align:-0.9721em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9721em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 是处理器核心数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">T_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是程序在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个核心上运行的时间。它有时被称为<strong>强扩展</strong>（strong scaling）。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是程序顺序执行版本的运行时间时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">S_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 称为<strong>绝对加速比</strong>（absolute speedup）。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是程序的并行版本在单核上的运行时间时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">S_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 称为<strong>相对加速比</strong>（relative speedup）。</p>
<p>绝对加速比比相对加速比更能反映并行的真实好处，因为当并行程序在单核上运行时，也会受到同步开销的影响。但绝对加速比更难测量，因为它要求程序有一个顺序执行版本。</p>
<p><strong>效率</strong>（efficiency）被定义为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mi>p</mi></msub><mo>=</mo><mfrac><msub><mi>S</mi><mi>p</mi></msub><mi>p</mi></mfrac><mo>=</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mrow><mi>p</mi><msub><mi>T</mi><mi>p</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">E_p = \frac{S_p}{p} = \frac{T_1}{pT_p}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2408em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3324em;vertical-align:-0.9721em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9721em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p>
<p>它通常被表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span> 之间的百分数，衡量并行化造成的开销。高效率的程序的运行时间集中在有用的工作上，不在同步和通信上浪费过多时间。</p>
<p>加速比还有另外一面，称为<strong>弱扩展</strong>（weak scaling）。它在增加处理器核心数的同时增大问题规模，使得每个核心负责的工作量保持不变。这种语境中，加速比和效率被表达为单位时间完成的工作总量。</p>
<p>弱扩展常常是比强扩展更真实的测量值，它更接近于现实任务。</p>
<h2 id="其他并发问题">其他并发问题 </h2>
<p>我们用线程为例讨论一些并发问题，但这些问题并不仅限于线程，它们在任何并发流操作共享资源时都会出现。</p>
<h3 id="线程安全">线程安全 </h3>
<p><strong>线程安全</strong>（thread-safe）的函数在被多个并发线程反复地调用时能正确地工作。</p>
<p><strong>不保护共享变量的函数</strong>是线程不安全的。</p>
<p><strong>保持跨越多个调用的状态的函数</strong>是线程不安全的。例如以下的 <code>rand</code> 函数，它的当前调用的结果依赖于上一次调用的中间结果。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-unsigned">unsigned</span> next_seed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">/* rand - return pseudo-random integer on [0, 2^15 - 1] */</span>
<span class="token keyword keyword-int">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    next_seed <span class="token operator">=</span> next_seed <span class="token operator">*</span> <span class="token number">1103515245</span> <span class="token operator">+</span> <span class="token number">12543</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>next_seed <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">32768</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* srand - set the initial seed for rand() */</span>
<span class="token keyword keyword-void">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    next_seed <span class="token operator">=</span> seed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>当调用 <code>srand</code> 为 <code>rand</code> 指定一个种子后，单线程地反复调用 <code>rand</code> 可以得到一个可重复的随机数序列。但如果以多线程调用 <code>rand</code>，这种假设就不再成立。</p>
<p>唯一的解决方案是重写 <code>rand</code>，使它不再依赖于静态数据，而是依靠调用者在参数中传递状态信息。这不得不修改调用者的代码，非常麻烦。</p>
<p><strong>返回指向静态变量指针的函数</strong>是线程不安全的。<code>ctime</code> 和 <code>gethostbyname</code> 将计算结果放在一个静态变量里，然后返回指向这个静态变量的指针。</p>
<p>我们可以重写此函数，使得调用者传递存放结果变量的地址，这消除了共享数据，但要求更改调用者代码。</p>
<p>另一种选择是采用<strong>加锁-复制</strong>（lock-and-copy）技术。在每次调用前对互斥锁加锁，将结果复制到一个私有的内存位置，然后对互斥锁解锁。我们可以定义一个 wrapper function 包装此过程。</p>
<p>然而加锁复制有很多缺点，如引入额外的<strong>同步开销</strong>，对于复杂的结构还必须<strong>深复制</strong>。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// ctime 的一个线程安全版本</span>
<span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">ctime_ts</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token class-name">time_t</span><span class="token operator">*</span> timep<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> privatep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span><span class="token operator">*</span> sharedp<span class="token punctuation">;</span>

    <span class="token function">P</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sharedp <span class="token operator">=</span> <span class="token function">ctime</span><span class="token punctuation">(</span>timep<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> sharedp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> privatep<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>调用线程不安全函数的函数可能是</strong>线程不安全的。如果被调用的函数是第一类或第三类线程不安全函数，并且调用函数用互斥锁保护了调用，那么调用函数是线程安全的。</p>
<h3 id="可重入性">可重入性 </h3>
<p><strong>可重入</strong>（reentrant）函数是线程安全的函数的一个真子集，它们在被多个线程调用时，<strong>不会访问任何共享数据</strong>。</p>
<p>可重入函数通常比不可重入的线程安全函数更高效，因为它们不需要同步操作。</p>
<p>以下是 <code>rand</code> 函数的可重入版本，我们用调用者传递的指针参数取代了静态的 <code>next</code> 变量。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">rand_r</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span><span class="token operator">*</span> nextp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>nextp <span class="token operator">=</span> <span class="token operator">*</span>nextp <span class="token operator">*</span> <span class="token number">1103515245</span> <span class="token operator">+</span> <span class="token number">12543</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>nextp <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">32768</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>如果<strong>所有函数参数都按值传递</strong>，且引用的所有变量都是当前块作用域的自动局部变量，函数就是<strong>显式可重入</strong>（explicitly reentrant）的。</p>
<p>如果函数的参数有按指针传递的，那么它是一个<strong>隐式可重入</strong>（implicitly reentrant）的函数。如果调用者小心地传递指向非共享数据的指针，它是可重入的。<code>rand_r</code> 就是隐式可重入的。</p>
<h3 id="在线程化的程序中使用已存在的库函数">在线程化的程序中使用已存在的库函数 </h3>
<p>多数 Linux 函数，包括标准库中的 <code>malloc</code>、<code>free</code>、<code>printf</code>、<code>scanf</code> 等，都是线程安全的。</p>
<p><img src="./note-part2_files/12-41-常见的线程不安全标准库函数.png" alt=""></p>
<p><code>strtok</code> 已弃用。</p>
<p><code>asctime</code>、<code>ctime</code>、<code>localtime</code> 是在不同时间和数据格式间转换时经常使用的函数。</p>
<p><code>gethostbyname</code>、<code>gethostbyaddr</code> 和 <code>inet_ntoa</code> 是已弃用的网络编程函数，已经被可重入的 <code>getaddrinfo</code>、<code>getnameinfo</code> 和 <code>inet_ntop</code> 取代。</p>
<p>除了 <code>rand</code> 和 <code>strtok</code> 以外，这些线程不安全函数都是第三类的，它们返回一个指向静态变量的指针。</p>
<p>Linux 提供了大多数线程不安全函数的可重入版本，它们一般以 <code>_r</code> 结尾。</p>
<h3 id="竞争">竞争 </h3>
<p>如果程序的正确性依赖于<strong>某线程必须在另一个线程到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 位置之前到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 位置</strong>，那么就会发生竞争。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// This code is buggy</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"csapp.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">4</span></span></span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> myid <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from thread %d\n"</span><span class="token punctuation">,</span> myid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>以上程序中，主线程中 <strong><code>i</code> 自增运算和线程例程中第一句赋值语句</strong>之间存在竞争。</p>
<p>为了避免竞争，我们需要为每个传入的参数动态分配一个私有的内存位置。</p>
<p>注意，<strong>必须在线程例程中释放这个内存位置</strong>，否则会造成内存泄漏。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// ...</span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ptr <span class="token operator">=</span> <span class="token function">Malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token function">Pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">Pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span><span class="token operator">*</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> vargp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> myid <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Free</span><span class="token punctuation">(</span>vargp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from thread %d\n"</span><span class="token punctuation">,</span> myid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="死锁">死锁 </h3>
<p><strong>死锁</strong>（deadlock）指一组线程被永久地阻塞了。下图展示了一对用两个信号量实现互斥的线程的进度图。</p>
<p><img src="./note-part2_files/12-44-死锁进度图.png" alt=""></p>
<p><strong>程序员使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 操作顺序不当</strong>，以至于<strong>两个信号量的禁止区域重叠</strong>。两个禁止区完全包围住了死锁区域的右方和上方，使得进入死锁区域的轨迹线永远无法离开死锁区域。</p>
<p>死锁是很困难的问题，它们不可预测，极难复现。</p>
<p>使用二元信号量实现互斥时，只要遵循互斥锁加锁顺序规则，就不会发生死锁。</p>
<p><strong>互斥锁加锁顺序规则</strong>：给定所有互斥操作的一个全序，如果每个线程都以同一种顺序加锁，并以相反的顺序解锁，那么就不会发生死锁。</p>
<p>例如，在上述程序中，我们在每个线程中先对 <code>s</code> 加锁，再对 <code>t</code> 加锁，就解决了死锁问题。</p>
<p><img src="./note-part2_files/12-45-无死锁的程序.png" alt=""></p>

      </div>
      
      
    
    
    
    
    
    
  </body></html>